---
title: "Redis"
date: 2023-06-05T00:00:17+08:00
draft: false
description: ""
type: "post"
tags: ["database", "nosql", "cache"]
categories : ["full-stack"]
---

## 簡介
- NoSQL 資料庫
- 記憶體式存儲 (In-memory)
- 以鍵值對 (Key-Value) 形式存儲資料
- 支援多種資料結構，如列表 (List)、集合 (Set)、雜湊 (Hash) 等
- 高性能，適合需要快速讀寫的場景

## 使用場景
### 快取（Cache）
- 將常用資料儲存在記憶體中，避免重複從資料庫或遠端系統取得，減少 I/O 操作。
- 提升回應速度與系統吞吐量。
- 可搭配快取策略（如 Cache Aside、Read Through 等）與淘汰策略（如 LRU）靈活管理。

### 共享會話（Shared Session）
- 在無狀態（stateless）架構中，如負載平衡下的多台應用伺服器，透過 Redis 儲存 session 資料，使不同伺服器能讀寫相同使用者會話。
- 常見於 Web 架構，搭配如 Spring Session、Express-session 等框架整合。

### 分散式鎖（Distributed Lock）
- 適用於多節點協調資源使用，例如：
  - 限制某筆資料只能同時被一個實例處理。
  - 控制單一任務排程執行。
- Redis 可使用：
  - `SET key value NX EX 10` 實現具過期時間的原子鎖。
  - `SETNX` + `EXPIRE` 的組合（不推薦，存在競態問題）。
    - 這是分開的兩個操作，如果在 `SETNX` 後程式崩潰，會死鎖。
  - Redlock 演算法：Redis 官方提出的多節點鎖實作方式，提升容錯與安全性。
    - 強調了要在多台機器上取得鎖，也避免了單點故障。

### 速率限制（Rate Limiter）
- 用於防止某 IP、帳號或 API 過度請求，保護服務不被濫用。
- 常見實作方式：
  - **計數器模型**：使用 `INCR` + `EXPIRE` 記錄某時間窗內的請求次數。
  - **漏斗模型（Leaky Bucket）**、**滑動視窗（Sliding Window）** 可實現更複雜限流邏輯。
    - Leaky Bucket：將請求視為水滴，漏斗的孔洞大小決定流速。每次只允許一定數量的請求通過。滿了就拒絕
    - Sliding Window：紀錄「過去 N 秒內的請求次數」
- 可配合 Lua 腳本保證操作的原子性。

## 資料結構
Redis 支援以下幾種資料結構：

- **String**：最基本的類型，可儲存文字、數字、二進位資料
- **List**：有序串列，類似 linked list，可使用 `LPUSH`、`RPUSH`、`LPOP`、`LRANGE`
- **Set**：無序集合，不重複，常用指令：`SADD`、`SREM`、`SMEMBERS`
- **Hash**：鍵值對集合，類似物件，不支持巢狀，可儲存多個欄位：`HSET`、`HGET`
- **Sorted Set (ZSet)**：有分數排序的集合，`ZADD`、`ZRANGE`
- **Bitmap**：位元組陣列，可用於統計、計數等操作
- **HyperLogLog**：用於近似計數，節省空間。可用在大數據統計，如獨立訪客數。
- **Steam**：用於處理資料流，支援生產者/消費者模式。
  - 和 Pub/Sub 不同，Stream 支援持久化。

## 基本操作

### 啟動與連線
- ```redis-server```  
  啟動 Redis 服務，預設埠為 6379
- ```redis-cli```  
  進入 Redis 命令列介面

### 基本指令
- ```SET <key> <value>```  
  設定鍵值對，預設值為字串類型
- ```GET <key>```  
  獲取指定鍵的值
- ```DEL <key>```  
  刪除指定鍵
- ```EXISTS <key>```  
  檢查鍵是否存在
- ```KEYS <pattern>```  
  查找符合模式的鍵，例如 ```KEYS *``` 可列出所有鍵
- ```FLUSHALL```  
  清空所有資料

### 過期機制
- ```TTL <key>```  
  查看鍵的剩餘存活時間，單位為秒  
  - "-1" 表示永不過期  
  - "-2" 表示已過期
- ```EXPIRE <key> <second>```  
  設定鍵的過期時間
- ```SETEX <key> <seconds> <value>```  
  設定鍵值對並同時指定過期時間

## 持久化
Redis 支援將資料從記憶體儲存至磁碟，以防止服務重啟或異常時資料完全遺失。主要持久化方式有兩種：**RDB** 和 **AOF**，也可以同時啟用形成「混合模式」。

### RDB（Redis Database Snapshot）
定期將資料以快照（Snapshot）的形式寫入磁碟，產生 `.rdb` 檔案。
- **優點**：
  - 備份與還原速度快，檔案體積小。
  - 適合週期性備份與資料轉移。
- **缺點**：
  - 資料非即時保存，當機可能會遺失最近幾秒至幾分鐘的資料。
- **觸發方式**：
  - 自動觸發：依 `save` 設定（如 `save 900 1` 表示 900 秒內若至少有 1 次寫入即觸發）
  - 手動觸發：
    - `SAVE`：同步進行快照，會阻塞主執行緒（不建議線上使用）。
    - `BGSAVE`：異步 fork 子進程生成快照，主線程不被阻塞。
  - 

### AOF（Append Only File）
以日誌方式記錄每一筆寫入操作（set、del、incr 等），可透過重播日誌來重建資料。
- **優點**：
  - 資料持久性更高，丟失的風險相對較低。
- **缺點**：
  - 檔案體積通常較大，還原速度較 RDB 慢。
- **AOF 同步策略（appendfsync）**：
  - `always`：每次寫入都立刻同步到磁碟，最安全但效能最低。
  - `everysec`（預設）：每秒同步一次，是效能與可靠性的折衷。
  - `no`：由 OS 決定何時同步，風險較高。
- **AOF 重寫（Rewrite）機制**：
  - 為減少 AOF 檔案體積，Redis 會產生一個精簡的新 AOF 檔案。
  - 新檔案只保留必要操作來重建現有資料狀態（不影響原本的 AOF 使用）。

### 混合模式
- 結合 RDB 和 AOF 優勢  
- 在 AOF 重寫時，前段使用 RDB 格式快照，後段附加 AOF 操作日誌  
- 兼顧恢復速度與資料完整性

## 發布與訂閱 (Pub/Sub)

Redis 提供簡單的發布與訂閱機制，實現訊息的即時推播。

### 常用指令
- `PUBLISH <channel> <message>`：向頻道發送訊息
- `SUBSCRIBE <channel>`：訂閱指定頻道，接收該頻道的所有訊息
- `UNSUBSCRIBE <channel>`：取消訂閱
- `PSUBSCRIBE <pattern>` / `PUNSUBSCRIBE`：支援使用通配符的模式訂閱

### 應用場景
- 即時聊天室
- 推播通知（例如訂閱通知）
- 即時監控（如後端系統事件通報）

### 特性與限制
- **即時性**：訂閱者只能接收到訂閱之後的訊息，無法回頭讀取已發布過的訊息
- **無法持久化**：訊息一旦送出且無訂閱者，將會遺失（不像 Kafka 等系統支援儲存訊息）
- **不適用於可靠訊息傳遞**：若需要保證消息不遺失、可重播、消費確認，建議使用 Redis Stream 或 Kafka 等替代方案

## 事務與 Lua 腳本

### Redis 事務 (Transaction)
Redis 提供簡單的事務機制，允許一次送出多個指令並**順序執行**。

- `MULTI`：開始事務區塊，將後續指令加入佇列
- `EXEC`：執行所有事務中的指令
- `DISCARD`：取消事務，清空指令佇列
- `WATCH <key>`：監控指定鍵，在`EXEC`前若被其他客戶端改動則取消 `EXEC`（實作**樂觀鎖**）

> 注意：Redis 的事務**不支援回滾**，若某條指令執行失敗，其它指令仍會繼續執行。

---

### Lua 腳本
Redis 支援使用 Lua 腳本執行多個指令，並保證整段腳本的**原子性**。
注意!這裡意思是不會被其他命令打斷，不是資料庫的全部成功或全部失敗！

- `EVAL <script> <numkeys> <key1> <key2> ... <arg1> <arg2> ...`  
  執行 Lua 腳本
- `EVALSHA`：使用腳本哈希執行，提升效能（腳本需先透過 `SCRIPT LOAD` 載入）

優點：
- 支援更複雜邏輯（如迴圈、條件判斷）
- 所有指令在單一命令內執行，避免 race condition，**比 MULTI 更安全**
- 效能佳，因為避免多次網路往返（round trip）

應用情境：
- 實作複雜的鎖機制或條件更新
- 原子性變更多個 key 的狀態
- 數據過期與計數等複合操作

## 高可用與分布式架構（High Availability）
### 主從同步（Replication）
- 採用一主多從架構：
  - 主節點（Master）處理寫入操作。
  - 從節點（Replica）同步資料並處理讀取操作，實現**讀寫分離**。
- 從節點會自動與主節點保持同步：
  - 支援全量同步（initial sync）與部分同步（PSYNC）。
- 提升讀取效能，分攤主節點壓力。
- 缺點：
  - 主節點故障後需**手動切換**主從，無法自動容錯。
  
### 哨兵模式（Sentinel）
提供 Redis 的**高可用性（HA）解決方案**，能自動偵測與處理主節點故障。
- 部署多個 Sentinel 節點（建議奇數數量）來監控 Redis 主從節點狀態。
- Sentinel 機制：
  - 不斷向主從節點發送 Ping。
  - 當某 Sentinel 發現節點異常，標記為**主觀下線**。
  - 多數 Sentinel 同意後，標記為**客觀下線**，並觸發**自動故障轉移（failover）**。
  - 選出新的主節點，並通知其他從節點重新追隨（replicaof）新主。
- 優點：
  - 支援自動故障轉移與主從重組。
  - 適合中小型部署場景。


### Redis 叢集模式（Cluster）
Cluster 模式支援 Redis 的**分片（Sharding）**與**高可用性**，適用於大規模與高併發應用場景。
- Redis 預設將 key 空間分為 16384 個 **slot**，每個 slot 由某節點負責。
- 透過雜湊函數分配 key 至對應 slot。
- 每個節點負責一部分 slot，可橫向擴展寫入容量。
- 可配置主從關係，每個主節點可有 1 個以上副本（replica），確保資料備援。
- 節點間使用通常使用 16379 作為 cluster 通訊埠。

#### Cluster 的特性：
- 支援**資料自動分片**。
- 節點失效時，若有對應的 replica，系統會自動進行**主備切換**。
- 支援 slot 移動與重分配，需使用 `redis-cli --cluster` 工具手動進行。


## 常見問題與優化
- Redis 是單執行緒，但支援 I/O 多工（基於 epoll）
- 建議限制每次輸入的資料大小（避免阻塞）
- 使用 pipelining 可減少 RTT 開銷

## 快取機制

### Cache patterns
- **Cache Aside**  
  應用程式先查詢快取，若快取未命中，再查詢資料庫並寫入快取
- **Read Through**  
  應用程式只對快取發出讀請求，由快取自動讀取資料庫補齊缺失資料
  可以簡化應用程式的邏輯
- **Write Through**  
  資料寫入時，同時寫入快取與資料庫
- **Write Behind**  
  寫入時先寫入快取，再由快取延遲批次寫入資料庫
  可能導致資料不一致

### 快取常見問題與解法
- **快取雪崩 (Cache Avalanche)**  
  同一時間大量快取失效，導致請求瞬間集中打到資料庫
  - **解法**  
    為快取加上隨機過期時間，避免集中失效  
- **快取擊穿 (Hotspot Invalid)**  
  熱點資料突然失效，導致大量請求同時落到資料庫 
  - **解法**  
    - 熱點資料設為不過期（手動更新）
    - 查詢時使用互斥鎖（如分布式鎖）控制一次只由一個執行緒查詢資料庫並重建快取
- **快取穿透 (Cache Penetration)**  
  大量請求查詢不存在的資料，導致每次都打到資料庫
  - 解法：
    - 查無資料時仍寫入快取（如寫入空值並設定過期時間）
    - 在應用層加入合法性檢查
    - 使用布隆過濾器（Bloom Filter）攔截不可能存在的 key

## 記憶體管理

- **定期刪除（Periodic Deletion）**  
  Redis 每隔一段時間（預設每 100ms），隨機抽取一部分設定了過期時間的 key，檢查是否過期，若過期就刪除。  
  - 優點：不會影響正常請求  
  - 缺點：可能會有過期資料殘留，無法即時清除

- **惰性刪除（Lazy Deletion）**  
  當有請求讀取某個 key 時，才會檢查該 key 是否已過期，若過期則立即刪除並返回 nil。  
  - 優點：降低刪除成本  
  - 缺點：會讓過期資料佔用記憶體直到被讀取

Redis 實際上是 **同時使用定期 + 惰性刪除**，平衡即時性與效能。

### 記憶體淘汰策略 (Eviction Policies)
當 Redis 配置了 `maxmemory` 且記憶體超出上限時，會根據 `maxmemory-policy` 設定淘汰資料。
- **noeviction**  
  不會淘汰任何鍵。當記憶體滿了就直接回傳錯誤 
- **allkeys-lru**  
  - 對所有鍵使用最近最少使用（LRU）算法淘汰  
    - LRU：Least Recently Used，最長時間未使用的鍵會被淘汰
- **allkeys-lfu**  
  - 對所有鍵使用最不常用（LFU）算法淘汰，比 LRU 更注重使用頻率
    - LFU：Least Frequently Used，一定時間內使用次數最少的鍵會被淘汰
- **volatile-lru**  
  只針對設有過期時間（TTL）的鍵使用 LRU 淘汰  
- **volatile-lfu**  
  只針對設有過期時間（TTL）的鍵使用 LRU 淘汰
- **allkeys-random**  
  從所有鍵中隨機淘汰  
- **volatile-random**  
  從設有過期時間的鍵中隨機淘汰  
- **volatile-ttl**  
  優先淘汰剩餘存活時間 (TTL) 較短的鍵