[{"content":"邏輯上的執行順序 FROM WHERE GROUP BY HAVING DISTINCT SELECT ORDER BY DDL Data Definition Language 用來定義資料庫的結構 Create Database 1 CREATE DATABASE database_name; Create Table 1 2 3 4 5 6 CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype, .... ); Data types: INTENGER, VARCHAR(size), TEXT, etc. VARCHAR Variable-length character string Constraints 1 2 3 4 5 6 CREATE TABLE table_name ( column1 datatype constraint, column2 datatype constraint, column3 datatype constraint, .... ); Auto Increment 用來自動增加一個數值 通常用在 primary key Primary Key 用來唯一識別一筆資料 Foreign Key 用來避免資料不一致 必須是另一個 table 的 primary key 可以是 NULL 可以設置 reference action 比如 ON DELETE CASCADE Not Null 用來限制 column 不可以是 NULL Unique 不像 primary key，可以有 null Check 用來限制 column 的值，可以自己寫條件 可以用在多個 column DCL Data Control Language 用來控制資料庫的存取權限 DQL Data Query Language 用來查詢資料庫中的資料 Select 1 SELECT column1, column2, ... FROM table_name; * 代表所有的 column column column 也可以利用 operator 1 SELECT column1 + column2 FROM table_name; 可以使用 AS 來改變 column 的名稱 1 SELECT column1 AS new_name FROM table_name; WHERE 針對 row 的條件過濾 1 SELECT column1, column2, ... FROM table_name WHERE condition; ANY, ALL 用來比較子查詢的結果 1 SELECT column1, column2, ... FROM table_name WHERE column1 \u0026gt; ANY (SELECT column1 FROM table_name); 如果用 \u0026gt; ANY subquery，而 subquery 沒有任何結果，那麼就會回傳 false，因為你的數值沒有比任何一人都高（要至少一人） 如果是 \u0026gt; ALL subquery，那麼就是要比所有人都高，所以如果 subquery 沒有任何結果，那麼就會回傳 true，你的數值比裡面的東西都高 JOIN 用來結合兩個 table 1 SELECT column1, column2, ... FROM table1 JOIN table2 ON table1.column = table2.column; types INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN GROUP BY 用來將資料分組 針對 group 的條件過濾 1 SELECT column1, column2, ... FROM table_name GROUP BY column1; select 的 column 必須是 group by 的 column 或是 aggregate function HAVING 用來過濾 group by 的結果 要有 group by 才能使用 1 SELECT column1, column2, ... FROM table_name GROUP BY column1 HAVING condition; ORDER BY 1 SELECT column1, column2, ... FROM table_name ORDER BY column1; 可以指定升冪或降冪 DESC, ASC LIMIT \u0026amp; OFFSET 用來限制查詢結果的數量 DISTINCT 用來去除重複的資料 CASE 用來做條件判斷 1 2 3 4 5 6 SELECT column1, column2, ... CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ELSE result END FROM table_name; 查詢結果集合運算 UNION 用來結合兩個查詢結果 1 2 3 (SELECT column1, column2, ... FROM table1) UNION (SELECT column1, column2, ... FROM table2); UNION ALL 會包含重複的資料 UNION 會自動去除重複的資料 限制 每個查詢的 column 數量必須相同 每個查詢的 column 的資料型態必須相同 column 的順序必須相同 INTERSECT 用來取兩個查詢結果的交集 EXCEPT 用來取兩個查詢結果的差集 ALL 要加這個才會包含重複的資料 Subquery select, from, where 等等都可以有 subquery 他可以視情況回傳一個值，也可以回傳一堆 row，或是一個 column（一維向量 可以用 outer query 的 column 來當作 subquery 的條件 Correlated Subquery 一個 subquery 用到 outer query 的 value 可能導致效能問題，比如每一筆資料都要執行一次 subquery 像是兩層 for loop flattening 寫成等效的 flat query DML Data Manipulation Language 用來操作資料庫中的資料 Insert 1 2 3 INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...), (value1, value2, value3, ...) 可以一次插入多筆資料 Update 1 UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition; Delete 1 DELETE FROM table_name WHERE condition; Operators Arithmetic Operators Comparison Operators Bitwise Operators String Operators Functions Math Functions Date Functions String Functions ","date":"2024-08-25T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/sql-%E8%AA%9E%E6%B3%95%E7%AD%86%E8%A8%98/","title":"SQL 語法筆記"},{"content":"Kafka event streaming platform 專注在 publish / subscribe message 會在一段時間後被刪除，而不是等待 consumer 處理 Topic 一個特定的 data stream 一系列的 message 沒有限制 topic 的數量 由 name 來識別 Topic replication 如果有一個 broker down 了，會有另一個 broker 繼續提供複本 topic replication factor 這個 factor 要大於 1 常見的設定值是 3 這個數值代表有幾個複本 複本會被放在其他的 broker 上 設為 n，可以承受 n-1 個 broker down 一個 partition 只會有一個 broker 作為他的 leader 其他的有複本的 broker 被稱為 ISR (in-sync replica) producer 寫入的時候，只能寫到 leader consumer 預設也只會從 leader 讀取 2.4 版本後，可以設定從 ISR 讀取 Partition topic 通常會被分成多個 partition partiton 中的 message 是有序的 message 會獲得 id，他是 incremental 的 這個 id 被稱為 offset 只在特定的 partition 中有意義，不同的 partition 的 offset 是獨立的 但不同 partition 的 message 是沒有順序的，只有在同一個 partition 中才有順序 immutable 一旦 message 被寫入，就不能被修改 通常 partition 的數量至少為 consumer 數量 如果 partition 數量少於 consumer 數量，有些 consumer 會閒置 Message message 也被叫做 event 構成 required key, value, compression type, partition, offset, timestamp key, value 可以是 null timestamp 可以由系統設置 message 發給 kafka 後，會加上 partition, offset, timestamp optional header retention message 會在一段時間後被刪除 預設 7 天，可以設定 Message serialization / deserialization Kafka 會將 message 轉換成 bytes 才傳輸 用在 key 和 value 不支援的格式也可以用自訂的 serializer / deserializer ex: JSON 優點 可以用不同的語言來寫 producer 和 consumer 減少資料大小 Producer producer 會將 message 寫入到 topic producer 會知道要寫入哪個 partition send message 會帶有一個 key，可以是任何資料型態 如果 key 是 null，會以 round-robin 的方式分配到 partition 如果不是，同個 key 會被分配到同個 partition，因為有 hash function 來決定 kafka partitioner 會負責做 key hashing 預設 hash function 是 murmur2 Producer acknoledgement (ack) 有三種 ack acks=0 producer 不會等待 broker 的回應 這樣會有最高的效能，但是可能會有 message 丟失 acks=1 producer 會等待 leader 的回應 這樣會有中等的效能，但是可能發生 leader down 的情況 acks=all producer 會等待所有的 ISR 的回應 這樣會有最低的效能，但是不會有 message 丟失 Consumer consumer 會從 topic 中讀取 message 是 pull 的方式 和 producer 解耦 Push vs Pull push 沒辦法知道 consumer 能不能 handle message 如果 push 出去但 consumer 來不及消化會造成問題 pull 如果 consumer 速度比 producer 慢，可以之後慢慢補上 Consumer group 一個 application 可以有多個 consumer，共同組成一個 consumer group 同個 consumer group 中的 consumer 會共同設置一個 group id consumer group 中的所有 consumer 會以 exclusive 的方式從 partition 中讀取 message 不會有同一個 partition 被配給多個 consumer 如果 consumer 比 partition 多，有些 consumer 會閒置 group coordinator 會負責管理 group 中的 consumer 會負責分配 partition 給 consumer 利用 __consumer_offsets 來記錄 consumer group 中的 consumer 的 offset Consumer offset kafka 會紀錄 consumer group 中的每個 consumer 消耗到哪裡了 會放在 topic 的 __consumer_offsets 當 group 中的 consumer 取得 message 後，會週期性的 commit offset，讓 kafka 更新到 ＿consumer_offsets 這樣即使 consumer down 了，下次啟動時，也可以從上次消耗的地方繼續 三種 commit 策略 at least once 會在處理完 message 後才 commit 要確保處理方式是 idempotent 可以幫 message 加上 primary key at most once 會在取得 message 後就 commit exactly once Kafka broker kafka cluster 中的每個 server 都是 broker 多個連接在一起的 broker 組成一個 cluster 會有一個 broker 是 controller 負責管理 cluster 中的 broker 也管 topic 和 partition 用 id 來識別，id 是整數 broker 會包含某些 partition 也被叫做 bootstrap server 一但連到某個 broker，就可以連到整個 cluster kafka client 會處理 broker 數量考量 儲存空間 容錯 throughput Zookeeper 被用來管理 kafka broker 可以拿來幫 partition 做 leader election Zookeeper 分成 leader 和 follower Kafka 3.0 之後，可以改用 Kafka Raft 4.0 之後，會移除 zookeeper 該不該用 現在似乎 KRaft 已經準備好上 production 了 如果是 kafka client，應該盡量不使用 zookeeper CLI kafka-server-start.sh \u0026lt;config file\u0026gt; 啟動 kafka server (broker) 指定 config file --bootstrap-server 指定 kafka server 不推薦使用 --zookeeper --command-config 指定 config file 裡面會寫包含帳號密碼以及加密方式等安全設定 kaft-topics.sh --partitions 指定 partition 數量 --replication-factor 指定 replication factor --topic 指定 topic name --create delete --describe 描述 topic Replicas 顯示哪些 broker 有複本 (id) ISR 顯示哪些 broker 和 leader 同步 --list 列出所有 topic kaft-console-producer.sh --topic 指定 topic --producer.config 指定 config file --producer-property 指定 producer property acks 指定 acks 模式 --property 可以打許多次，每次指定一個 property kaft-console-consumer.sh --topic 指定 topic --from-beginning 不只是自打開 consumer 後的 message，而是從一開始的 message 開始 如果同一個 group 有多個 consumer，這個選項只會對第一個 consumer 有用，offset 是看 group 的 --consumer.config 指定 config file --property --group 指定 consumer group kafka-consumer-groups.sh --list 列出所有 consumer group --describe 描述 consumer group CURRENT-OFFSET 目前 offset LOG-END-OFFSET 最後一個 offset LAG 落後的 offset ","date":"2024-08-17T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/kafka-%E7%AD%86%E8%A8%98/","title":"Kafka 筆記"},{"content":"MongoDB 基礎 以 BSON (Binary JSON) 儲存資料 BSON 是 JSON 的二進位版本，支援更多資料型別，如日期和二進位資料 _id 欄位作為預設的主鍵 若未指定，MongoDB 會自動生成一個 12 字節的 ObjectId 用於確保文件中唯一性，特別在分散式系統中 索引機制 Composite Index 由多個欄位組成，例如 (a, b) Prefix 特性 如果索引為 (a, b)，則 (a) 也可被單獨使用 但 (b) 或 (a, b, c) 無法直接利用此索引 Hint 可強制 MongoDB 使用特定索引 用於測試或避免 optimizer 選錯索引 Explain 分析查詢 用來檢視查詢的執行計畫 重要欄位 cursor BasicCursor 表示全表掃描，應避免 BtreeCursor 表示使用索引 nscanned 掃描的索引數量 nscannedObjects 掃描的文件數量 n 最終返回的文件數量 關係：nscanned \u0026gt;= nscannedObjects \u0026gt;= n scanAndOrder 表示需要將文件載入記憶體並排序 通常一次性返回所有結果，效率較低 Optimizer 索引選擇 第一階段：尋找最佳索引 最佳索引條件 包含所有 filter 和 sort 的欄位 equality filter 必須在 range filter 之前 sort 欄位必須在 range filter 之後 若有多個最佳索引條件符合條件，隨便選擇一個 第二階段：實驗性選擇 若無最佳索引，會測試多個索引 optimizer 選擇 nscanned 最小的索引作為最終方案 儲存引擎 MMAPv1 MongoDB 早期的儲存引擎 特性 _id 直接對應 disk 偏移量 (diskloc) 查詢速度快，但更新需維護偏移量，效能低 鎖定機制 初始為 database-level lock 後期升級至 collection-level lock 已於 MongoDB 4.0 後棄用 WiredTiger MongoDB 收購並採用的新儲存引擎 特性 Document-level locking，提升並發效能 支援資料壓縮，減少儲存空間 版本演進 5.2 之前 _id 用於查找 recordid recordid 作為 clustered index，指向實際文件 5.3 之後 _id 直接成為 clustered index _id 為 12 字節 (ObjectId)，比原 64 位 recordid 更大 影響 對 secondary index 增加儲存負擔 提升跨機器和 shard 環境中的唯一性 ","date":"2024-08-16T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/mongodb-%E7%AD%86%E8%A8%98/","title":"MongoDB 筆記"},{"content":"Estimation 要評估的指標 latency throughput capacity Database 估計 沒特別指定的話，可以預估 single relational database 可以處理 read \u0026amp; write 10K per second single relational database 的容量可以抓 3 TB redis 可以抓 100K，但是受限於 memory，可能抓 30GB 可以問的問題類型 總共有多少用戶？ 有多少活躍用戶？ 每個用戶平均每天使用多久？ Network Load Balancer type application load balancer (ALB) OSI layer 7 (Application layer) 可以根據 request header, URL, query string 來做 routing 可以 validate / terminate SSL network load balancer (NLB) OSI layer 4 (Transport layer) 可以根據 protocol (TCP, UDP, IP..), destination port etc 來做 routing 一般來說預設會 pass through SSL 比較適合應付高流量 strategy round robin 輪流 least connection resource-based 考慮每個 instance 的資源使用情況 weighted variants of the above 可以把上面說的各種情況多加入 weight 的考量 random 優點 resilience 可以關注到某個 instance down 了，自動把 request 轉到其他 instance scalability 後面的 instance 可以 horizontal scale 和 API Gateway 的差異 API Gateway 除了 load balancing 會有更多的功能，例如 rate limiting, authentication, authorization, request validation, caching, logging etc Protocol \u0026amp; Send/Receive data TCP UDP http websocket duplex (two-way) communication 只會建立一次 TCP connection load balancer 可以會遇到問題 long polling client 送 request 給 server，server 不會立刻 close connection，而是等待有新資料或 timeout 才回應 某些不能用 websocket 的情況下，可以用 long polling 來模擬 但是在一些框架或語言可能不好實作 gRPC RPC remote procedure call 把一些 service 包裝成像 local function 一樣，就可以像調用本地函式一樣使用 remote 的服務 google 開發的 RPC 框架 用 protobuf 作為 IDL (Interface Definition Language) binary protocol 非 readable，需要 encode / decode 但比 json 小 .proto file 定義 message 的格式 描述了 interface 長怎樣 protoc 用來 compile .proto file，根據指定的程式語言，產生 client / server code server 再實作 interface 用 http/2 來傳輸 不能用在 browser 適合用在內部服務之間的溝通 GraphQL 流程 User perspective 描述身為 user 期待看到什麼東西 這裡可以先簡單介紹這個 app 的大概邏輯，之後 marketplace 再針對不同 role 探討資料和使用情境 也可以詢問使用的平台 Marketplace 詢問要支援的用戶數量，以及活躍用戶數量 如果有多種用戶，也要分開討論 ex: 叫車服務會有司機和乘客 有更多角色後，可以開始根據角色討論他們的 perspective 取得一些數字 考慮 sotrage 以及 throughput 叫車服務範例 乘客總數量、活躍乘客數、每月乘客需求趟數 司機總數量、活躍司機數、單趟平均時間 throuput 活躍用戶 refresh rate 每個 user 平均打開 app 的次數 平均打開 app 會用多久 Rough design 探討資料的傳遞 根據不同 role 去講他們應該傳送什麼資料，用什麼協定，request 的頻率 (request per second) 討論的時候可以用 average，但是會有 peak time，可以考慮 X2, X4, X10 探討資料的儲存 要準備一些前提，比如假設單一資料庫每秒可以 insert 5K 筆資料 可以討論不同的 sharding 考慮怎樣存可以讓大小減少 評估這樣分是否可能導致 sharding uneven 怎樣的切法可以讓 query 盡量不要跨 shard 每個階段也可以探討 throughput 開始根據情境設計不同的 service 來表達他們的交互 Tips 查找 能不能用地理資訊來做 hashing 能不能用 geo index 工具 \u0026amp; 技術 headless browser 沒有 user interface 的 browser 但是依然有 rendering engine 和 js interpreter。可以用來得到最終的 html Cyclic redundancy check (CRC) 一般用在檢查封包是否有錯誤，但是我們也可以用來檢查某個檔案是否有被修改，好做 sync CQRS (Command Query Responsibility Segregation) 把 read 和 write 分開 一個 storage 針對 read 做 optimize，另一個 storage 針對 write 做 optimize Unique ID UUID 是 random 且 human-readable（不會有相近的 char，比如 0 和 O） 但是太長 可以用不同的 encoding 壓縮長度 因為 UUID 用的 charactor 是 0-9, a-f，所以可以用有更多種 charactor 的 encoding 來壓縮 BASE62 包含 0-9, a-z, A-Z BASE58 BASE62 但不包含容易混淆的 0, O, I, l BASE64 BASE62 但多了 +, / Other 每個 Phase 可以多和 interviewer 討論，確認走在正確的方向上 面對面試官給的數字可以嘗試為了好算向上抓一些 延遲任務 如果遇到因為某些原因需要晚點才能做某個任務，可以用 queue 來處理 Cache 除了用專門的 cache database 做，Server 自身也可以用 memory 來 cache 對於先搶先贏的系統不一定要追求公平，只要達成目標即可 對於搶票機制可以做 pre-populate，事先在 database 生好指定數量的票，這樣就可以只 lock 某個 row，不用 lock 整個 table ","date":"2024-08-03T00:08:46+08:00","permalink":"https://roykesydon.github.io/Blog/p/system-design/","title":"System Design"},{"content":"Transaction 一個或多個操作的集合 一個 transaction 要不全部執行，要不全部不執行 即使程式中未顯式使用 transaction，資料庫也會自動為操作包裹一個隱式的 transaction lifespan begin commit rollback Atomicity 一個 transaction 要不全部執行，要不全部不執行 在 commit 前不管因為任何理由失敗，都該 rollback Consistency 符合當初制定的規則 (ex: 設置的 foreign key 指向的資料一定要存在) referential integrity 保證 primary key 和 foreign key 之間的關係 Eventual consistency 最後一定會 consistent，儘管過程中可能會出現短暫的不一致 Isolation 一個 transaction 的執行不應該影響其他 transaction read phenomena dirty read 一個 transaction 讀到了另一個 transaction 已經寫了但還沒 commit 的資料。這個資料有可能被 commit 也有可能被 rollback non-repeatable read 一個 transaction 兩次讀取同個資料時，得到的資料不一樣因是因為有其他 transaction 更新了這個資料（已經 commit 了） 和 dirty read 不同的是，這個資料是已經 commit 的 phantom read 也是第一次和第二次讀取的資料不一樣，第二次發現多了額外的資料，這次是因為有其他 transaction 寫入了新的資料（並且 commit 了） 之所以要和 non-repeatable read 分開，是因為他這裡沒辦法簡單的靠鎖起來已經讀過的資料，因為你沒辦法鎖你本來看不到的資料 系統設計遇到這問題可以考慮用 pre-populate 的方式，把所有可能的資料都先創好，就可以個別鎖住 lost update 我更新了某筆資料，但是在 commit 之前，有其他 transaction 也更新了這筆資料，並且 commit。我再去讀取這筆資料時，發現我更新的資料就被覆蓋了 double booking problem 當兩個 transaction 同時搶更新同個資源就有可能遇到該問題 example 兩個 transaction 都先 select 再 update 他們兩個 select 都先看到有空位，然後一前一後更新，就會造成 double booking Isolation level 為了解決 read phenomena，資料庫提供了不同的隔離等級 不同的隔離等級會影響到 transaction 之間讀取資料的方式，以達到不同的資料一致性要求 不會影響自身 transaction 前面所 write 的資料 read uncommitted No isolation 可以看到其他 transaction 還沒 commit 的資料 所有的 read phenomena 都有可能發生 read committed 只能看到其他 transaction commit 的資料 許多資料庫的預設隔離等級 除了 dirty read 之外，其他 read phenomena 都有可能發生 repeatable read 確保同一筆資料在同一個 transaction 中讀取時，結果是一樣的 phantom read 還是有可能發生 snapshot 保證 transaction 得到的資料是一致的 只會看到 transaction 開始時的 snapshot read phenomena 都不會發生 好像不是所有資料庫都有這個隔離等級，也有些 repeatable read 就是用 snapshot 來實現的 比如 PostgreSQL 就是用 snapshot 來實現 repeatable read 但這不代表不會遇到問題，請參考 double booking problem serializable 最高隔離等級 保證所有 concurrent transaction 執行起來會和依序執行的效果一樣 如果 transaction 不會彼此影響，還是有可能會讓 transaction 並行執行 read phenomena 都不會發生 和要求 exclusive lock 相比，有可能實現方法是遇到衝突會 fail Durability 一旦 transaction 完成，資料應該要 persistent 完成的 transaction 會被記在 non-volatile storage durability technique Write ahead log (WAL) 先寫 log (寫你做了什麼操作，但不去真的改 disk 上對應的資料)，有空再修改 這樣一些修改就可以改在 memory，如果 crash 了，可以用 log 來 recover 而且考量硬碟限制，如果你想修改的資料遠小於硬碟可寫的最小單位，會很浪費 Asynchronous snapshot 在後台把 snapshot 寫到 disk ","date":"2024-07-21T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/database-transactions-and-acid-properties/","title":"Database Transactions and ACID Properties"},{"content":"資料庫核心概念 儲存結構 Table 資料庫中最基本的儲存單位，用來組織資料 Row_id 多數資料庫會維護一個唯一的 row_id，也稱為 tuple id，用來識別每一行資料 例如 PostgreSQL 使用 OID 或 ctid，MySQL 則依賴主鍵 Page 多個 row 會被儲存在一個 page 中 讀取時不會單獨讀取某個 row，而是以 page 為單位讀取一或多個 page IO IO 操作指的是存取磁碟的操作 一次 IO 可能讀取多個 page，也可能直接從 cache 中取得資料 資料庫常利用 cache（如 buffer pool）來減少 IO 若查詢速度很快，可能是因為資料已存在 cache 中 Heap 用來儲存整個 table 的資料，是一種無特定順序的結構 若使用 clustered index 組織資料，則不會有獨立的 heap 例如 MySQL InnoDB 的主鍵就是 clustered index，資料直接依主鍵排序儲存 資料儲存方式 Row-oriented (行導向) 每個 row 依序儲存，包含所有 column 的資料 一次 IO 會讀取多個 row，每個 row 包含所有欄位 適合 OLTP（線上交易處理），因為常需要存取整行資料 Column-oriented (列導向) 每個 column 依序儲存，同一 column 的資料連續存放 壓縮效率高，且適合 aggregation 操作，因此常用於 OLAP（線上分析處理） 碎片化 (Fragmentation) Internal Fragmentation (內部碎片) 一個 page 中有許多未使用的空間 可能因為 row 刪除或大小不均導致，例如插入時預留空間過多 External Fragmentation (外部碎片) 多個 page 的儲存位置不連續 即使剩餘空間足夠，因不連續而無法使用，需透過整理（如 vacuum）來解決 資料結構與索引 常用資料結構 B-Tree 一種平衡樹結構，適用於快速搜尋 每個 node 同時儲存 key 和 value 限制 由於 node 儲存完整資料，空間利用率較低 range query 效率較差，因為需要多次隨機存取 B+Tree B-Tree 的改良版本，常用於資料庫索引 特性 internal node 只儲存 key，leaf node 儲存 key 和 value 因 internal node 只存 key，元素大小較小，一個 node 可容納更多 key，使存取的結點數變少，提升搜尋效率 leaf node 用 linked list 串聯，適合 range query 通常一個 node 對應一個 DBMS 的 page LSM-Tree (Log-Structured Merge-Tree) 設計為追加式寫入，資料加在尾端，不覆蓋原有資料 優勢 對 SSD 友好，因避免隨機寫入 適合高寫入量的場景 與 B-Tree 比較 B-Tree 為保持平衡會頻繁調整結構，導致隨機 IO 索引基礎 索引的作用 若欄位未建立索引，查詢需掃描整個 table 索引透過 pointer 指向 heap 或資料位置，加速查詢 索引本身也儲存在 page 中 搜索方法 Table Scan 掃描整個 table，適用於範圍過大或無索引的情況 通常以 parallel 方式執行，提升效率 Index Scan 利用索引定位資料，再從 heap 取值 Index-only Scan (Covering Index) 若所需欄位已包含在索引中，無需存取 heap 優勢 速度快，因避免額外 IO 注意 索引過大可能佔用更多記憶體，甚至觸發磁碟 IO，降低效率 Composite Index 將多個 column 作為 key 建立索引 特性 在 PostgreSQL 中，若索引為 (a, b)，查詢 a 可使用索引，但單獨查 b 無法有效利用 順序影響查詢效率，設計時需考慮常用條件 Non-key Column 可透過 include 將常用但非 key 的欄位加入索引 促成 index-only scan，提升查詢速度 索引類型 Clustered Index (叢集索引) 資料依索引順序物理儲存，也稱 Index-Organized Table 特性 一個 table 只能有一個 clustered index，因資料只能按一種順序排列 未指定時，primary key 通常作為 clustered index（如 MySQL InnoDB） 優勢 範圍查詢效率高，因資料已排序 Primary Key vs Secondary Key Primary Key 通常用於 clustered index，資料圍繞其排序 若查詢小範圍資料，因有序可減少 IO 設計差異 PostgreSQL 不強制 clustered，primary key 只是唯一約束 MySQL InnoDB 則將 primary key 作為 clustered index Secondary Key 不在乎原本 table 的 order，而是根據自訂的 key 來排序 會有另外一個結構去放 index，可以找到 row_id 用途 提供額外的查詢路徑 設計差異 PostgreSQL 所有索引（包括 primary 和 secondary）直接指向 row 優勢：secondary index 可直接取資料，不用再跳一層 primary key 劣勢：更新 row 時，若 row_id 改變，所有索引需同步更新 MySQL secondary index 指向 primary key，再由 primary key 指向 row 優勢：row 更新時只需調整 primary key 的指向 劣勢：查詢需多跳一次，增加 IO 資料模型與類型 資料類型 設計原則 設計 column 時，應先確認資料庫提供的資料類型，選擇最適合的類型以提升效能與儲存效率 以 PostgreSQL 為例 Numeric 整數 (integer)：如 smallint、integer、bigint 浮點數 (float)：如 real、double precision Serial：自動遞增（auto increment）的整數，常用於主鍵（如 serial、bigserial） Character char(n)：固定長度字串，空間不足時補空白 varchar(n)：可變長度字串，指定最大長度 text：無長度限制的字串，等同於未指定長度的 varchar bpchar：好像就是 varchar，但是 document 有寫 blank trimmed Date / Time 如 date、time、timestamp，提供日期與時間儲存 Boolean true/false 或 null Binary bytea：儲存二進位資料 Geometric 提供點 (point)、線 (line)、多邊形 (polygon) 等類型 應用：若需儲存二維平面座標，可用 point 替代兩個 float UUID 通用唯一識別碼，適合分散式系統生成唯一 ID Enum 自訂有限字串集合，按建立順序有序 應用：狀態欄位（如 \u0026ldquo;pending\u0026rdquo;、\u0026ldquo;completed\u0026rdquo;） 分割 (Partitioning) 定義 將大 table 分成多個小 table，以提升效能或管理便利性 類型 Vertical Partitioning (垂直分割) 按 column 分割 應用 將不常用或大型欄位（如 blob）獨立出來 可將這些欄位放在較慢的磁碟，保留常用欄位在 SSD 減少不必要欄位進入 cache Horizontal Partitioning (水平分割) 按 row 分割 應用 根據範圍（如時間、地域）分割資料 優點 單一 partition 的單次查詢更快 對 sequential scan 有幫助，因範圍縮小 可將舊資料移至較便宜的儲存設備 缺點 跨 partition 移動資料效率低 若查詢需掃描所有 partition，可能比未分割的 table 更慢 partition 大小可能不均（unbalance），需設計均衡策略 資料庫游標 (Database Cursor) 用途 處理大型結果集時，避免一次傳送所有資料給 client（因網路與記憶體限制） 類型 Server-side Cursor 伺服器分批傳送資料給 client 優勢：減少 client 記憶體需求 劣勢：多次網路往返可能增加總時間 Client-side Cursor 一次傳送所有資料，由 client 分批處理 優勢：減少伺服器負擔 劣勢：需較大網路頻寬與 client 記憶體 分散式系統 分片 (Sharding) 定義 將 table 分成多個 shard，分散至不同資料庫伺服器 與 Horizontal Partitioning 的差異 Horizontal Partitioning：分割後仍位於同一資料庫，由 DBMS 管理 Sharding：分割後分至不同伺服器，client 需自行處理資料位置 挑戰 交易 (transaction) 與 join 操作變得複雜，因資料分散 需額外設計一致性與資料存取邏輯 分片鍵 (Sharding Key) 類型 Hash 使用 hash function 決定資料分配 優勢：分佈均勻 劣勢：範圍查詢困難 Range 根據某 column 的範圍（如時間、ID）分配 優勢：支援範圍查詢 劣勢：可能導致熱點（hotspot） Dictionary 根據離散值（如地區、類別）分配 優勢：直觀且易管理 劣勢：擴展性受限 設計考量 Cardinality 鍵值的種類數量，種類過少限制水平擴展 Frequency 鍵值的分佈頻率，需避免單一 shard 負載過高 Monotonicity 若鍵值單調遞增或遞減，可能導致新資料集中於某 shard 解決方式：結合 hash 或隨機前綴 資料庫複製 (Database Replication) 目的 透過 redundancy 來提高 reliability, tolerance, accessibility 類型 Master / Backup Replication (主從複製) 單一 master 負責寫入，多個 backup（slave）負責讀取 模式：一寫多讀 應用：讀多寫少的場景（如內容管理系統） Multi-master Replication (多主複製) 多個 master 可同時寫入 挑戰：需處理寫入衝突（如使用版本控制或衝突解決策略） 應用：高可用性與分散式寫入需求 同步方式 Synchronous (同步) transaction 完成前需等待所有 backup 寫入確認 變體：可設定等待前 N 個或任一完成 優勢：資料一致性高 劣勢：延遲增加 Asynchronous (非同步) transaction 寫入 master 後即完成，後台同步至 backup 優勢：寫入速度快 劣勢：可能出現資料不一致（若 master 故障） 應用 常見於負載平衡與災難恢復設計 並發與交易管理 並發控制策略 Pessimistic (悲觀) 使用鎖定機制確保交易隔離 適用於衝突頻繁的場景 Optimistic (樂觀) 不使用鎖，假設衝突少見，若發生衝突則交易失敗並重試 適用於讀多寫少的場景 鎖定機制 (Lock) 類型 Shared Lock (共享鎖) 多個交易可同時持有，適用於讀取 其他交易可再設置 shared lock Exclusive Lock (排他鎖) 僅一個交易可持有，適用於寫入 禁止其他交易讀取或寫入 PostgreSQL 提供 SELECT ... FOR UPDATE 來取得 exclusive lock 相容性 若資料已持有一種鎖，其他交易無法設置另一種鎖 例如：shared lock 下無法設置 exclusive lock，反之亦然 死結 (Deadlock) 定義 多個交易互相等待對方釋放鎖，導致無法繼續執行 處理 多數 DBMS 會檢測死結，並強制回滾最後造成死結的交易 兩階段鎖定 (Two-Phase Locking, 2PL) 目的 DBMS 為了實現 isolation 需要保證 conflict serializability (CSR)，2PL 可以保證這一點 階段 Growing Phase (增長階段) 交易只能申請鎖 Shrinking Phase (收縮階段) 交易只能釋放鎖 限制：釋放任一鎖後，交易無法再申請新鎖 特性 一個交易釋放鎖後，無法再取得鎖 保證一致性，但可能導致死結 應用於多數關聯式資料庫的交易管理 實作與優化 資料庫引擎 (Database Engine) 定義 也叫 storage engine 或 embedded database，負責處理 CRUD 操作的核心庫 功能 DBMS 基於引擎提供更高階功能（如查詢優化、交易管理） 範例 MySQL 的 InnoDB（支援交易與外鍵）、MyISAM（高效讀寫但無交易） SQLite 本身即為嵌入式引擎 物件關聯映射 (ORM) 載入策略 Eager Loading (積極載入) 一次載入所有相關資料 範例：查詢 Teacher 時一併載入所有 Student 優勢：減少後續查詢次數 劣勢：可能載入過多不必要資料 Lazy Loading (延遲載入) 僅在需要時載入相關資料 優勢：節省初始載入時間與記憶體 劣勢：可能導致多次 IO Open Session in View (OSIV) 每個 http request 開啟一個資料庫 session 用途：配合 lazy loading，確保 request 期間資料可隨時載入 注意：可能延長 session 存活時間，增加資源占用 N+1 Problem 查詢主表後，對每個主表記錄再查詢子表，導致 N+1 次 IO 範例：查詢 10 個 Teacher，再各查其 Student，共 11 次查詢 解決方式：使用 join 或 eager loading 合併查詢 效能優化與實務建議 避免使用 Offset Offset + Limit 是簡單的 pagination 實現，但 offset 需讀取並丟棄前 n 筆資料 替代方案：使用條件（如 WHERE id \u0026gt; last_id）追蹤分頁位置 連線池 (Connection Pool) 維護固定數量的資料庫連線，避免頻繁建立與關閉連線的開銷 等幂鍵 (Idempotency Key) 確保同一 request 只執行一次 實現 生成唯一鍵（如 ULID），隨 request 傳送並記錄 重複鍵時拒絕執行 ULID 優勢 包含時間戳記，可排序且集中於相近 page 相較 UUID 的隨機性，減少 IO 與 buffer 壓力 一致性雜湊 (Consistent Hashing) 將 hash 結果映射至環狀結構，分配資料至伺服器 優勢 新增或移除伺服器時，僅影響部分資料重分配 可針對負載高的伺服器動態調整 寫入放大 (Write Amplification) 實際寫入磁碟的資料量超出預期 分很多不同 level，通常是在說 SSD 造成的 原因 SSD 更新時，需將整個 block 搬移至新位置並標記舊 block 為 free 想更新的時候，更新的 page 會被標記為不能使用。為了那些不能再被使用的空間搬整個 block 多型關聯 (Polymorphic Association) 單一欄位根據情況指向不同 table 的 id 優勢：節省空間與表數 劣勢：無法直接使用 foreign key，需額外邏輯處理 替代方案：拆為多欄位或多表，增加明確性 ","date":"2024-07-21T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/database-%E4%B8%80%E8%88%AC%E7%AD%86%E8%A8%98/","title":"Database 一般筆記"},{"content":"Pipeline 名詞 Artifact 你需要用到的檔案，可能是 build 出來的檔案，或是跑測試用的專案 ex: .jar, .war Type Build pipeline Release pipeline azure-pipelines.yml 可以 create pipeline，在專案中加入該檔案，Azure DevOps 會自動偵測並執行 用於 build pipeline trigger 指定哪些 branch 有 push 時，要執行 pipeline Variables 可以設定變數，用在 yaml 中 Task 可以搜尋各種 task 來完成任務 copy files publish build artifacts Release pipeline 把 build 出來的 artifact，部署到指定的環境 artifact 上方的閃電，可以設置當有新的 artifact 時，自動觸發 release create release 執行 CI/CD Agent pool 可以加入自己的 agent，也就是自己的 server Board Work item Epic 一個非常 high level 的需求 Issue 把 Epic 拆成小的需求 在敏捷也可以稱為 User Story Task 再把 Issue 拆成更小的需求 Backlog PO 創建的 Issue，會在 Backlog 中 可以把 Issue 拖拉到 sprint 中 可以結合 git repo，把 commit 或 branch 關聯到 Issue Sprint 在這可以新增 sprint 也有 task board，列出所有 task 可以設置 task 的狀態以及指派人員 ","date":"2024-07-20T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/azure-devops-%E7%AD%86%E8%A8%98/","title":"Azure Devops 筆記"},{"content":"File Uploaded Vulnerability 防禦方法 不要允許使用者上傳任何可執行的檔案 檢查 file type 和 file extension file type 指的是 header 的 Content-Type 用某些套件分析檔案，並重新創建和重新命名檔案 Code Execution Vulnerability 允許攻擊者執行 OS command 防禦方法 不要使用危險的 function 透過 filter 檢查輸入 比如利用 regex File Inclusion Vulnerability LFI (Local File Inclusion) Vulnerability 攻擊者可以讀取伺服器上的任何檔案（包含 /var/www 外的檔案） 透過輸入讀其他檔案的時候沒有檢查檔案路徑 可以用來讀 /proc/self/environ，可能會存在一些可以透過 request 修改的變數。植入PHP 程式碼便有可能被執行 RFI (Remote File Inclusion) Vulnerability 和 LFI 類似，但是檔案來自外部 可以在當前 server 執行其他 server 的 php 程式碼 可以在其他 server 以 .txt 存 php file 防禦方法 避免 remote file inclusion php 的話可以關掉 allow_url_fopen 和 allow_url_include 避免 local file inclusion 用 static file inclusion，不要透過變數去取得檔案位置 SQL Injection 防禦方法 使用 prepared statement XSS (Cross Site Scripting) 允許攻擊者在網頁上執行 javascript code 執行在 client 端，不是 server 端 Main types Reflected XSS 用 URL 攻擊 Persistent/Stored XSS 攻擊的程式碼存在 database 或是某個 page DOM-based XSS 利用前面的方法，透過開發者不當操作 DOM 來攻擊 ex: 攻擊者透過 .innerHTML 放入 script tag Exploitation BeEF Framework 可以把目標 hook 到 beef 可以透過 beef 對被 hook 的目標做各種操作 防禦方法 盡量避免讓 user 的輸入直接顯示在網頁上 在 insert 到網頁前，escape 所有不信任的輸入 把這些 character 轉換成 HTML 用的格式 ex: \u0026lt; -\u0026gt; \u0026amp;lt; CSRF (Cross Site Request Forgery) 防禦方法 Anti CSRF token 生表單的時候也生一個 token，並記住，request 要帶上這個 token unpredictable can\u0026rsquo;t be reused 前後端分離 後端生 CORS 不要接受所有來源，讓前端取得 token 前端生 要發 request 的時候把 cookie 改成和 token 一樣的值 Backdoor msfvenom msfconsole Anti-Virus Principle Static Analysis 和已知的 malware 比對 可以利用 packers, encoders, abfuscators 來讓程式更加獨特 Dynamic(Heuristic) Analysis 在 sandbox 中執行，看他的行為 要幫程式增加安全的操作 延遲 Payload 執行的時間 ","date":"2024-06-28T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/web-security/","title":"Web Security"},{"content":"Terms Incremental vs Iterative Incremental 透過多個 increment（增量）逐步構建專案，每個增量都是可運行的部分功能，並在後續開發中持續擴充。 Iterative 建立 prototype（原型），然後反覆改進，每次迭代都基於上一版本進行調整與優化。 Model Type Linear/Predictive 適用於具備類似專案經驗的情境 擁有明確的開發流程 變更空間極小，需求需在開發前確定 Flexible/Adaptive 適用於新創概念或需求尚不明確的專案 專案可能隨時間變更，因此需具備較高的靈活性 Waterfall Model 像瀑布一樣，一個階段完成後才能進入下一個階段 典型流程： Requirement → Design → Implementation → Testing → Deployment → Maintenance 高度預測性（Predictive），變更成本極高，彈性低 問題點： 若在 Testing 階段發現重大缺陷，可能需回溯至 Requirement 重新開始 隨著進度推進，修正成本（fix cost）將大幅增加 需要在每個階段做詳細規劃，以降低風險 用戶直到後期才會看到可運行的成果 Incremental Model 在整個開發過程中，將系統劃分為 多個增量（increments） 來逐步開發與交付 每個增量都具備可運行的功能，並能獨立部署 各個增量的目標與功能範圍需事先定義，以確保最終整合 Agile 一種思維方式，而非特定的開發模型 Agile Manifesto（敏捷宣言） Individuals and interactions over processes and tools（個人與互動高於流程與工具） 若團隊決定使用新的工具，應優先考量團隊的需求，而非僅僅依賴過去習慣的工具 Working software over comprehensive documentation（可運行的軟體高於完備的文件） 文件很重要，但單純依賴大量文件無法讓客戶提供有效回饋 Customer collaboration over contract negotiation（與客戶合作高於合約談判） 強調持續與客戶溝通，以確保專案方向正確，而不是只關注合同上的條款 Responding to change over following a plan（回應變化高於遵循計畫） 在變化快速的環境下，適應需求變更比僵化地執行既定計畫更重要 瀑布式開發的缺點（Agile 解決的問題） 技術環境變化迅速，Agile 讓開發更具適應性 傳統開發方法往往因為考量成本，不容易應對變更 而 Agile 透過 小的增量（increment） 來持續調整方向，降低風險 軟體需求無法 100% 預測 早期規劃的需求可能與最終需求不符，因此 Agile 強調 持續交付與回饋 系統可能不符合用戶需求 透過 迭代開發（iterative development），確保用戶能夠在開發過程中參與並提供反饋 市場變化快速 Agile 強調 MVP（最小可行產品），讓團隊能在短時間內推出核心功能，以快速測試市場反應 Kanban 以視覺化方式管理工作流程 透過卡片（Kanban 卡）來追蹤工作項目 能夠直觀地發現某個工作階段是否積壓過多任務 核心屬性（Properties） Visualize workflow（視覺化工作流） Limit work in progress（限制在製作業務量） Manage flow（管理工作流） Make process policies explicit（明確定義流程規則） Improve collaboratively（透過協作持續改進） 核心原則（Principles） Start with what you do now（從現有流程開始） Agree to pursue incremental, evolutionary change（追求漸進式改變） 並非一次性顛覆整個流程，而是逐步優化 Respect the current process, roles, responsibilities \u0026amp; titles（尊重現有流程、角色、職責與職位） Encourage acts of leadership at all levels（鼓勵各層級展現領導力） Leadership 不僅指管理職責，也包含主動解決問題、協助他人、激勵他人 工作欄位（Work Columns） Backlog（待辦事項） Analyze（需求分析） Develop（開發） Test（測試） Release（發布） Scrum Scrum 核心概念 Scrum 是敏捷開發框架，透過迭代式的開發方式，提高軟體交付的效率與適應性。 主要流程包括 Sprint Planning、Daily Scrum、Sprint Review 和 Sprint Retrospective。 角色與職責 1. Product Owner 負責確保產品的價值最大化 職責： 維護 健康的 Product Backlog（保持任務清晰、優先順序合理） 與 利害關係人 溝通，確保開發方向符合需求 定義 Acceptance Criteria（驗收標準） 管理 預算與 Release 計畫 2. Scrum Master 確保 Scrum 流程正確執行 職責： 促成 Daily Standup，確保討論聚焦 移除障礙，幫助團隊專注於開發 培養 Scrum 文化，確保團隊理解並實踐 Scrum 的價值觀 Servant Leader - 有一點領導，但和大家平等。促成團隊工作而不是指揮別人 3. 開發團隊（Dev Team） 包括工程師、設計師、測試人員等 目標： 與 Product Owner 合作撰寫 User Stories 開發、測試、確保功能符合定義的需求 參與 技術設計、研究與原型開發 Scrum 流程 1. Product Backlog 由 Product Owner 負責維護，內容包含： 優先度 預估花費時間 負責的人 2. Sprint Planning Meeting 目標：將 Product Backlog 轉換為 Sprint Backlog 角色分工： Scrum Master 確保會議高效進行 如果有講太久的部分，可能稍後再排單獨會議 確保一切都和 sprint goal 一致 Product Owner 準備好 product backlog 澄清 product backlog 的細節 要準備好描述 acceptance criteria 比如搜索速度要多快？ Dev Team 拆解任務、估算工作量、選擇可完成的任務 3. Sprint Backlog 本次 Sprint 需要完成的所有任務 開發人員自行選擇任務，並在 1-4 週內完成 Sprint 4. Daily Scrum 不能花太久，比如限制 15 分鐘內完成 Scrum Master 確保會議的進行，確保 timebox 紀錄關於目前障礙的筆記，規劃時間移除 Dev Team 昨天完成了什麼？ 今天計畫做什麼？ 有遇到什麼阻礙？ 5. Sprint Review（成果展示） 向 Stakeholders 展示這次 Sprint 交付的 Product Increment 討論改進方向，準備下一個 Sprint 6. Sprint Retrospective（回顧與改進） 探討 這次 Sprint 哪些地方可以改進 常見方法： Start-Stop-Continue Start：開始做什麼？ Stop：應該停止什麼？ Continue：繼續保持哪些做法？ 每個人說出一個想開始做的事情，一個想停止做的事情，一個想繼續做的事情 可以保持匿名 3-5-3 Structure（Scrum 的核心架構） 3 大工件（Artifacts） Product Backlog Sprint Backlog Product Increment 5 大事件（Events） Sprint Planning Daily Scrum The Sprint Sprint Review Sprint Retrospective 3 大角色（Roles） Product Owner Scrum Master 開發團隊（Dev Team） 其他補充： Scrum 5 大價值觀 (Values)： 專注（Focus） 尊重（Respect） 承諾（Commitment） 勇氣（Courage） 開放（Openness） Scrum 3 大支柱 (Pillars)： 透明性（Transparency） 檢視（Inspection） 適應（Adaptation） 可以利用 back-to-back testing 來確認沒有弄壞之前 sprint 的功能 ","date":"2024-06-27T02:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/software-development-model/","title":"Software Development Model"},{"content":"測試相關概念 Test Data 用來測試系統的輸入 Test Case 包含測試步驟、預期結果、測試資料 Oracle 理想的結果，作為判斷測試是否成功的標準 Verification（驗證） 確認系統是否符合規格（specification） 若出錯，通常是開發或設計的問題 Validation（確認） 確認系統是否符合使用者需求 若出錯，代表產品目標可能有誤 Bug 與錯誤類型 Bug 程式中的錯誤或偏離預期的行為 Failure 偏離預期的事件（event），如系統崩潰或錯誤輸出 Error 導致 failure 的程式錯誤（code issue） Fault（缺陷） 造成 failure 的設計或開發上的錯誤，可能潛伏在系統內直到被觸發 測試輔助工具 Stub 用來代替其他元件的簡單實作，會回傳硬編碼（hard-coded）值 Mock 類似 stub，但除了回傳預設值，還可驗證是否正確調用 Driver 負責執行測試指令並初始化變數的工具 測試覆蓋率（Test Coverage） Line Coverage（行覆蓋率） 測試過的程式碼行數相對於總行數的比例 Branch Coverage（分支覆蓋率） 測試所有條件分支是否都被執行過，如 if、switch 內的所有可能路徑 測試類型（Testing Types） 單元測試（Unit Testing） 測試程式的最小單位（smallest unit of software） 需隔離（isolate）被測單元，避免外部依賴影響測試結果 常使用 dummy value、mock 物件來替代外部依賴 整合測試（Integration Testing） 測試不同組件（components）之間的交互（communication）和架構（architecture） 測試方式 Big Bang Testing（非漸進式測試） 一次測試所有 components，通常用於大型應用程式 Incremental Testing（漸進式測試） 逐步新增模組進行測試，直到完整測試整個系統 Top-Down Testing 從最上層開始，尚未開發的底層使用 stub 代替 Bottom-Up Testing 從最底層開始，尚未開發的上層使用 driver 代替 Back-to-Back Testing（對比測試） 比較已知良好版本與新版本的輸出 若 output 相同，則新版本仍保有舊版本的正確功能 可作為 incremental testing 的一部分 黑箱測試 vs 白箱測試 黑箱測試（Black Box Testing） 不需要知道內部結構，透過輸入與輸出來驗證系統行為 常見測試方法 Boundary Value Analysis（邊界值分析） 測試邊界值，如最大、最小、剛好超出範圍的數值 Cause-Effect Graph（因果圖測試） 一種設計測試案例的方法，也稱為 fishbone diagram 不同的輸入條件（cause）會導致不同的結果（effect） Pair-Wise Testing（成對測試） 測試多個參數的不同組合，減少測試案例數量的同時仍保證足夠覆蓋率 State-Based Testing（狀態測試） 測試不同狀態下的輸入，確認狀態變更的正確性 測試種類 Functional Testing（功能測試） 確保系統功能符合需求 Regression Testing（回歸測試） 重新測試已驗證過的功能，確保新的修改沒有破壞舊的功能 Non-Functional Testing（非功能測試） 測試效能、安全性、可靠性等非功能性需求 白箱測試（White Box Testing） 需要了解內部結構，測試程式碼本身 常見測試方法 Control Flow Testing（控制流程測試） 設計測試案例，使所有條件分支（branch condition）皆被執行 Data Flow Testing（資料流測試） 測試變數的生命週期，包括變數的定義（declaration）與使用（use） 應用範圍 Unit Testing 最主要用於單元測試 Integration Testing 用於確保不同模組之間的溝通正確 ","date":"2024-06-27T00:01:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/testing/","title":"Testing"},{"content":"基礎概念 Container runtime CRI (Container Runtime Interface) Kubernetes 用來和 container runtime 互動的 interface 任何可以實現 CRI 的 container runtime 都可以用在 Kubernetes，比如 containerd 以前有幫 Docker 特別實現一個 CRI，叫做 Docker shim OCI (Open Container Initiative) 一個開放的 container image 和 runtime 的標準 他定義了 container image 和 container runtime 的格式 containerd 一個 container runtime，docker 底下所使用的 container runtime，現在已經與 docker 單獨出來開發維護 他實現了 CRI，所以可以用在 Kubernetes CLI ctr 如果你只裝 containerd，沒有裝 docker，就可以用這個來操作 containerd 能用的指令比較少 For Debugging nerdctl docker-like 的 CLI 很多指令可以把 docker 的指令換成 nerdctl 的指令 For general purpose crictl 用來操作符合 CRI 的 container runtime 的 CLI For Debugging Node Kubernetes 集群中的一台機器 過去叫做 Minion Cluster 由多個 Node 組成的集群 Node Type Master 控制整個集群的 Node Worker 其他非 Master 的 Node 叫做 Worker Node Master vs Worker Master 擁有的 Component API Server etcd Controller Scheduler Worker 擁有的 Component Container Runtime Kubelet Component 安裝 Kubernetes，實際上是安裝以下幾個 Component API Server front-end of the Kubernetes kubectl 是在和這裡溝通 etcd distributed key-value store 會實現 lock mechanism，確保沒有 conflict 預設聽 2379 port command line client etcdctl kubelet 在每個 node 上運行的 agent 負責確保 container 在 node 上如期運行 Container Runtime 用來 run container 的 underlying software Controller Manager 當 node、container、endpoint 掛掉的時候，他要負責監控和回應 底下有許多種的 Controller，負責監控還有作出應對處理 type Replication Controller 確保指定數量的 Pod 在任何時間都在運行 load balancing \u0026amp; scaling 後來被 ReplicaSet 取代 Node Controller 確保 node 在運行 設定固定間隔監測 node 的健康狀態 Scheduler 負責處理 node 間的 distributing work 會尋找新創的 container，並分配到 node 嘗試幫每個 pod 挑選最適合的 node two phase Filter 檢查 node 是否符合 pod 的需求 Rank 給 node 一個分數，選擇最高分的 node Pod Kubernetes 的最小單位 一個 Pod 封裝一個應用程式，可能包含一個或多個 container ReplicaSet 新版本的 Replication Controller yaml spec template 指定要創建的 Pod 的 template 把 pod 的 metadata 和 spec 都放在這裡 replicas 指定要創建的 Pod 的數量 selector 指定要選擇的 Pod 需要這個是因為 ReplicaSet 也可以管理那些不是他創建的 Pod matchLabels 指定要選擇的 Pod 的 label command kubectl scale --replicas=3 -f \u0026lt;file\u0026gt; scale up/down replicas 這樣不會修改檔案，所以檔案的如果原本是 2，檔案依然會寫 2，只是 replicas 會變成 3 kubectl scale --replicas=3 replicaset \u0026lt;name\u0026gt; scale up/down replicas kubectl edit replicaset \u0026lt;name\u0026gt; 想要 scale up/down replicas 也可以用這個，他會立刻生效 簡寫 rs Deployment 管理 ReplicaSet 和 Replica Controller yaml 和 ReplicaSet 很像，把 kind 從 ReplicaSet 改成 Deployment 就好 會自動創建 ReplicaSet 使用情境 Rolling update 想要更新每個 Pod，但不是同時更新，而是一個一個更新，確保不會有 downtime Rollback 如果更新失敗，可以回到之前的版本 Pause and Resume 當需要做 multiple changes，不想要一下指令就馬上做，可以先 pause，等所有指令下完再 resume rollout 創建 Deployment 的時候，會自動創建一個 rollout 創建一個 rollout 的時候，會自動創建一個 Deployment revision Deployment Strategy Recreate 先刪除所有舊的 Pod，再創建新的 Pod 中間會有 Application downtime Rolling Update 一個一個更新 Pod 這個是預設的 strategy command kubectl rollout status deployment \u0026lt;name\u0026gt; 查看 rollout 的狀態 kubectl rollout history deployment \u0026lt;name\u0026gt; 查看 rollout 的 history (revision) kubectl rollout undo deployment \u0026lt;name\u0026gt; 回到上一個 revision 簡寫 deploy Service 讓不同 group 的 Pod 互相通信 像一個 virtaul server，可以連接到一個或多個 Pod 每個 Node 都有一個 kube-proxy，他會檢查有沒有新的 service，並維護 iptables type NodePort 會在每個 node 上開一個 port，讓外部可以連進來 default valid port range: 30000-32767 yaml spec type ports port service 的 port targetPort pod 的 port 如果不設置，會用 port 的值 nodePort 如果不設置，會從 default port range 選一個 selector 指定要連接的 Pod 預設會用 load balancing，策略是 Random，像是一個內建的 load balancer 如果有在同個 cluster 跨 node 的情況，不需要其他設定，就可以創建一個跨 node 的 service，會幫他們都設同一個 nodePort ClusterIP 只有在 cluster 內部可以連進來 用來幫某一組的 pod 提供一個統一的界面並做轉發 不能依賴 internal IP，因為每個 pod 都有可能會 down 或 up yaml spec type ports port targetPort selector service 可以用 cluster IP 或是 service name 來連接 LoadBalancer 會在 cloud provider 上開一個 load balancer nodePort 的 load balancer 是在 node 內部的，現在是要幫多個 node 做 load balancing 這只有在 cloud provider 上才有 name 很重要，因為其他的 Pod 會用這個 name 來連接 (就像 domain name) 簡寫 svc YAML Kubernetes 的配置文件 root level properties apiVersion kind apiVersion Pod v1 Service v1 ReplicaSet apps/v1 Deployment apps/v1 kind Pod, Service, ReplicaSet, Deployment metadata name labels 可以加入任何 key-value pair spec specification section pod containers name image env: list of environment variables name value Tool kubectl kubectl 用來 deploy、inspect、manage application on a Kubernetes cluster commands kubectl run \u0026lt;name\u0026gt; --image=\u0026lt;image\u0026gt; 創建一個 Pod kubectl get pods 查看所有 Podllll -o wide 顯示更多資訊 column READY / 也可以用 kubectl get all 來查看 Pod、Service、ReplicaSet、Deployment kubectl describe pod \u0026lt;name\u0026gt; 查看 Pod 的詳細資訊 欄位 Node Pod 在哪個 Node 上運行，包含了 Node 的 IP IP Pod 的 IP kubectl delete pod \u0026lt;name\u0026gt; 刪除 Pod kubectl create -f \u0026lt;file\u0026gt; 根據 YAML file 創建 resource 如果 resource 已經存在，會報錯 kubectl apply -f \u0026lt;file\u0026gt; 根據 YAML file 創建 resource 如果 resource 已經存在，會更新 resource kubectl replace -f \u0026lt;file\u0026gt; 根據 YAML file 創建 resource 如果 resource 已經存在，會刪除舊的 resource，並創建新的 resource kubectl edit replicaset \u0026lt;name\u0026gt; 可以直接編輯 Replica Set 的 yaml 檔，但他不是一開始創建用的檔案，而是 Kubernetes 在 memory 暫時生成的 kubectl set image deployment \u0026lt;name\u0026gt; \u0026lt;container-name\u0026gt;=\u0026lt;new-image\u0026gt; 更新 Deployment 的 image 注意這裡是 Container name，不是 Pod name --record=true 會記錄每次的操作 用在 rollout 的時候，可以看到每次的操作，不然會顯示 minikube 用來在 local machine 上建立一個 single-node cluster kubeadm 用來在多個 node 上建立 cluster 在多個 node 上安裝 Kubernetes 流程 安裝 container runtime 安裝 kubeadm 初始化 master node 建立 pod network 加入 worker node Networking Cluster Networking 每個 Pod 都有自己的 IP 兩個不同屬於同一個 cluster 的 Pod 可能會有相同的 IP Kubernetes 要求所有的 Pod 要可以在不用 NAT 的情況下互相通信 所有的 container 和 node 都要可以在沒有 NAT 的情況下互相通信 可以用 Calico 等方案實現 他會把每個 node network 都設成不同的，底下的 pod IP 自然就不會重複 ","date":"2024-06-14T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/kubernetes-%E7%AD%86%E8%A8%98/","title":"Kubernetes 筆記"},{"content":"基礎概念 Module 把相關的 Component、Directive、Pipe、Service 等打包在一起的容器 可以使用 Lazy Loading 延遲加載模組，提高效能 Component Angular 應用程式的基本組成單位 由 HTML、CSS、TypeScript 共同組成 具有自己的 @Component 裝飾器 Pipe 用來轉換資料的工具，可以用於字串格式化、日期格式化等 可以透過 | 符號在模板中使用，例如 {{ value | uppercase }} 內建 Pipes：date、uppercase、lowercase、currency、percent 等 可以建立自訂 Pipe Directive 用來修改 DOM 元素的外觀或行為 例如 ngIf、ngFor、ngStyle、ngClass 分為三種類型： Structural Directive: 修改 DOM 的結構 *ngIf, *ngFor, *ngSwitch 可搭配 ng-container 不會產生額外的 DOM 元素，適合在 ngIf 和 ngFor 不希望產生額外元素時使用 *ngFor 例子：let item of items; index as i Attribute Directive: 修改 DOM 的屬性，例如 ngClass, ngStyle Component Directive: 包含 template 的 directive Service 負責 API 請求、資料處理等工作 透過 Dependency Injection (DI) 來提供服務 @Injectable() 裝飾器用來標記服務 providedIn root: 服務將在整個應用程式中可用 也可以在特定 Module 或 Component 的 providers 中設定要注入的 Service Router 負責處理 URL 路由 設定路由時使用 routes 陣列 path: 定義路徑 component: 指定對應的 Component canActivate: 設定路由守衛 (Guard) 路由守衛 (Guard) 透過 ng g guard \u0026lt;guard-name\u0026gt; 來產生 CanActivate: 控制是否允許使用者進入某個路由 適合用來驗證使用者權限 CLI Command ng new my-app: 建立新的 Angular 專案 ng serve: 啟動開發伺服器 ng build: 打包專案 ng generate (縮寫 ng g) ng g module my-module: 建立新的 Module ng g component my-component: 建立新的 Component --module=app: 指定 Component 所屬的 Module ng g service my-service: 建立新的 Service ng g pipe my-pipe: 建立新的 Pipe ng g directive my-directive: 建立新的 Directive Module @NgModule() declarations: 定義同一 Module 中的 Component、Directive、Pipe imports: 匯入其他 Module providers: 定義 Service bootstrap: 定義應用程式啟動時的根 Component exports: 定義要匯出的 Component、Directive、Pipe Component 包含的主要部分： Template: HTML 模板 TypeScript Class: 包含 Component 的邏輯與屬性 Selector: 定義 Component 在 HTML 中的名稱 CSS Style: 樣式 .spec.ts: 測試檔案 Standalone Component Angular 新版預設採用 Standalone Component 模式 Component 不再需要透過 NgModule 管理 Lifecycle Hooks ngOnChanges: 當輸入屬性變更時調用 ngOnInit: 組件初始化時調用（僅執行一次） ngDoCheck: 手動偵測變更 ngAfterContentInit: ng-content 投影完成後調用 ngAfterContentChecked: ng-content 內容變更後調用 ngAfterViewInit: ViewChild、ViewChildren 初始化後調用 ngAfterViewChecked: 每次檢查變更後調用 ngOnDestroy: 組件銷毀前調用，可用於取消訂閱與清除資源 Sharing Data (資料傳遞) @Input: 父元件傳遞資料給子元件 @Output: 子元件透過 EventEmitter 傳遞資料給父元件 其他方式： 透過 Service 和 RxJS Subject/BehaviorSubject 來進行資料共享 Data Binding (資料綁定) Property Binding (屬性綁定) 用來設定 HTML 元素的屬性 使用中括號 [] 包住屬性名稱 範例： 1 \u0026lt;img [src]=\u0026#34;imageUrl\u0026#34;\u0026gt; Event Binding (事件綁定) 用來設定 HTML 元素的事件 使用小括號 () 包住事件名稱 範例： 1 \u0026lt;button (click)=\u0026#34;onClick()\u0026#34;\u0026gt;Click Me\u0026lt;/button\u0026gt; $event: 取得事件物件 1 \u0026lt;input (input)=\u0026#34;onInput($event)\u0026#34;\u0026gt; Two-way Binding (雙向綁定) 屬性與事件綁定結合在一起 使用 [(ngModel)] 綁定表單輸入 需要匯入 FormsModule 範例： 1 \u0026lt;input [(ngModel)]=\u0026#34;name\u0026#34;\u0026gt; ","date":"2024-05-24T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/angular-%E7%AD%86%E8%A8%98/","title":"Angular 筆記"},{"content":"Maven 專案管理工具 會先檢查 maven local repository 有沒有需要的 dependency，沒有的話就會去 maven central repository (remote repository) 下載 pom.xml project cooridnate groupId artifactId version plugin 和 dependency 的差別是，是用來執行某種 task 的 mvnw maven wrapper 在沒有安裝 maven 的環境下，會下載正確的 maven 版本 Spring IoC Invocation of Constructor 把物件交給 Spring 管理 loose coupling Dependency Injection Bean 給 Spring 管理的物件 創建方法 @Component 創建出的 Bean 名字是 class 的開頭轉小寫 注入方法 @Autowired 種類 field injection 不太推薦，不利於 unit test spring boot 會先建立所有 component，在逐一注入，使元件可能短暫處於初始化不完整狀態 constructor injection 最推薦 建立 bean 時就注入 確保 component 被使用時是處於完整的狀態 有利於 unit test，因為可以把設計好的 mock bean 從 constructor 傳入 spring 建議使用 constructor injection setter injection 用 setter 來注入 創好 component 後，再注入 限制 該 Class 也得是 Bean 會根據類型注入 bean 如果同時有多個同類型的 bean，會報錯，可以用 @Qualifier 指定要注入的 bean 名稱 @Qualifier 指定要注入的 bean 名稱 @Primary 如果有多個同類型的 bean，會優先注入這個 bean Cycle life @PostConstruct 創建 bean 後，就會執行這個方法 限制 必須是 public void 不能有參數 @PreDestroy bean 被銷毀前執行 限制 必須是 public void 不能有參數 Lazy Initialization 本來 beans 不管有沒有用都會被創建 @Lazy 只有在要使用時才會初始化 缺點是用 @RestController 的話，第一次 request 才會創建 可以在 application.properties 裡設定 spring.main.lazy-initialization=true，讓所有 beans 都變成 lazy initialization AOP Aspect Oriented Programming 透過 Aspect 統一處理不同方法的共同邏輯 要導入 aop 的 starter 只有 Bean 才能設置 @Aspect Annotation @Aspect 這個 class 是一個切面 @Before 加上切入點，就可以在切入點 (Pointcut) 的方法執行前執行 @After 在方法之後執行 @Around 在方法之前和之後都執行 常用的功能都已經被封裝好了，開發較少用到 AOP Run app use java -jar mvn clean package java -jar target/xxx.jar use mvn spring-boot:run mvn spring-boot:run 特性 Starter Spring Boot Starters 官方的 starter 命名是 spring-boot-starter-* 第三方的 starter 命名是 *-spring-boot-starter\n外部化配置 application.properties 重新啟動 jar 時會自動載入，不用改配置要重新 build jar 集中管理 @Value 可以注入到變數中 可以用 : 來設定預設值 限制 只能在 Bean 和 Configuration 中使用 YAML application.properties 寫多後，沒有層級辨識度 application.yml profiles 可以根據不同的環境來設定不同的配置 (dev, test, prod) application-{profile}.properties application-{profile}.yml spring.profiles.active 指定啟用的 profile jar -Dspring.profiles.active=dev 指定配置文件 cli --spring.config.location Config 資料夾 可以在 jar 目錄下建立 config 資料夾，放配置文件，不用輸入額外的 args 大致分類 core logging web security data actuator integration devtools test Dependency Management parent 寫了版本號，故 dependency 可以不用寫版本號 真的要指定的話，可以利用 maven 的就近原則 Auto Configuration Component Scan Spring Boot 會掃描主程式所在的 package 以及子 package 也可以在主程式上加以下註解來指定掃描的 package @SpringBootApplication(scanBasePackages = \u0026quot;com.example\u0026quot;) 所有 starter 都有 spring-boot-starter，spring-boot-starter 又有 spring-boot-autoconfigure，這個就是自動配置的地方 spring boot 默認掃描不到 spring-boot-autoconfigure 的所有配置類 (因為預設只掃描 Main Application Class 的 package)，但是 @SpringBootApplication 的 @EnableAutoConfiguration 會預設掃描 spring-boot-autoconfigure 的所有配置類 它們再依據 conditional annotation 來決定是否要啟用這個配置類 Common Annotations Spring Boot 放棄了 XML 配置，改用 Annotation 配置\nComponent registration @Configuration, @SpringBootConfiguration @Bean 有時候可能會想用第三方套件，此時可能不能修改套件的 code，這時候就可以用 @Configuration 來註冊 bean @Controller, @Service, @Repository, @Component 三層式架構 @Controller 用來處理請求 @Service 用來處理業務邏輯 @Repository 用來處理資料庫操作 @SpringBootApplication 由以下組成 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan Web @RestController @Controller + @ResponseBody @RequestMapping 設置 route Method @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping 取得參數 @RequestParam 取得 url 中的參數 @RequestBody 取得 request body 根據欄位名字調用對應的 setter @RequestHeader 取得 header @PathVariable 取得 route 中的參數 @Scope mode singleton 預設，共用一個 instance prototype 每次注入都創建新的 instance 可以用 proxy.mode = ScopedProxyMode.TARGET_CLASS，會變成每次調用 method 都創建新的 instance prototype 的元件生出後，spring 不會再管理，要自己管理生命週期，相當於 new 出物件的替代作法 預設是 lazy initialization request 每個 request 都有一個獨立的 instance request 指的是 HTTP request，從進入 controller 到離開 controller session 每個 session 都有一個獨立的 instance session 指的是 HTTP session，從進入 controller 到離開 controller Conditional Annotations 條件成立則觸發指定行為 ConditionalOn example ConditionalOnClass 如果 classpath 有指定的 class 才會觸發 ConditionalOnMissingClass 如果 classpath 沒有指定的 class 才會觸發 ConditionalOnBean 如果容器中有指定的 bean 才會觸發 ConditionalOnMissingBean 如果容器中沒有指定的 bean 才會觸發 Scenario 如果有某個 dependency，則創建某個 bean Property Binding 把任意 Bean 的 property 與配置文件 (application.properties) 中的 property 綁定 annotations @ConfigurationProperties prefix @EnableConfigurationProperties 如果 class 只有 @ConfigurationProperties，沒有 @Component，需要加這個 annotation 用在第三方 package 上，因為默認掃不到第三方的 @component Java JSON Data Binding 在 Java POJO 和 JSON 之間轉換 Spring 用 Jackson 來做轉換 Jackson 會 call getter, setter 來轉換 alias mapping marshalling serialization 輔助工具 Spring boot devtools Hot reload Spring Boot Actuator 公開用來 monitor 的 endpoint endpoints 都有固定前綴 /actuator /health 查看應用程式的 status /info 查看應用程式的 info /beans 查看所有 bean Logging Logging 選擇\nLogging API JCL SLF4J (Simple Logging Facade for Java) jboss-logging Logging implementation Logback Log4j2 JUL (java.util.logging) Spring Boot 預設使用 Logback 和 SLF4J spring-boot-starter 引用了 spring-boot-starter-logging\nLog Format Default example 1 2024-05-06T19:21:40.751+08:00 INFO 22932 --- [demo] [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port 8080 (http) with context path \u0026#39;\u0026#39; 時間, 日誌等級, pid, 分割符, thread, logger, message Log Level Type (由低到高) ALL TRACE 一般不用 DEBUG INFO WARN ERROR FATAL OFF 會 print 出比設定的等級高的 log Log Configuration logging.level.*\n設定不同 package 的 log 等級 1 logging.level.com.example=DEBUG logging.group.\n把多個 package 放在一組，可以統一設定 預設有 web, sql 組 logging.file\n.name 檔名 歸檔 and 切割\n歸檔 每天單獨存 .logback.rolllingpolicy.file-name-pattern 切割 超過指定大小就切割 .logback.rolllingpolicy.max-file-size Filter 實做 javax.servlet.Filter，就能註冊為 spring 的 filter OncePerRequestFilter 保證一次 request 只會執行一次 doFilterInternal chain.doFilter(request, response) 這行之後代表後面的 filter 都執行完了 如果只有一個 filter，就代表 controller 執行完了 shouldNotFilter 可以設定不要執行的 url pattern 註冊 Filter 流程\n設定 @Configuration 加到 Bean \u0026lt;option\u0026gt; setUrlPatterns 只有符合 url pattern 的 request 才會經過這個 filter \u0026lt;option\u0026gt; setOrder 決定 filter 的順序 如果 filter 要取得 request 和 response 的內容，可以用 ContentCachingRequestWrapper 和 ContentCachingResponseWrapper 重新包裝\n因為原本的作法是用 stream 讀取資料，只能讀一次 @WebFilter\n屬於 Java servlet 而非 Spring 要在 application 補上 @ServletComponentScan 可以直接註冊 filter Spring Security 名詞 Authentication 認證 檢查是不是系統的使用者，以及是哪個使用者 Authorization 授權 檢查使用者有沒有權限做某件事 流程 filter chain\nexample UsernamePasswordAuthenticationFilter 檢查使用者名稱和密碼 ExceptionTranslationFilter 處理例外 FilterSecurityInterceptor 檢查授權 authorizeHttpRequests 設定哪些 request 需要什麼權限 example: JWT 驗證流程\n先透過 filter chain 經過 JWT filter 透過 UserDetailsService 取得使用者資訊 驗證使用者資訊 更新 SecurityContextHolder 用來判斷使用者是否已經通過 authentication Configuration @EnableWebSecurity 啟用 web security example 1 2 3 4 5 6 7 8 9 10 11 12 @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception { http.authorizeHttpRequests((requests) -\u0026gt; { ((AuthorizeHttpRequestsConfigurer.AuthorizedUrl)requests.anyRequest()).authenticated(); }); http.httpBasic(Customizer.withDefaults()); return (SecurityFilterChain)http.build(); } } 把 Spring Boot 預設實作的 fitler chain 的 @Order 拿掉，這是決定誰的優先序高 也把 formLogin 拿掉，就不會有登入頁面 UserDetails 實現 UserDetailsService 的 Bean 可以被用來取得 UserDetails implements UserDetails getAuthorities getUsername getPassword isAccountNonExpired isAccountNonLocked isCredentialsNonExpired isEnabled SecurityContextHolder 用來存放 authentication CommandLineRunner 用來在 Spring Boot 啟動後執行一些任務 會在所有 bean 創建完後執行 JPA Jakarta Persistence API 以前叫 Java Persistence API 只是一個 specifcation，提供一組 interface，需要實作 包含了 Entity, EntityManager, Query, Transaction.. DataSource 用來連接資料庫 定義了連接資料庫的 info EntityManager 用來創建 query 的主要 component 需要 DataSource EntityManager vs JpaRepositroy EntityManager low-level control and flexibility JpaRepository high-level abstraction JPQL 基於 Entity name 和 fields 的 query language 不是基於資料庫的 column 或 table name，是基於 Entity 的名字，要注意區別 Data access object (DAO) common pattern 需要 JPA Entity Manager Config spring.jpa.hibernate.ddl-auto create 每次都會重新創建新的 table update 只會更新 table，不會刪除 create-drop 創建 table，然後刪除 validate 只會檢查 table 是否存在，不會創建 Annotation @Entity, @Table 也要記得寫 getter, setter @Entity 需要 public 或 protected 的無參數建構子 @Table 可選，可以設定 table 名稱 @Transient 不會被序列化，不會被存到資料庫 可用在可以單獨計算的欄位，比如用資料庫的生日可以算出年齡 @Transactional 用在 method 上，代表這個 method 是一個 transaction propagation 用在 method 上，被別的 transaction 調用應該怎麼處理，講 transaction 的傳播 REQUIRED 如果有外層 transaction 就用，沒有就創建一個 REQUIRES_NEW 無論有沒有外層 transaction，都創建一個新的，不受影響 NESTED 嵌套 transaction，如果外層 transaction rollback，內層也會 rollback 如果自己 rollback，外層不受影響 @Column 可以設定欄位名稱 這是可選的，沒有的話就是用變數名稱 @Id Primary key @GeneratedValue strategy AUTO 根據資料庫自動選擇 IDENTITY 用資料庫的 identity column SEQUENCE 用資料庫的 sequence Table 用 underlying table 來確保唯一性 UUID 用 UUID 來確保唯一性 @OneToMany, @ManyToOne 用來設定關聯 cascade 設定當 parent 被刪除時，child 要怎麼處理 CascadeType.ALL parent 被刪除時，child 也會被刪除 CascadeType.PERSIST parent 被刪除時，child 不會被刪除 Spring Data JPA 用特定語法，只需要定好 interface，不用 implement extends JpaRepository\u0026lt;Entity, ID\u0026gt; 第一個參數是 entity 第二個參數是 primary key 的型態 示範 findByXxx 用 XXX 的欄位來查詢 findByXXXLike 用 XXX 的欄位來模糊查詢 JpaRepository @Repository 用來標記 DAO extends JpaRepository\u0026lt;Entity, ID\u0026gt; 第一個參數是 entity 第二個參數是 entity 的 id 的型態 可以自定義方法 遵循命名規則，他會自己轉 SQL 也可以用 @Query 來自定義 SQL \u0026lt;?0\u0026gt; 代表第一個參數，以此類推 Hibernate 用來儲存 java object 到資料庫的框架 ORM Object Relational Mapping 用物件來操作資料庫 一種 JPA 的實作 背後用 JDBC 來操作資料庫 Spring Boot 預設用 Hibernate 來實作 JPA Validation field validation\n@NotEmpty @Min @Max @Valid\n用在 controller 上，才會自動檢查參數 Exception RuntimeException 繼承這個，可以設置 status, message, timestamp @ExceptionHandler 放在 Controller 中的 exception handler method 上，可以處理底下 method 丟出的 exception @ControllerAdvice 類似 interceptor/filter 可以 pre-process request, post-process response 可以用在 global exception handler Testing Integration Test 在 test class 前面的 annotation @RunWith(SpringRunner.class) @SpringBootTest @AutoConfigureMockMvc 測試開始時會在容器中創建 MockMvc 在 test method 前面加的 annotation @Test @Before, @After 在每個測試前後執行，可以用來清空資料庫和設置 header MockMvc 用來模擬 HTTP request example 1 2 3 4 5 6 7 8 9 @Autowired private MockMvc mockMvc; @Test public void test() throws Exception { mockMvc.perform(get(\u0026#34;/hello\u0026#34;)) .andExpect(status().isOk()) .andExpect(content().string(\u0026#34;Hello World\u0026#34;)); } 其他 Lombok @Getter, @Setter 生成 getter, setter @ToString 印出所有變數 @EqualsAndHashCode 生成 equals, hashCode Args @NoArgsConstructor 生成無參數建構子 @AllArgsConstructor 生成所有參數建構子 @RequiredArgsConstructor 只幫 final 變數生成建構子 @Data 同時用 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor @Value 把所有變數都設成 final 同時用 @Getter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor 和 Spring boot 的 @Value 撞名 @Builder 生成 builder pattern @Slf4j 生成 log 變數 Jackson ObjectMapper 用來轉換物件和 JSON readValue 把 JSON 轉成物件 用 getter, setter 來判斷欄位 Annotation @JsonIgnore 不轉換 @JsonProperty 指定欄位名字 @JsonUnwrapped 把物件的欄位展開，從巢狀變成平面 @JsonInclude 設定要不要轉換 null 如果設定為 Include.NON_NULL，給 null 的話，就不會轉換 @JsonFormat 設定日期格式 ","date":"2024-05-06T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/spring-boot-%E7%AD%86%E8%A8%98/","title":"Spring Boot 筆記"},{"content":"Creational patterns 關於 object creation 的 patterns。\nFactory Method 將不同 Product 定義一個共有的 Interface(以下簡稱 PI)，並由子類別實作，同時也幫不同工廠定義一個生成 product 的 interface(以下簡稱 FI)，透過不同的工廠類別實體來建立有共同 interface (PI)的不同 Product。 優點 將建立 Product 的方法獨立出來，符合 Single Responsibility Principle 可以輕易擴充新種類的 Product，而不用修改原本的程式碼，符合 Open-Closed Principle Abstract Factory 相比 Factory Method，現在的情境是有多個 Product 的同時，又會分不同系列，而且每次都是使用同一系列的 Product。 - ex: 有一套家具，但是分多種不同的風格，每次都是使用同一風格的家具。\n現在 Factory 會有一個共有的 interface，但是這個 interface 包含了建立一整套 product 的方法\nBuilder 對於建構一個複雜且具備多種組合的產品，可以透過下面兩種方式其中之一解決：\n建構巨大的建構函式 覆蓋所有可能的子類別 但都存在其問題，要不是大量的子類別，不然就是難以呼叫的建構函式。\n把建立物件的每個 component 獨立出來，並且切成多個可分開執行的 step，再根據自己的需求調用需要的函式。\n對於建置步驟可能需要不同時做的情況，定義一個 Builder interface，包含了建立物件的每個 component 的方法，然後由 Builder 的子類別來實作這些方法。\nClient 可以根據自己的需要調用 Builder 中的方法（不用全部調用），就可以在同樣的建構程式碼下透過不同的 Builder 來建立不同的物件。\nDirector 不是必需的，但有需要的話可以讓他幫忙調用 Builder 的 method，好在專案中重複使用。\nPrototype 使用在想要獲得某個對象的 clone 的情境。如果直接照著外表複製，可能會因為看不到私有屬性而造成問題。\n把 clone 的責任交給對象本身，而不是交給 Client。由對象本身提供 clone method。 支援 clone 方法的物像被稱為 prototype。\nSingleton 確保某個類別只有一個 instance，並且提供一個 global access point。\n但是這樣違反了 Single Responsibility Principle，因為他現在要解決兩個問題：\n要讓唯一的 instance 可以被全域存取 負責確保自己的類別只有一個 instance 而且會讓全域變數有的缺點轉移過來，比如不安全，因為別的程式碼可能也可能修改我們在用的變數\nStructural patterns 探討如何組裝類別和物件成為更大的結構。\nAdapter 轉換某個對象的 interface 到另外一種 interface，讓另外一個 Object 可以理解他。 就像 XML 要轉到 JSON。\nBrdige 把一個大類別分成兩個獨立的維度（抽象和實作），讓他們可以獨立變化。\nGura 舉的簡單例子 這例子可以被拿來想像具體實作可能長怎樣\n使用在需要在多個 orthogonal (independent) 的維度上擴展類別時的情境。比如我們要生產的一堆 entity 有分不同的 shape 和 color。 如果有兩種 shape 和兩種 color，我們就會有 4 種子類別\n目標是讓情況從難以計數的子類別數，變成多組功能聯合起來。可以透過把其中一個維度轉換成單獨的類別，然後用引用的方式獲取。\n作法 拆成 abstraction (high-level control) 和 implementation (實際工作)， 由 abstraction 來控制 implementation，比如 GUI 來控制底下的 API。 這樣的好處是兩邊都可以各自發展，以 GUI 和 API 舉例，GUI 可以開發不同方法調用事先說好的 API 介面（abstract），而根據 API 介面可以發展出不同的 implementation。\n未來有更新的 GUI （繼承原有的 abstraction）也因為 implementation 是獨立的，不用擔心影響到他\nComposite 用在程式模型具有層級結構（像是表示成樹）的情況。比如說我現在有一個大盒子，每次拆開盒子裡面有可能是多個東西，然後東西可能是小一點的盒子，或是產品。\n如果要確認全部的產品價格總和，就要層層展開所有盒子，直到看到所有產品。\n作法 假設盒子結構稱為 Composite，而裡面的東西稱為 Component。我們可以定義一個共同介面，以價格為例，可能是讓 composite 和 component 都有獲取價格的 method，但是當調用 composite 的價格時，他會往 child 調用獲取價格的 method，然後把價格加總起來。用遞迴的方式來處理。\n對於 Composite (Container)，不但實現 Component，也提供一個 list 來存放子 component，以及加入和從 list 中移除的 method。\n對 Composite 的操作，會被委託給子 component，不需要 client 擔心。\n就像指揮官只需要對高階軍官下命令。\nDecorator 當今天有多種同類型的東西，你可以能會同時用到多種子類別所形成的組合時，就可以用 Decorator。\nGuru 舉例，不同社群平台的 notification，你可能會想要有不同的 notifier，發到一些指定的社群平台。也有拿天冷穿衣服舉例，可以層層穿不同的衣服。\n但這是一層層的感覺，具有順序性。 Decorator 和 Component 都繼承同一個 interface。 有兩種實作辦法，可以層層包裹但是在外部自行調用，也可以把包裹的功能放在 Decorator 裡面，讓他自己調用。 如果是第二種，可能就像下面這樣 就像是 data = new Encrypt(new Compress(new FileData(data)))\n存在很難從 stack 中刪除特定 decorator 的缺點。\nFacade 為複雜的一堆子系統提供一個外部介面 Class，讓 client 可以使用他們關心的功能。 實際怎麼調用 client 無須知道。\nGuru 舉例，比如說你要轉換影片，可能要調用很多不同的子系統，比如說轉檔、壓縮、上傳等等，可以獨立出去一個新的 class 提供轉換影片的功能，然後內部調用這堆子系統，client 只需要調用這個新的 class 就好。\n容易形成 god object。\nFlyweight 對於大量類似的物件，為求節省記憶體而誕生的 pattern。\n把物件的內容分成 intrinsic 和 extrinsic，intrinsic 是不會改變的 (unique)，而 extrinsic 是會改變的 (repeating)。讓 extrinsic 的東西用同一塊記憶體。\n可以透過一個可以儲存建立過共有物件的 factory 來建立物件。\nProxy 用在多個服務想要調用某個重量級資源的情境下，可能只有很偶爾的情況需要用這 entity，但是如果平常就佔據著這個 entity，可能會消耗大量資源。\n如果在服務和 entity 之間加上 proxy，就可以讓 proxy 來處理這些情況。可以用 proxy 的場景較多，下面以 cache 的場景為例子。\n獲取某個靜態檔案可能非常花時間，但如果透過 proxy，第一個 service 想要這檔案的時候，proxy 可以去調用並暫存，其他 service 來要求的時候就可以直接回傳給他們。\nBehavioral patterns 探討物件或是演算法之間的溝通和分配職責。\nChain of Responsibility 透過一連串可以串接起來的 handler，來處理請求。\n對於一系列檢查的情況，可以用這種作法，有兩種形式：\n一路檢查，檢查失敗則中斷請求。 常見的例子是用在網頁的 middleware，如果有一個 middleware 檢查失敗，就不會往下傳。 每個 Handler 自行決定要不要處理該請求，要的話則不會往下傳。 這樣可能會最後沒人處理 就像網頁點擊事件，一層層元素往上問。 Command 把請求獨立出來，讓請求可以被用各種方式調用。 比如說把業務邏輯從 GUI 中抽出來，讓 GUI 只負責呼叫 command，然後 GUI 就可以有多個地方呼叫同一個 command。\n比如多種不同的按鈕或快捷鍵背後都執行同一個存檔功能。存檔就可以作為 command 獨立出來。 背後再根據這個 command 實施對應的業務邏輯。\nIterator 用來需要遍歷集合中元素的情境，把不同種類的遍歷行為細節隱藏起來。\n提供多種不同的 iterator，但遵循同一種 interface，讓使用者可以根據需要選擇 iterator。 對於不關心用哪種 iterator 的使用者，也能受益於 iterator 的 interface，而不必耦合於特定的演算法。\nMediator 禁止多個 component 直接溝通，迫使他們透過 mediator 來溝通，避免複雜的關係。 所有人只能透過 notify mediator 來溝通，mediator 根據 sender 和 event，來做出相應處理。\n所有的 component 都不知道最終會有哪些 component 處理自己的請求，同樣的，他們也不知道請求是誰造成的，彼此不知道對方的存在。\nMemento 讓你可以儲存和復原到先前的狀態。\n讓要儲存的對象自己生成 snapshot。\n建議存在名為 momento 的 special object，這個 object 不能讓除了 producer 外的其他 object 直接存取。\n其他 object 只能透過 limited interface 來取得透過 producer 產生的 momento。\n這些限制讓 momento 可以交給其他 object 來管理，稱為 caretaker，要復原的時候再把 momento 交還給 producer。\nObserver 定義 subscription 機制。\n有 interesting state 的 object 稱為 subject，但由於他也會通知其他人，所以又稱為 publisher。追蹤它的人稱為 Subscriber。\nSubscriber 如果想要在 Publisher 的狀態改變時被通知，就要訂閱 Publisher。然後 Publisher 維護一個 list 來存放所有訂閱者。\nState 用在類似 Finite-State Machine 的情況。\n把物件可能的狀態給提取出去，建立一個 interface，interface 包含了所有在不同狀態下會表現行為不同的 method。\n該 pattern 把每個 state 獨立成一個 Class，把實際的行為委託給 state，而不是由 context (原始物件) 來控制。Context 只管切換 state。\nStrategy 把不同實現方法的演算法定義為遵循同一個 interface 的類別，讓使用者可以根據需要選擇演算法。\n原始的類別叫做 Context，client 可以把不同的策略傳給 Context，然後 Context 再根據策略來執行。\nTemplate Method 把演算法拆成多個步驟，讓子類別可以選擇性覆寫其中的一些步驟，但不改變演算法的結構。\n原始的 template 可能有已經有預設實作或是 abstract method，就算有預設實作，子類別也可以選擇性覆寫。\nVisitor 如果今天有一堆有共同父類別的子類別，我想新增某個功能，並給他們所有人用，同時不太希望修改到既有的這些類別，這時候可以用 visitor（雖然還是會做微不足道的修改）。\nVisitor 要解決的問題和 Double Dispatch 很像。\nvistor 會把新功能放在名為 Visitor 的新 class 中，然後透過 double dispatch 來執行。\n新功能會根據這些子類別提供不同的 method，然後透過這些 method 來執行新功能。\n我們最終會在這些子類別中新增一個 accept method，這個 method 會接受一個 visitor，然後根據 visitor 來執行對應的 method。\n雖然這樣依然會修改到子 class，但這屬於微不足道的改變，而且可以讓之後新增的一些功能不用再去修改這些子 class。\nSingle Dispatch dispatch 是指決定在 runtime 要呼叫哪個 method 的過程。 大多數的物件導向程式語言都支持 single dispatch，比如說在執行時期，遇到多型的時候，選擇要執行什麼 method。（我不確定有沒有多型以外的情況）\nDouble Dispatch 這是一種技巧，讓我們可以在執行時期根據接收者（物件本身）和參數（傳進方法的物件）的類型決定要執行哪個 method。\n好像也可以說是兩個參數的多型。\n這是因為在編譯時期，看利用多型的程式碼，我們只能知道物件的多型型別，但是不知道他的實際型別，所以我們無法知道要執行哪個 method。\n但是如果我們在執行時期，可以根據物件的實際型別來決定要執行哪個 method，這樣就可以達到我們想要的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class A { public void accept(Visitor v) { v.visit(this); } } public class B { public void accept(Visitor v) { v.visit(this); } } public class Visitor { public void visit(A a) { // visitor 不一定要用重名，這裏只是舉例 System.out.println(\u0026#34;A\u0026#34;); } public void visit(B b) { System.out.println(\u0026#34;B\u0026#34;); } } 調用的時候可能會像a.accept(visitor)\n第一次調用發生在 accept method，根據 a 來決定要執行哪個 accept method\n第二次調用發生在 visit method，根據 參數的類型 來決定要執行哪個 visit method\n","date":"2023-10-10T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-desing-pattern/","title":"設計模式 Desing Pattern"},{"content":"Union-Find (DSU) 不同條件下的時間複雜度 待補 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int find(int x) { if (f[x] == x) return x; else return f[x] = find(f[x]); } int merge(int x, int y) { f[find(x)] = find(y); } int main() { for (int i = 1; i \u0026lt;= n; i++) f[i] = i; x = find(x); y = find(y); if (x != y) { merge(x, y); } } Trie 1 2 3 4 5 6 7 8 9 10 11 class Node { public: int cnt; int id; Node* nxt[26]; Node() { cnt = 0; for (int i = 0; i \u0026lt; 26; i++) nxt[i] = nullptr; } }; Segment Tree 單點修改線段樹 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #define pl(x) (x * 2 + 1) #define pr(x) (x * 2 + 2) void build(int index, int l, int r) { if (l == r) { tree[index] = arr[l]; return; } int mid = (l + r) / 2; build(pl(index), l, mid); build(pr(index), mid + 1, r); tree[index] = tree[pl(index)] * tree[pr(index)]; } void change(int index, int q, int l, int r, int \u0026amp;value) { if (l == r) { tree[index] = value; return; } int mid = (l + r) / 2; if (mid \u0026gt;= q) change(pl(index), q, l, mid, value); else change(pr(index), q, mid + 1, r, value); tree[index] = tree[pl(index)] * tree[pr(index)]; } void query(int index, int ql, int qr, int l, int r, int \u0026amp;ans) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { ans *= tree[index]; return; } int mid = (l + r) / 2; if (ql \u0026lt;= mid) query(pl(index), ql, qr, l, mid, ans); if (mid \u0026lt; qr) query(pr(index), ql, qr, mid + 1, r, ans); } ","date":"2023-08-29T00:08:46+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98/","title":"資料結構筆記"},{"content":"Sorting Merge Sort 一直拆分兩邊最後再輪流 merge 起來，merge 時看兩邊開頭誰最小，依序放 都是 $O(nlogn)$ stable not in-place Quick sort 選定一個 pivot，用兩個指針從兩邊開始往中間找。當左指針找到比 pivot 大的數值，右指針找到比 pivot 小的數值後交換。直到兩個指針相遇，再把 pivot 換到中間，繼續兩邊處理\n最差會到 $O(n^2)$，平均 $O(nlogn)$\n選 pivot\n隨機選 Median of Three 選開頭、中間和結尾的中位數 Other Binary Exponentiation 快速冪 1 2 3 4 5 6 7 8 9 int qpow(int x, int m) { int ans = 1; while (m) { if (m \u0026amp; 1) ans *= x; x *= x; m \u0026gt;\u0026gt;= 1; } return ans; } Discretization 離散化 1 2 3 4 5 sort(vec.begin(), vec.end()); vec.resize(unique(vec.begin(), vec.end()) - vec.begin()); for (int i = 0; i \u0026lt; vec.size(); i++) { val[i] = lower_bound(vec.begin(), vec.end(), val[i]) - vec.begin(); } Ternary Search 三分搜 1 2 3 4 5 6 7 8 9 10 11 l = -10000.0; r = 10000.0; while (r - l \u0026gt; eps) { ml = (r - l) / 3.0 + l; mr = (r - l) * 2.0 / 3.0 + l; if (f(ml) \u0026gt; f(mr)) { l = ml; } else { r = mr; } } ","date":"2023-08-27T00:09:46+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E6%9C%AA%E5%88%86%E9%A1%9E%E6%BC%94%E7%AE%97%E6%B3%95-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98/","title":"未分類演算法 \u0026 資料結構筆記"},{"content":"Floyd-Warshall 1 2 3 4 for (int k = 0; k \u0026lt; nodeCount; k++) for (int i = 0; i \u0026lt; nodeCount; i++) for (int j = 0; j \u0026lt; nodeCount; j++) DP[i][j] = min(DP[i][j], DP[i][k]+ DP[k][j]); dijkstra 時間複雜度 $O((V+E)*log(E))$ 最差每條邊都要插入 heap 要取出 V 個點 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class cmp { public: bool operator()(edge a,edge b) { if(a.weight\u0026lt;b.weight) return true; return false; } }; dis[a] = 0; priority_queue\u0026lt;edge, vector\u0026lt;edge\u0026gt;, cmp\u0026gt; pq; pq.push({a, 0}); while (!pq.empty()) { edge u = pq.top(); pq.pop(); if (!vis[u.to_node]) { vis[u.to_node] = 1; for (auto i : mp[u.to_node]) { if (dis[i.to_node] \u0026gt; dis[u.to_node] + i.weight) { dis[i.to_node] = dis[u.to_node] + i.weight; pq.push({i.to_node, dis[i.to_node]}); } } } } Topological Sorting 記得確認是不是 Directed Acyclic Graph BFS 是沒有前繼節點優先，DFS 是沒有後繼節點優先 用 BFS 的話就是把入度為 0 的點加入 Queue，一直維護該 Queue 1 2 3 4 5 6 7 8 9 10 void dfs(int u) { if (!vis[u]) { vis[u] = true; for (auto j : edge[u]) dfs(j); toposort.push_back(u); } } for (int i = 1; i \u0026lt;= n; i++) dfs(i); reverse(toposort.begin(), toposort.end()); 樹的直徑 兩次 DFS，第一次找到離任意點最遠的點，第二次從該點出發找到離他最遠的點，這兩個點之間的距離就是樹的直徑。\nLowest Common Ancestor 待補 Eulerian path 歐拉路徑 每條邊只能被訪問一次（一筆畫問題） 條件 除了兩個點外，其他都得為入度==出度。另外兩個點，最多有一個出度要比入度大一，最多有一個入度要比出度大一。（只能有 0 或 2 個奇點） 須為連通圖 視作無向圖的時候是否可以連到每個點 Matching Hungarian Algorithm 待補 最小點覆蓋等等 待補 ","date":"2023-08-27T00:08:46+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E5%9C%96%E8%AB%96%E7%AD%86%E8%A8%98/","title":"圖論筆記"},{"content":"簡介 Meta 在 2015 年公開的 API Query Language 相較於傳統的 REST API，具備更靈活的查詢能力 可讓客戶端精確地獲取所需的資料，避免多餘的請求和回應 被多家公司採用，如： Facebook GitHub Twitter \u0026hellip; GraphQL 與 REST API 的主要差異 Single Endpoint\nREST API 針對不同資源 (resource) 需要不同的 endpoint，而 GraphQL 透過單一 endpoint 存取所有資源 但 GraphQL 由於僅有一個 URL，無法直接利用 HTTP caching 進行快取，而是依賴 client-side caching 或 persistent queries 來優化效能 解決 Under-fetching 和 Over-fetching 問題\nUnder-fetching\n一個 API call 無法取得所有需要的資料，導致需要多次 API call 例如，使用 RESTful API 取得一篇文章及其作者資訊，可能需要先請求文章資料，再請求作者資料 GraphQL 透過 nested query 可以在單次 API call 內獲取文章及作者資訊 Over-fetching\nAPI 回應的資料超過實際所需，造成資源浪費 GraphQL 允許客戶端指定僅需要的欄位，避免傳輸過多無用資料 GraphQL 的運作方式 GraphQL 需要特別架設 GraphQL server，可考慮使用 Apollo Server、Express + graphql 套件等方式實作\n需定義 schema 來描述不同的資料類型 (Data type) 及其關聯 (relationship) 透過 resolver 來處理查詢和資料變更 Query (查詢) GraphQL 的查詢語法允許客戶端精確地獲取所需的資料，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 query postQuery($id: ID!) { post(id: $id) { id title content author { id name } } } ### Mutation (變更資料) GraphQL 透過 Mutation 來處理新增、修改、刪除資料，例如新增文章的請求： ```graphql query addPost($post: AddPostInput!) { addPost(post: $post) { id title content author { id name } } } ","date":"2023-08-22T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/graphql-%E7%B0%A1%E4%BB%8B/","title":"GraphQL 簡介"},{"content":"Use Cases Cache 把常用的資料回傳，省略長時間的 IO 操作 Shared Session 在 stateless server 間共享 session Distributed lock 用在程式間想共用某種資源的時候 用 setnx (set if not exists) atomic Rate Limiter 用 increment 和 expiration 實現 快取常見策略 cache aside 先問 cache，沒有的話再問 db，並把 db 回傳的資料放到 cache read through client 只能存取到 cache，如果沒資料，cache 會去 db 拿資料 write through client 寫資料時，cache 會留一份資料，並把資料寫到 db write behind 和 write through 很像，但是不會立即寫到 db，會等到有更多的資料時，才一次寫到 db Feature NoSQL In-memory Key-Value Basic Command redis-server default port: 6379 redis-cli Access data set \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\nPretty much everything stored in Redis is going to be a type of string by default get \u0026lt;key\u0026gt;\ndel \u0026lt;key\u0026gt;\nexists \u0026lt;key\u0026gt;\nkeys \u0026lt;pattern\u0026gt;\nfind keys with certain pattern keys * get all keys flushall\nget rid of everything Expiration ttl \u0026lt;key\u0026gt;\nshow time to live \u0026ldquo;-1\u0026rdquo; for no expiration \u0026ldquo;-2\u0026rdquo; already expired expire \u0026lt;key\u0026gt; \u0026lt;second\u0026gt;\nsetex \u0026lt;key\u0026gt; \u0026lt;seconds\u0026gt; \u0026lt;value\u0026gt;\nset with expiration Data Structure List lpush/rpush \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; lrange \u0026lt;key\u0026gt; \u0026lt;start index\u0026gt; \u0026lt;end index\u0026gt; \u0026lt;end index\u0026gt; can be -1 lpop/rpop \u0026lt;key\u0026gt; Set sadd \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; smembers \u0026lt;key\u0026gt; srem \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; remove Hash Key-value in Key-value\nhset \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; \u0026lt;value\u0026gt; hget \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; hgetall \u0026lt;key\u0026gt; get everything about \u0026lt;key\u0026gt; hdel hexists \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; Redis doesn\u0026rsquo;t support nested hash struct 刪除過期 key 定期刪除 在固定間隔時間隨機抽 key 檢查並刪除\n惰性刪除 在訪問 key 的時候發現過期就刪除\nmaxmemory-policy (Eviction) 可以設定這些 policy，在記憶體依然額滿的情況下做對應的處理\nnoeviction allkeys-lru allkeys-lfu volatile-lru volatile-lfu allkeys-random volatile-random volatile-ttl 快取情境問題 快取雪崩 Cache Avalanche 某個時刻大量 cache 失效，使資料庫需要承擔很大的流量。 解法 幫 cache 加上額外的隨機過期時間 快取擊穿 Hotspot Invalid 某個 hotspot 的 cache 失效，使大量請求跑到資料庫 解法 讓 hotspot 永不過期 查詢資料庫的部分加上 lock 快取穿透 Cache Penetration client request 不存在的資料，因為同時不存在於 cache 和資料庫中，所以直接跑到資料庫 解法 在 application 先過濾掉非法請求 Bloom Filter 布隆過濾器 Persistence RDB 固定時間對所有資料做快照，memory dump 出來 recovery 比 AOF 快 save、bgsave AOF 紀錄操作流程 檔案比較肥 Rewrite 當 AOF 太大，Redis 會生一個新文件取代舊的，用最少操作生出目前的資料\n混合 在 AOF 重寫的時候也利用 RDB 前面是 RDB，後面是 AOF\nAvailability 主從同步 一主多從，把讀取壓力分擔到 slave 上\n哨兵模式 Sentinel 會有哨兵不斷地 Ping 主從伺服器，確認是否有異常\n如果哨兵是集群，有哨兵檢測到異常，會判斷某伺服器主觀下線，當有一定數量的哨兵投票認為伺服器不可能用，就會變成客觀下線，進行 failover\nCluster 分擔寫入壓力\nRedis 有 16384 個 slot，透過 hash 分配 key 到不同的 slot\n預設會另外用 port 16379 來讓節點間溝通\n可以混和主從同步達到高可用\n","date":"2023-06-05T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/redis/","title":"Redis"},{"content":"Hexagonal Architecture (Ports and Adapters Architecture) 目標是讓應用程式的核心邏輯與外部系統解耦 把軟體分為內部部分與外部部分 內部部分 包含 domain logic 先被開發，不受外部系統影響 外部部分 包含所有的依賴層 (dependency layers) 不屬於應用程式的部分，如 UI、資料庫 (DB)、或應用框架 (framework) Ports 介面 (interface)，定義外部系統可以使用的方法 兩種類型 Input Ports：由內部應用程式暴露給外部使用，定義應用程式的行為 Output Ports：由內部應用程式呼叫外部系統，如資料庫或 API Adapters 用來實作 Ports，轉換外部請求到應用程式內部邏輯 Primary Adapter 實作 Input Port，負責接收外部輸入並調用 Use Case 例如 Web Controller 或 CLI Handler Secondary Adapter 實作 Output Port，負責將 Use Case 的結果傳遞到外部系統 例如資料庫存取層 (Repository) 或 API 呼叫 Clean Architecture 目標是讓 domain logic 與其他部分分離，使系統可以隨時更換技術而不影響核心邏輯 透過 DIP (Dependency Inversion Principle) 達成 高層次模組不應依賴低層次模組，兩者應依賴抽象 抽象不應依賴細節，細節應依賴抽象 將軟體分為不同層次，並確保依賴方向只能往內部流動 常見架構比較 傳統三層架構 (Three-Tier Architecture)\n依賴關係：Presentation Layer -\u0026gt; Business Logic Layer -\u0026gt; Data Access Layer 這種架構會導致 Business Logic 依賴 Data Access，影響可測試性與可維護性 Clean Architecture\n所有外部層次都應依賴 Business Logic Layer (Use Cases) 依賴方向為 Frameworks \u0026amp; Drivers -\u0026gt; Interface Adapters -\u0026gt; Use Cases -\u0026gt; Entities 優點 技術可替換性高 domain logic 獨立於技術實現，允許更換 UI、資料庫、框架等技術 只需替換 Adapters，不影響核心邏輯 測試方便 domain logic 不依賴外部系統，可以使用 mock 測試 減少整合測試的負擔 更容易擴展與維護 避免不同技術層相互耦合，讓系統更具彈性 Clean Architecture 的層次結構 Entities 核心物件，負責企業規則 (Enterprise Business Rules) 只關心應用程式的核心邏輯，與技術無關 例如帳戶物件：包含帳號名稱、密碼、驗證密碼的方法 Use Cases 應用程式規則 (Application Business Rules)，定義具體業務邏輯 負責協調 Entities，確保業務流程正確 例如處理使用者登入、交易等邏輯 Interface Adapters 負責資料轉換，讓資料符合不同層的需求 例如 View Model 轉換、DTO 轉換、Repository 轉換 Frameworks and Drivers 包含所有技術相關的部分，如 Web 框架、資料庫、第三方 API 這些技術可以隨時替換，不影響 Use Cases 和 Entities ","date":"2023-05-22T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/clean-architecture/","title":"Clean Architecture"},{"content":"前言 軟體要對 domain 做 Modeling，呈現出 domain 裡的核心概念，才能滿足使用者需求，因此不乏與領域專家的討論\n通用語言 Ubiquitous Language 開發人員與領域專家熟悉的知識不同，容易產生交流困難。因此：\n領域專家和開發團隊要訂定共同的語言，避免使用自己熟悉但對方不理解的術語。 確保這些語言在代碼、文件、溝通中保持一致 Layered Architecture 分為四個概念層，只會往下調用，可能會跨層\n可以達到關注點分離 (separation of concerns)，提高各個方面的 cohesive\nUser Interface (Presentation Layer) 負責 UI 呈現（使用者可能是人或另一個系統） Application Layer 不包含 business logic，負責協調 domain object 完成業務流程 Domain Layer（核心） 負責業務邏輯、業務規則、狀態管理。 這一層的設計是 Model-Driven Design 的關鍵！ Infrastructure Layer 負責技術支援（如資料庫存取、外部 API 連接） 保存業務狀態的技術細節在此實作 為前三層提供支援 主要概念 Entity（實體） 具備 identity，即使 state 改變，identity 仍保持不變 Mutable，但應該透過業務邏輯來控制修改方式 追蹤 Entity 需要較高的成本 Value Object（值物件） 沒有 identity，只關心 Value Immutable（不可變），如需修改，則應創建新的值物件 可以安全地共用 可以輕易創建丟棄 Service 有些動作不屬於某個 Entity 或 Value Object，因為它是跨物件的 Stateless（無狀態）：每個請求互不影響 Aggregate（聚合） 把複雜關聯的物件聚合在一起，確保 consistency 和 invariants consistency (一致性) 相關物件的資料一致 invariants (不變量) 資料改變時要維護的規則 Aggregate Root： 具備 global identity，內部 Entity 只有 local identity 通常是 entity 擔任 外部只能透過 Aggregate Root 存取內部其他物件 其他 Building Blocks Factory 若創建 aggregate、entity、value object 的過程很複雜，或是涉及專業知識，就該用 factory 封裝 若情況不複雜，或是需要更細的控制，可以直接使用建構函式 Repository 若所有物件都直接存取資料庫，會破壞精心設計的結構，導致封裝性降低 Repository 封裝了資料庫操作，提供物件存取的統一介面 Domain event 代表 Domain 中的重要事件 其他物件或 aggregate 可以訂閱它，讓 aggregate 通知它們某個 domain event 發生 Strategic Design Subdomain 將 domain 拆分為小塊，理想情況下 subdomain 和 bounded context 是一對一的關係 類型 Core Subdomain 公司的競爭優勢所在，最核心的業務邏輯，例如搜尋引擎的搜尋演算法 Generic Subdomain 一般常見的功能，例如登入系統 Supporting Subdomain 輔助核心業務的部分，例如電商網站的商品篩選功能 Bounded Context 劃定界線，確保同一個 bounded context 內的概念和規則保持一致 相同的名詞可能在不同的 context 中有不同的意義 Context Map 描述 Bounded Context 之間的關係\n上下游 (U/D) 上游提供服務，下游依賴上游 Shared Kernel 兩個 BC 共享某些部分 違反 BC 原則，是一種例外設計 Customer-Supplier 一個子系統重度依賴另一個子系統 Conformist：Customer 完全配合 Supplier Partnership 兩個 BC 互相合作，沒有主次之分，成敗與共 Anticorruption Layer (ACL) 在開發系統與外部系統之間加一層適配，防止影響內部模型 常用到 Facade 和 Adapter Open Host Service (OHS) 外部系統提供統一的服務接口，避免每個用戶端都要自己實作 ACL 通常搭配 Published Language (PL)（PL 是協定傳送資料的格式，例如 XML、JSON、Protocol Buffer） Anti-Pattern 應該避免的情形 Smart UI 超肥的萬能 UI Anemic Domain Model 貧血模型 只有 getter 和 setter，沒有業務邏輯的模型 Pratical DDD The strangler migration 透過 Facade，把一些服務慢慢移植給新系統，最後取代 legacy ","date":"2023-05-22T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88-domain-driven-design/","title":"領域驅動設計 Domain-Driven Design"},{"content":"重構 在不改變軟體行為的情況下，對軟體內部構造進行改善\nCode Smell 也稱 Bad Smell，代表程式碼中需要重構的部分\nBloaters 程式碼（類別、方法）過於龐大\nLong Method 部分解法 用 Extract Method 拆解過長的 function 用 Replace Temp with Query 取代暫存變數 Large Class 一個 Class 有太多 fields / methods / lines 部分解法 Extract Class Extract Subclass 把部分功能移到新建的子類別 Long Parameter List 部分解法 Preserve Whole Object 把來自同一物件的資料直接該物件取代 Introduce Parameter Object 把相關的參數包成一個 Object Data Clumps 不同的程式碼區域出現相同的變數組（Guru 舉的例子是連接資料庫用的參數） 常一起出現的資料群應該被單獨抽成一個 Class 部分解法 Extract Class Introduce Parameter Object Primitive Obsession 過度使用基本類別（primitives），造成 Shotgun Surgery Magic Number 也是一種 Primitive Obsession 部分解法 Replace Data Value with Object Replace Type Code with Class Object-Orientation Abusers 亂用物件導向程式設計原則\nSwitch Statements 有非常複雜的 Switch Case 或是 if-else 部分解法 Replace Conditional with Polymorphism Replace Type Code with Subclasses 直接把多種狀態個別建立子物件，並把相關行為放進去，用多型處理 Replace Type Code with State/Strategy 用一個 state 物件來取代 type code Temporary Field 指那些只在特定情況下才會被使用的 field，平時都是 null 通常是因為存在需要大量參數的 function，但是這些參數被選擇放到 field 部分解法 Extract Class 把這些 field 和會用到的 function 抽成一個 Class Introduce Null Object 用一個 Null Object 來取代 null，他可以提供一些預設的行為 Alternative Classes with Different Interfaces 兩個 Class 具有功能相同、命名不同的 function 部分解法 Rename Method Extract Superclass 把兩個 Class 的共同功能抽成一個父類別 Change Preventers 一處改變會導致多處程式碼改變\nDivergent Change 對一個類別的修改會導致類別的多處也需要修改 部分解法 Extract Class Shotgun Surgery 某個責任被分散到大量的 Class 身上，使修改其時要大量修改 對多個類別進行同一種修改 部分解法 Move Method Move Field Dispensables 不必要的程式碼\nDuplicated Code 多個程式碼片段幾乎相同 部分解法 Extract Method Lazy Class 沒什麼用的冗餘 Class 部分解法 Inline Class 把這個 Class 的 feature 全部移到另一個 Class Collapse Hierarchy 子類別和父類別功能差不多，可以把子類別和父類別合併 Couplers 導致類別之間高度耦合\nFeature Envy 存取別的 Object 的 Data 的情形比自己的還頻繁 這方法可能應該屬於另一個 Object 部分解法 Move Method 把這個方法移到另一個 Class Extract Method 如果只有一部分有這種情況，可以把這部分抽出來 Message Chains Client 請求 A 物件，A 物件又請求 B 物件，以此類推 部分解法 Hide Delegate 情境是 client 從 A 物件取得 B 物件，然後又呼叫 B 物件的方法 解法是把 B 物件的方法轉移給 A 物件 Extract Method \u0026amp; Move Method 把最終的方法抽出來，放到開頭的物件 Inappropriate Intimacy 一個類別使用另一個類別的內部欄位或方法 不單是存取私有變數，應該說依賴於另外一個類別的實作細節，比如出於某些原因知道要以特定順序呼叫方法 和 Feature Envy 相比，損害了其他類別的封裝性 部分解法 Move Method / Move Field 如果該類別確實不需要這些東西可以考慮 Extract Class 把這些方法和欄位抽成一個 Class ","date":"2023-04-25T14:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E9%87%8D%E6%A7%8B-refactoring/","title":"重構 Refactoring"},{"content":"Normalization 目的 避免 redundant information 資料重複容易導致資料不一致 避免 anomalies 避免資料不一致 隨著 1NF ~ 5NF，有更多的 safety guarantee\nFunctional Dependency {X} -\u0026gt; {Y}\nX 是 determinant，Y 是 dependent Y is functionally dependent on X (Y depends on X) X functionally determines Y 一個 attribute 的 value 可以決定另一個 attribute 的 value\nex: {playerID} -\u0026gt; {playerName} 這代表 playerID 決定了 playerName 用箭頭表示，左邊是 determinant，右邊是 dependent\n一個 attribute 可以有多個 dependent\nex: {playerID} -\u0026gt; {playerName, playerAge}\n一個 attribute 也可以是多個 attribute 的 dependent\nex: {playerID, itemID} -\u0026gt; {itemName}\n1NF 去除重複性 違反條件 用 row order 傳達資訊 mixing data types in single column 但 relational database 不會讓你這樣做 存在沒有 primary key 的 table repeating groups 同一個 column 有多個數值，或是在同一個 row 存多個同類型的數值 每個 column 的 value 都應該是 atomic ex : player item roy 1 item_1, 4 item_2 star 4 item_4 player item_type1 quantity1 item_type2 quantity2 roy item1 1 item2 4 star item_4 4 2NF 去除 partial dependency 所有的 non-key attribute 都要 depend on 整個 PK 非正式定義，有點細微差異 如果是 composite key，不能 depend on PK 的其中一部分 functional dependency ex: {playerID, itemID} -\u0026gt; {itemName} 違反的例子 ex: playerID itemID itemName 1 1 item_1 1 2 item_2 2 1 item_1 這裡的 PK 是 {playerID, itemID}，但 itemName 只 depend on itemID 3NF 去除 transitive dependency\ntransitive dependency {A} -\u0026gt; {B} -\u0026gt; {C} 考慮到 functional dependency 有遞移性(Transitivity)\nTransitivity {A} -\u0026gt; {B}，{B} -\u0026gt; {C}，則 {A} -\u0026gt; {C} 所有 non-key attribute 都要 depend on the whole key，不能 depend on 其他 non-key attribute\n違反的例子\nex: playerID itemID itemName itemCategory 1 1 item_1 weapon 1 2 item_2 weapon 2 1 item_1 weapon 這裡的 PK 是 {playerID, itemID}，但 itemCategory 只 depend on itemName 這裡的 itemCategory 是 transitive dependency Boyce-Codd Normal Form (BCNF) 3NF 的強化版，又稱 3.5NF 實務中大多做到 3NF 對於每個 functional dependency，左邊的 attribute 都是 super key 違反例子 ex: playerID itemID itemName PlayerName 1 1 item_1 roy 1 2 item_2 roy 2 1 item_1 test 存在至少兩個 functional dependency {itemID} -\u0026gt; {itemName} {playerID} -\u0026gt; {playerName} 但是 {playerID} 和 {itemID} 都不是 super key 拆成三個表就可以解決 4NF 要先符合 BCNF 去除多值依賴(Multivalued Dependency) multivalued dependency 一個表格至少要有 3 個 column 才有可能有 multivalued dependency 對於 {A} -\u0026gt; {B}，如果一個 A 可以對應到多個 B，也可以對應到多個 C，然後 B 和 C 獨立，則有 multivalued dependency 一個 table 中的所有 multivalued dependency 必須依賴於 key 5NF 又稱 Project-Join Normal Form (PJNF) 去除 join dependency join dependency 一個 table 可以表示成其他 table join 起來的結果 如果 JOIN dependency 存在，就拆分多個 table ","date":"2023-03-14T10:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/database-normalization/","title":"Database Normalization"},{"content":"Class Diagram 類別關係 (Class Relationships) 依賴 (Dependency) 描述：「uses-a」關係，表示某個類別暫時依賴於另一個類別，通常體現在方法的參數或回傳值中。 符號：虛線箭頭 - - -\u0026gt; 範例：Class A - - -\u0026gt; Class B（A 使用 B，但 B 的變動不會影響 A） 關聯 (Association) 描述：「knows-a」關係，表示兩個類別彼此有關聯，可存取對方的屬性或方法。 符號：實線 ----- 額外資訊： 單向關聯：A 知道 B，但 B 不知道 A 雙向關聯：A 和 B 彼此知道對方 聚合 (Aggregation) 描述：「has-a」關係，表示物件之間的組合，但子物件 (child) 可以獨立存在，不受 parent 影響。 符號：空心菱形 ◊----- 範例：學校 (School) 擁有多個老師 (Teacher)，但學校刪除後，老師仍然可以存在。 組合 (Composition) 描述：「has-a」關係，強於聚合，表示 child 的生命週期依賴 parent，若 parent 被刪除，child 也會消失。 符號：實心菱形 ◆----- 範例：房子 (House) 由房間 (Room) 組成，若房子被拆除，房間也會消失。 繼承 (Inheritance) 描述：「is-a」關係，表示子類別 (subclass) 繼承父類別 (superclass) 的屬性和行為。 符號：實線箭頭 -----▷ 範例：Dog 是 Animal 的子類別 (Dog -----▷ Animal) 實作 (Implementation) 描述：「can-do」關係，表示類別實作 (implements) 介面 (interface)。 符號：虛線箭頭 - - - -▷ 範例：Bird 實作 Flyable (Bird - - - -▷ Flyable) 額外特性 (Other Features) 導向 (Navigation) 若兩個類別都能訪問對方，則使用無箭頭的關聯線 -----。 若只有一方能訪問對方，則使用箭頭 -----\u0026gt;。 角色名稱 (Role Name) 在關聯線旁標示角色名稱，表示該類別在關係中的角色。 範例：Person 與 Car 之間的關係中，Car 可能有 owner 角色。 多重度 (Multiplicity) 定義關聯物件的數量。 範例： 1：只能有一個實例 0..1：最多一個 *：零個或多個 1..*：至少一個 自關聯 (Self-Association) 當類別內部的物件彼此有關聯時，可用自關聯 (Self-Association)。 範例：Employee 可能是另一個 Employee 的 manager。 存取修飾詞 (Access Modifiers) 在 UML 類別圖中，可以用 +、-、# 來表示不同的存取權限：\n符號 存取修飾詞 說明 + public 任何類別都可以存取 - private 只有該類別本身可以存取 # protected 只有該類別與其子類別可以存取 ~ package (default) 只有相同 package 內的類別可以存取 ","date":"2023-03-09T14:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/uml-%E7%AD%86%E8%A8%98/","title":"UML 筆記"},{"content":"軟體設計原則 軟體設計原則 Encapsulate What Varies 封裝經常改變的程式碼，以避免影響其他區塊的程式碼，提升維護性 具體做法包括將變動部分抽象為 interface，讓實作細節與使用方解耦 例如，在策略模式（Strategy Pattern）中，將變動行為封裝於獨立類別，並透過 interface 進行交換 Favor Composition over Inheritance Composition（組合）在許多情境下可取代 Inheritance（繼承），並能達成 Polymorphism（多型） 只有在符合 is-a 關係時才應考慮使用繼承，例如「貓是動物」 Composition 透過組合物件的方式擴展功能，通常比繼承更具彈性，且能降低耦合度 比如有 Engine 類別，Car 可以有一個 Engine 的物件，而不是繼承 Engine SOLID 設計原則 Single Responsibility Principle (SRP) - 單一職責原則 A class should have only one reason to change 每個類別應該只負責一項功能，避免職責過於複雜 實踐方式： 把一個複雜的模組拆成多個獨立的類別 例如，把「資料庫存取」與「商業邏輯」分開，避免單一類別同時負責多種功能 Open-Closed Principle (OCP) - 開放封閉原則 You should be able to extend the behavior of a system without having to modify that system 系統應該對擴充開放，對修改封閉 實踐方式： 使用抽象類別與介面，讓新功能可以透過擴展來新增，而不是直接修改原始碼 例如，在 Shape 介面下定義 draw()，新增 Circle、Rectangle 只需實作該介面，而無需修改原有 Shape 相關程式碼 Liskov Substitution Principle (LSP) - 里氏替換原則 子類別應該能替換父類別，且不影響程式的正確性 確保繼承時不破壞原有功能，避免發生「使用父類別時正常，但換成子類別就出錯」的情況 實踐方式： 避免子類別重寫父類別方法時，改變原有的行為或拋出例外 例如，如果 Bird 有 fly() 方法，而 Penguin 繼承 Bird，但企鵝不會飛，則應改用 CanFly 介面來區分，而非讓 Penguin 繼承 Bird 而空實作 fly() Interface Segregation Principle (ISP) - 介面隔離原則 No client should be forced to depend on methods it does not use 避免讓一個介面擁有過多功能，導致實作該介面的類別需要實作不必要的功能 實踐方式： 把大介面拆分為多個小介面，使類別只需實作與自身業務相關的介面 例如，Worker 介面包含 work()、eat() 方法，則應將其拆成 Workable 介面（包含 work()）與 Eatable 介面（包含 eat()），避免機器人類別被迫實作 eat() Dependency Inversion Principle (DIP) - 依賴反轉原則 高階模組不應該依賴低階模組，兩者都應依賴抽象層 抽象不應依賴具體實現，具體實現應依賴抽象 實踐方式： 透過 interface 或 抽象類別 來解耦高階與低階模組 例如，OrderService 依賴 PaymentProcessor 介面，而不是直接依賴 PayPalProcessor 或 StripeProcessor，這樣未來更換支付方式時無需修改 OrderService Modularity Coupling（耦合） 模組間的依賴程度，耦合越鬆散，模組的獨立性越高，維護與擴展性越好\nTight Coupling（緊密耦合） Content Coupling（內容耦合）\n一個模組直接依賴另一個模組的內部運作 範例：一個模組直接存取另一個模組的變數（假設變數表示長度，單位是公尺） 若另一個模組改變單位為公分，則所有存取該變數的模組都會受到影響 解法：透過 getter 提供 getMeter() 方法，而不是直接存取變數 Common Coupling（公共耦合）\n多個模組共同存取和修改同一個 global data 範例：多個模組使用相同的全域變數，當其中一個模組錯誤修改該變數時，其他模組可能會出錯 External Coupling（外部耦合）\n多個模組依賴相同的外部 I/O 範例：所有模組直接呼叫相同的 API，若 API 變更，所有模組都需修改 Medium Coupling（中等耦合） Control Coupling（控制耦合）\n一個模組透過參數影響另一個模組的內部邏輯 範例：函式 process(data, mode) 內部邏輯依賴 mode 參數，若 mode 值的定義變更，所有呼叫該函式的地方都需同步修改 Data-Structure Coupling（資料結構耦合）\n多個模組共用相同的 data structure 範例：若所有模組都依賴一個 dict 來存取資料，當 dict 結構變更時，所有模組都會受到影響 Loose Coupling（鬆散耦合） Data Coupling（資料耦合）\n模組之間僅透過資料交換（參數或回傳值）來溝通 範例：函式 calculateTax(amount) 接受 amount 參數，而不依賴全域變數 Message Coupling（訊息耦合）\n模組之間透過訊息或指令進行溝通，而不是直接影響彼此的邏輯 範例：一個模組透過 event bus 發送 order_created 訊息，另一個模組根據訊息執行相應動作（而不依賴具體的函式呼叫） Cohesion（內聚） 衡量模組內部功能的相關性，內聚度越高，模組的單一性越強，功能更專注且更易於維護\nWeak Cohesion（弱內聚） Coincidental Cohesion（偶然內聚）\n模組內的功能沒有關聯，只是被放在同一個檔案內 範例：單一檔案內包含不相關的函式，如 calculateTax() 和 generateReport() Temporal Cohesion（時間內聚）\n功能的唯一關聯是它們在相同時間執行 範例：Initializer 類別內包含 initDatabase()、initCache()、initLogger()，這些功能只在初始化時執行，內聚度較低 Logical Cohesion（邏輯內聚）\n模組內的功能可以被歸類為相同的類別 範例：BackupController 負責多種不同類型的備份，沒有專注於單一職責 Medium Cohesion（中等內聚） Procedural Cohesion（程序內聚）\n模組內的功能需要以特定順序執行 範例：Sender 類別內包含 connect()、sendData()、disconnect()，這些功能需要按照順序執行，內聚度較高 Communicational Cohesion（通信內聚）\n模組內的功能都圍繞在某個特定資料結構上 範例：ShoppingCart 類別內包含 addItem()、removeItem()、calculateTotal()，這些功能都圍繞在 items 屬性上 Sequential Cohesion（順序內聚）\n某個函式的輸出作為另一個函式的輸入，且具有執行順序 範例：readData() → processData() → saveData()，內聚度相對較高，但仍可能包含非核心功能 Strong Cohesion（強內聚） Functional Cohesion（功能內聚） 模組中的各部分都對模組中單一明確的目標有貢獻 範例：CalculateCircleArea 類別僅包含 calculateArea() 方法，專注於計算圓形面積 ","date":"2023-03-08T14:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-low-level/","title":"軟體設計 - Low Level"},{"content":"介紹 一種用於自動化找超參數的方法，用在採樣昂貴而且是黑盒子的情況\n流程 取樣一些資料點 生出一個 Surrogate Model(可採用 Gaussian Process) 反覆做以下事情 用 Acquisition Function 挑選下一個要採樣的點 重新評估 Surrogate Model Gaussian Process 最終的 prediction 是一個 distribution 而不是單一個數字 生成方法需借助 kernel function，常用 RBF(Radial Basis Function)\n$K(x, x^{\u0026rsquo;}|\\tau)=\\sigma^2exp(-\\frac{1}{2}(\\frac{x-x^{\u0026rsquo;}}{l})^2)$\n$\\sigma$ 和 $l$ 是兩個可以調整的超參數\nAcquisition Function 可用超參數來調節 exploitation 和 exploitation\nUCB(Upper confidence bound) PI(probability of improvement) EI(Expected improvement) ","date":"2023-01-26T01:36:53+08:00","permalink":"https://roykesydon.github.io/Blog/p/bayesian-optimization/","title":"Bayesian Optimization"}]