<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Full Stack on Roykesydon</title>
        <link>https://roykesydon.github.io/Blog/categories/full-stack/</link>
        <description>Recent content in Full Stack on Roykesydon</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 16 Aug 2024 00:00:17 +0800</lastBuildDate><atom:link href="https://roykesydon.github.io/Blog/categories/full-stack/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MongoDB 筆記</title>
        <link>https://roykesydon.github.io/Blog/p/mongodb-%E7%AD%86%E8%A8%98/</link>
        <pubDate>Fri, 16 Aug 2024 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/mongodb-%E7%AD%86%E8%A8%98/</guid>
        <description>&lt;h2 id=&#34;mongodb&#34;&gt;MongoDB&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以 BSON (Binary JSON) 儲存資料&lt;/li&gt;
&lt;li&gt;composite index
&lt;ul&gt;
&lt;li&gt;prefix
&lt;ul&gt;
&lt;li&gt;如果有一個 index 是 (a, b)，那麼 (a) 也是有效的 index&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;explain
&lt;ul&gt;
&lt;li&gt;用來看 query 的 execution plan&lt;/li&gt;
&lt;li&gt;cursor
&lt;ul&gt;
&lt;li&gt;BasicCursor
&lt;ul&gt;
&lt;li&gt;會 scan 整個 collection，是個警訊&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;掃描的文件數量
&lt;ul&gt;
&lt;li&gt;nscanned
&lt;ul&gt;
&lt;li&gt;掃描的 index 數量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nscannedObjects
&lt;ul&gt;
&lt;li&gt;掃描的 document 數量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;n
&lt;ul&gt;
&lt;li&gt;回傳的 document 數量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nscanned &amp;gt;= nscannedObjects &amp;gt;= n&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;scanAndOrder
&lt;ul&gt;
&lt;li&gt;是否需要把文件都放在 memory 並排序&lt;/li&gt;
&lt;li&gt;還會一次性回傳資料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;hint
&lt;ul&gt;
&lt;li&gt;強制使用某個 index&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;optimizer 挑選索引
&lt;ul&gt;
&lt;li&gt;第一階段 - 挑選最佳索引
&lt;ul&gt;
&lt;li&gt;最佳索引
&lt;ul&gt;
&lt;li&gt;包含所有的 filter 和 sort 的欄位&lt;/li&gt;
&lt;li&gt;range filter 和 sort 的欄位必須在 equality filter 的後面
&lt;ul&gt;
&lt;li&gt;sort 的欄位必須在 range filter 的後面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果有多個最佳索引就會隨便選一個&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二階段 - 透過實驗挑選索引
&lt;ul&gt;
&lt;li&gt;沒有最佳索引就會實驗判斷要選哪個，看看誰先找到指定數量的文件&lt;/li&gt;
&lt;li&gt;換句話說，如果有多個索引，optimizer 會選 nscanned 最小的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MMAPv1
&lt;ul&gt;
&lt;li&gt;Mongo 一開始用的 storage engine&lt;/li&gt;
&lt;li&gt;_id 直接對應到 diskloc，也就是 disk 的偏移量
&lt;ul&gt;
&lt;li&gt;查找速度驚人，但是更新就要維護偏移量很費時&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;採用 database-level lock，Mongo 後來也只更新成 collection-level lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WiredTiger
&lt;ul&gt;
&lt;li&gt;MongoDB 收購的 storage engine&lt;/li&gt;
&lt;li&gt;Document-level locking&lt;/li&gt;
&lt;li&gt;可以做到 compression&lt;/li&gt;
&lt;li&gt;5.2 之前
&lt;ul&gt;
&lt;li&gt;_id 會先被用來尋找 recordid，再用 recordid 去獲取 document&lt;/li&gt;
&lt;li&gt;recordid 是 clustered index&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5.3
&lt;ul&gt;
&lt;li&gt;_id 變成 clustered index&lt;/li&gt;
&lt;li&gt;之前 recordid 只有 64 位，但現在 _id 作為 primary key 有 12 bytes
&lt;ul&gt;
&lt;li&gt;對 secondary index 造成更大的負擔&lt;/li&gt;
&lt;li&gt;Mongo 想達成跨機器和 shard 的唯一性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Database 一般筆記</title>
        <link>https://roykesydon.github.io/Blog/p/database-%E4%B8%80%E8%88%AC%E7%AD%86%E8%A8%98/</link>
        <pubDate>Sun, 21 Jul 2024 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/database-%E4%B8%80%E8%88%AC%E7%AD%86%E8%A8%98/</guid>
        <description>&lt;h2 id=&#34;database-internal&#34;&gt;Database internal&lt;/h2&gt;
&lt;h3 id=&#34;storage-concept&#34;&gt;Storage concept&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Table&lt;/li&gt;
&lt;li&gt;Row_id
&lt;ul&gt;
&lt;li&gt;多數 database 會維護自己的 row_id&lt;/li&gt;
&lt;li&gt;也叫做 tuple id&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Page
&lt;ul&gt;
&lt;li&gt;多個 row 會被存在一個 page&lt;/li&gt;
&lt;li&gt;讀取不會只讀一個 row，而是一個或多個 page&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IO
&lt;ul&gt;
&lt;li&gt;IO operation 指的是存取 disk 的操作&lt;/li&gt;
&lt;li&gt;一個 IO 可能會獲得多個 page，也可能只是用 cache 的資料&lt;/li&gt;
&lt;li&gt;Database 常常會利用 cache 來減少 IO
&lt;ul&gt;
&lt;li&gt;因此有些 query 很快，可能是因為有快取資料可用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Heap data structure
&lt;ul&gt;
&lt;li&gt;儲存整個 table 的資料&lt;/li&gt;
&lt;li&gt;有些 database 會用 clustered index 來儲存，就不會有 heap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Index data structure (b-tree)
&lt;ul&gt;
&lt;li&gt;一個有 pointer 來指向 heap 的資料結構
&lt;ul&gt;
&lt;li&gt;較流行的是 b-tree&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以對一個或多個 column 做 index&lt;/li&gt;
&lt;li&gt;index 可以告訴你要查詢的資料在哪個 page&lt;/li&gt;
&lt;li&gt;index 也會被儲存在 page&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;row-oriented-vs-column-oriented&#34;&gt;Row-oriented vs Column-oriented&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Row-oriented database (row store)
&lt;ul&gt;
&lt;li&gt;每個 row 接著下個 row 來儲存&lt;/li&gt;
&lt;li&gt;每次 IO 會獲得多個 row，每個都有所有的 column&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Col-oriented database (column store)
&lt;ul&gt;
&lt;li&gt;每個 column 接著下個 column 來儲存&lt;/li&gt;
&lt;li&gt;比較好壓縮，也比較好做 aggregation，所以在一些分析資料的軟體會用到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-structure&#34;&gt;Data structure&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;B-tree
&lt;ul&gt;
&lt;li&gt;Balanced data structure for fast search&lt;/li&gt;
&lt;li&gt;限制
&lt;ul&gt;
&lt;li&gt;node 中的 element 同時存了 key 和 value&lt;/li&gt;
&lt;li&gt;range query 效率很差，因為要各別 random access&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B+Tree
&lt;ul&gt;
&lt;li&gt;B-tree 的變形，和 B-tree 很像，不過 internal node 只存放 key，只有 leaf node 會存放 value
&lt;ul&gt;
&lt;li&gt;internal node 因為現在只需要儲存 key，element size 比較小，所以可以存放更多 element&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;leaf node 會用 linked list 串起來
&lt;ul&gt;
&lt;li&gt;適合 range query&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通常一個 node 是一個 DBMS page&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LSM-tree
&lt;ul&gt;
&lt;li&gt;Log-Structured Merge-Tree&lt;/li&gt;
&lt;li&gt;都加在尾端，不會覆蓋原本的資料，對 SSD 有利&lt;/li&gt;
&lt;li&gt;B-Tree 為了平衡會頻繁修改&lt;/li&gt;
&lt;li&gt;有利於 insert&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fragmentation&#34;&gt;Fragmentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;這裡是以 database 為出發點去看 fragmentation&lt;/li&gt;
&lt;li&gt;Internal fragmentation
&lt;ul&gt;
&lt;li&gt;一個 Page 中有很多空間是空的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;External fragmentation
&lt;ul&gt;
&lt;li&gt;多個 Page 存放不是連續的。剩下的空間夠儲存新的資料，但是因為不連續，所以不能用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;database-cursor&#34;&gt;Database cursor&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;當資料庫有很大的結果集時，不可能一次把所有資料用網路傳給 client，用戶也沒有 memory 來存放所有資料&lt;/li&gt;
&lt;li&gt;Server side / client side cursor
&lt;ul&gt;
&lt;li&gt;Server side
&lt;ul&gt;
&lt;li&gt;一次只傳一部分資料給 client&lt;/li&gt;
&lt;li&gt;但是要多次往返可能最後總時間會比較久&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Client side
&lt;ul&gt;
&lt;li&gt;一次把所有資料傳給 client&lt;/li&gt;
&lt;li&gt;client 自己分批處理&lt;/li&gt;
&lt;li&gt;對 network bandwidth 要求較大&lt;/li&gt;
&lt;li&gt;可能沒有足夠的 memory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;partitioning&#34;&gt;Partitioning&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把大 table 分成多個小 table&lt;/li&gt;
&lt;li&gt;Vertical vs Horizontal
&lt;ul&gt;
&lt;li&gt;Vertical
&lt;ul&gt;
&lt;li&gt;根據 columns 拆成多個 partition&lt;/li&gt;
&lt;li&gt;可以把不太常用又大的 column (比如 blob) 放到另外一個 partition
&lt;ul&gt;
&lt;li&gt;可以把他放在較慢的 disk，保留其他常存取的 column 在 SSD&lt;/li&gt;
&lt;li&gt;也可以讓比較不常用的資料比較不容易進入 cache&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Horizontal
&lt;ul&gt;
&lt;li&gt;把 rows 拆成多個 partition&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;優點
&lt;ul&gt;
&lt;li&gt;用 single query 存取單一 partition 的速度更快&lt;/li&gt;
&lt;li&gt;對某些 sequential scan 有幫助&lt;/li&gt;
&lt;li&gt;可以把舊資料放在比較便宜的設備&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺點
&lt;ul&gt;
&lt;li&gt;如果要從一個 partition 移動資料到另一個 partition，效率很慢&lt;/li&gt;
&lt;li&gt;對於效率很差的 query，可能會需要 scan 所有 partition，此時比掃描整個沒做 partition 的 table 還要慢&lt;/li&gt;
&lt;li&gt;partition 可能會 unbalance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;database-indexing&#34;&gt;Database indexing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果需要搜索的欄位沒做 index，那麼就會需要 scan 整個 table，直到找到
&lt;ul&gt;
&lt;li&gt;如果要求欄位做 &lt;code&gt;like&lt;/code&gt; 之類的，那麼依然需要 scan 整個 table&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;搜索方法
&lt;ul&gt;
&lt;li&gt;table scan
&lt;ul&gt;
&lt;li&gt;如果掃描的範圍過大，Database 可能就會選擇該方法&lt;/li&gt;
&lt;li&gt;通常會用 parallel 的方式搜尋，所以還是會快一些&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;index scan&lt;/li&gt;
&lt;li&gt;Index-only scan
&lt;ul&gt;
&lt;li&gt;也叫 covering index&lt;/li&gt;
&lt;li&gt;需要的欄位在 index 裡面就有了，在這種情況不用去 heap 取，可以加速很多&lt;/li&gt;
&lt;li&gt;但也要小心使 index 變得過大。如果 memory 不夠，又會用到 disk，拖垮效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;non-key column
&lt;ul&gt;
&lt;li&gt;可以用 include 把一些常常需要一起帶入的資訊放到 index 裡面&lt;/li&gt;
&lt;li&gt;可以促成 index-only scan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;composite index
&lt;ul&gt;
&lt;li&gt;把多個 col 作為 key 做 index&lt;/li&gt;
&lt;li&gt;在 PostgreSQL ，如果有一個 index 是 (a, b)，用靠左的 index 可以做 index scan，但是用靠右的就不行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;clustered-index&#34;&gt;Clustered index&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;也叫做 Index-Organized Table
&lt;ul&gt;
&lt;li&gt;資料圍繞 index 來組織&lt;/li&gt;
&lt;li&gt;這也是為什麼 clustered index 只能有一個&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;沒特別指定的話，primary key 一般是 clustered index&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;primary-key-vs-secondary-key&#34;&gt;Primary key vs Secondary key&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;primary key
&lt;ul&gt;
&lt;li&gt;clusering
&lt;ul&gt;
&lt;li&gt;把 table 圍繞 primary key 來組織，但也有些 Database 不是這樣設計，比如 PostgreSQL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要維持 order，但是如果我要根據 PK 取得小範圍內的資料，和不顧排序相比，就可能不用多次 IO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Secondary key
&lt;ul&gt;
&lt;li&gt;不在乎原本 table 的 order，而是根據自訂的 key 來排序&lt;/li&gt;
&lt;li&gt;但是會有另外一個結構去放 index，可以找到 row_id&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;設計差異
&lt;ul&gt;
&lt;li&gt;PostgreSQL 的 index 都指向 row，不管是 primary 還是 secondary
&lt;ul&gt;
&lt;li&gt;這樣 secondary index 就可以直接取資料，不用再跳一層 primary key&lt;/li&gt;
&lt;li&gt;但是如果更新 row，會更新 row id，連帶影響要更新所有 secondary index，不管修改的欄位有沒有在這 index&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MySQL 的 secondary index 指向 primary key，primary key 指向 row
&lt;ul&gt;
&lt;li&gt;這樣 secondary index 就要先找到 primary key，再找到 row&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;distributed-database&#34;&gt;Distributed database&lt;/h2&gt;
&lt;h3 id=&#34;sharding&#34;&gt;Sharding&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把 table 拆成多個 table，分散在不同的 database&lt;/li&gt;
&lt;li&gt;分散式會帶來很多問題，比如要怎麼做 transaction 和 join?&lt;/li&gt;
&lt;li&gt;Horizontal partitioning vs sharding
&lt;ul&gt;
&lt;li&gt;Horizontal partitioning
&lt;ul&gt;
&lt;li&gt;一個 table 拆成多個 table，但是還是在同一個 database&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;和 Horizontal partitioning 的差別
&lt;ul&gt;
&lt;li&gt;table 現在會分到不同的 database server&lt;/li&gt;
&lt;li&gt;做 partition，client 不用管資料具體在哪個 partition，交給 DBMS 去處理。但是 sharding 就要 client 自己去處理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;database-replication&#34;&gt;Database replication&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;透過 redundancy 來提高 reliability, tolerance, accessibility&lt;/li&gt;
&lt;li&gt;Master / Backup replication
&lt;ul&gt;
&lt;li&gt;也叫 master-slave replication&lt;/li&gt;
&lt;li&gt;只有一個 master / leader，有一或多個 backup / standby&lt;/li&gt;
&lt;li&gt;一寫多讀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multi-master replication
&lt;ul&gt;
&lt;li&gt;多個 master，可以同時寫入&lt;/li&gt;
&lt;li&gt;需要處理 conflict&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sychronous vs Asynchronous replication
&lt;ul&gt;
&lt;li&gt;Synchronous
&lt;ul&gt;
&lt;li&gt;transaction 會被 blocked，直到所有的 backup 都寫入&lt;/li&gt;
&lt;li&gt;有些 database 可以設定 First N 或是 any 完成就好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Asynchronous
&lt;ul&gt;
&lt;li&gt;transaction 被寫入 master 後就算完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;concurrency-control&#34;&gt;Concurrency control&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;strategy
&lt;ul&gt;
&lt;li&gt;pessimistic
&lt;ul&gt;
&lt;li&gt;用各種 lock 來保證 isolation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;optimistic
&lt;ul&gt;
&lt;li&gt;不用 lock，真的有 transaction 衝突時就 fail&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lock
&lt;ul&gt;
&lt;li&gt;shared vs exclusive
&lt;ul&gt;
&lt;li&gt;shared lock 可以被多個 transaction 同時持有
&lt;ul&gt;
&lt;li&gt;用在讀取，所以可以多個 transaction 同時讀取&lt;/li&gt;
&lt;li&gt;在有 shared lock  的條件下，其他 transaction 也可以設置 shared lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;exclusive lock 只能被一個 transaction 持有
&lt;ul&gt;
&lt;li&gt;他人不能讀取或寫入&lt;/li&gt;
&lt;li&gt;PostgreSQL 有一個 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 來取得 exclusive lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;當涉及的資料持有其中一種 lock 時，其他 transaction 都不能設置另外一種 lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Deadlock
&lt;ul&gt;
&lt;li&gt;多個 transaction 互相等待對方釋放 lock&lt;/li&gt;
&lt;li&gt;多數 DBMS 會檢查 deadlock，並讓最後一個造成 deadlock 的 transaction rollback&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Two-phase locking (2PL)
&lt;ul&gt;
&lt;li&gt;DBMS 為了實現 isolation 需要保證 conflict serializability (CSR)，2PL 可以保證這一點&lt;/li&gt;
&lt;li&gt;two-phase
&lt;ul&gt;
&lt;li&gt;growing phase
&lt;ul&gt;
&lt;li&gt;取得 lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;shrinking phase
&lt;ul&gt;
&lt;li&gt;釋放 lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;強調一個 transaction 不能釋放 lock 後就再也無法取得&lt;/li&gt;
&lt;li&gt;有可能造成 deadlock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;database-engine&#34;&gt;Database Engine&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;也叫 storage engine 或 embedded database&lt;/li&gt;
&lt;li&gt;負責處理 CRUD 的 library&lt;/li&gt;
&lt;li&gt;DBMS 基於 engine 來提供更多功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;orm&#34;&gt;ORM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Eager vs Lazy loading
&lt;ul&gt;
&lt;li&gt;Eager
&lt;ul&gt;
&lt;li&gt;一次把所有相關的資料都讀取出來&lt;/li&gt;
&lt;li&gt;如果 Teacher 有很多 Student，可能會一次把所有 Student 都讀取出來&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lazy
&lt;ul&gt;
&lt;li&gt;只有在需要的時候才讀取&lt;/li&gt;
&lt;li&gt;但是可能會有很多次 IO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Open session in view (OSIV)
&lt;ul&gt;
&lt;li&gt;一個 request 一個 database session&lt;/li&gt;
&lt;li&gt;可以配合 lazy loading 來用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;N+1 problem
&lt;ul&gt;
&lt;li&gt;一個 query 取得所有資料，然後再用每個資料的 id 來取得相關資料&lt;/li&gt;
&lt;li&gt;這樣就會有 N+1 次 IO
&lt;ul&gt;
&lt;li&gt;第一次是從主表拿清單&lt;/li&gt;
&lt;li&gt;接下來 N 次是從子表拿資料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tips&#34;&gt;Tips&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;盡量不要使用 offset
&lt;ul&gt;
&lt;li&gt;最 naive 的實現 pagination 的做法就是用 offset + limit。但是 offset 代表讀取並丟掉前面幾筆資料，所以他會多讀一堆沒用的資料&lt;/li&gt;
&lt;li&gt;可以讓用戶那邊保存 id，where 設置 id 要大於多少來規避 offset&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Connection pool
&lt;ul&gt;
&lt;li&gt;維護一定數量的連接，避免每次都要建立連接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Idempotency key
&lt;ul&gt;
&lt;li&gt;用來確保一個 request 只會被執行一次&lt;/li&gt;
&lt;li&gt;會生成一個唯一的 key，並且在 request 中帶上這個 key。執行操作後會把這個 key 存起來，下次再收到這個 key 時就不會再執行操作&lt;/li&gt;
&lt;li&gt;可以用 ULID 而不用 UUID，因為 ULID 前面的 bit 有時間戳，可以用來排序
&lt;ul&gt;
&lt;li&gt;輸入的資料集中在相近的 page，還都加在尾端，可以減少 IO (相較隨機的 UUID)
&lt;ul&gt;
&lt;li&gt;不用被迫頻繁存取 disk。而且 UUID 的隨機性拉一堆 page 會導致 buffer 更容易被塞滿，而得強制寫入 disk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;consistent hashing
&lt;ul&gt;
&lt;li&gt;把 hash function 的結果分散在一個 hash ring 上
&lt;ul&gt;
&lt;li&gt;根據 hash function 的結果，看自己落在哪段範圍，配給指定的 server&lt;/li&gt;
&lt;li&gt;這樣的好處是追加或是移除 server 時，只會影響一台 server 的資料&lt;/li&gt;
&lt;li&gt;也可以追加到負載比較高的 server 附近&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;write amplification
&lt;ul&gt;
&lt;li&gt;寫入資料時，發現 disk 寫入的資料比你預期寫入的資料多很多&lt;/li&gt;
&lt;li&gt;分很多不同 level，通常是在說 SSD 造成的&lt;/li&gt;
&lt;li&gt;想更新的時候，更新的 page 會被標記為不能使用。會有另外一隻非同步程式定期處理這種
&lt;ul&gt;
&lt;li&gt;但是他會把整個 block 寫到新的地方，再把原地方設為 free，就為了那些不能再被使用的空間搬整個 block&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Angular 筆記</title>
        <link>https://roykesydon.github.io/Blog/p/angular-%E7%AD%86%E8%A8%98/</link>
        <pubDate>Fri, 24 May 2024 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/angular-%E7%AD%86%E8%A8%98/</guid>
        <description>&lt;h2 id=&#34;基礎概念&#34;&gt;基礎概念&lt;/h2&gt;
&lt;h3 id=&#34;module&#34;&gt;Module&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把相關的 Component、Directive、Pipe、Service 等打包在一起的容器&lt;/li&gt;
&lt;li&gt;Lazy Loading&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;component&#34;&gt;Component&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Angular 應用程式的基本組成單位&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pipe&#34;&gt;Pipe&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用來轉換資料的工具，可以把字串格式化、日期格式化等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;directive&#34;&gt;Directive&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用來修改 DOM 元素的外觀或行為
&lt;ul&gt;
&lt;li&gt;比如說 ngIf、ngFor、ngStyle、ngClass&lt;/li&gt;
&lt;li&gt;類型
&lt;ul&gt;
&lt;li&gt;Structural Directive: 修改 DOM 的結構
&lt;ul&gt;
&lt;li&gt;可以搭配
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng-container&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;不會產生額外的 DOM 元素，可以用在想要用 ngIf 和 ngFor 但不想產生額外元素的情況&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*ngFor&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let item of items; index as i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Attribute Directive: 修改 DOM 的屬性&lt;/li&gt;
&lt;li&gt;Component Directive: 包含 template 的 directive&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;service&#34;&gt;Service&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;負責 API 請求、資料處理等工作&lt;/li&gt;
&lt;li&gt;Dependency Injection&lt;/li&gt;
&lt;li&gt;@Injectable
&lt;ul&gt;
&lt;li&gt;providedIn
&lt;ul&gt;
&lt;li&gt;root: 全域共用&lt;/li&gt;
&lt;li&gt;也可以在 component 的 providers 中設定要注入的 service&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;router&#34;&gt;Router&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;負責處理 URL 路由&lt;/li&gt;
&lt;li&gt;routes
&lt;ul&gt;
&lt;li&gt;path&lt;/li&gt;
&lt;li&gt;component&lt;/li&gt;
&lt;li&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;guard
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng g guard &amp;lt;guard-name&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h2 id=&#34;canactivate&#34;&gt;CanActivate&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cli-command&#34;&gt;CLI Command&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng new my-app&lt;/code&gt;: 建立新的 Angular 專案&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng serve&lt;/code&gt;: 啟動開發伺服器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng build&lt;/code&gt;: 打包專案&lt;/li&gt;
&lt;li&gt;generate
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng generate module my-module&lt;/code&gt;: 建立新的 Module&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng generate component my-component&lt;/code&gt;: 建立新的 Component
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--module=app&lt;/code&gt;: 指定 Component 所屬的 Module&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng generate service my-service&lt;/code&gt;: 建立新的 Service&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng generate pipe my-pipe&lt;/code&gt;: 建立新的 Pipe&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng generate directive my-directive&lt;/code&gt;: 建立新的 Directive&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;module-1&#34;&gt;Module&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NgModule
&lt;ul&gt;
&lt;li&gt;declarations: 定義同一 Module 中的 Component、Directive、Pipe&lt;/li&gt;
&lt;li&gt;imports: 匯入其他 Module&lt;/li&gt;
&lt;li&gt;providers: 定義 Service&lt;/li&gt;
&lt;li&gt;bootstrap: 定義啟動的 Component&lt;/li&gt;
&lt;li&gt;exports: 定義要匯出的 Component、Directive、Pipe&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;component-1&#34;&gt;Component&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;包含元素
&lt;ul&gt;
&lt;li&gt;Template&lt;/li&gt;
&lt;li&gt;TypeScript Class
&lt;ul&gt;
&lt;li&gt;.spec.ts: 測試檔&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Selector: 定義 Component 的名稱&lt;/li&gt;
&lt;li&gt;CSS Style&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;standalone
&lt;ul&gt;
&lt;li&gt;新版 Angular 預設 app 使用 Standalone 模式，使 component 不再需要透過 NgModule 管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lifecycle-hooks&#34;&gt;Lifecycle Hooks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ngOnChanges
&lt;ul&gt;
&lt;li&gt;當 Angular 重新綁定輸入屬性時調用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngOnInit
&lt;ul&gt;
&lt;li&gt;當 Angular 初始化指令/元件時調用&lt;/li&gt;
&lt;li&gt;在第一輪 ngOnChanges 後調用&lt;/li&gt;
&lt;li&gt;只調用一次&lt;/li&gt;
&lt;li&gt;使用場景
&lt;ul&gt;
&lt;li&gt;初始化資料（需要根據 @Input 變數）&lt;/li&gt;
&lt;li&gt;fetch data from API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngDoCheck
&lt;ul&gt;
&lt;li&gt;在 ngOnChange 和 ngOnInit 之後調用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngAfterContentInit
&lt;ul&gt;
&lt;li&gt;在 Angular 把 ng-content 投影到 view 後調用&lt;/li&gt;
&lt;li&gt;在第一個 ngDoCheck 之後調用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngAfterContentChecked
&lt;ul&gt;
&lt;li&gt;在 ng-content 的內容變更後調用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngAfterViewInit
&lt;ul&gt;
&lt;li&gt;在 Angular 初始化完 view 後調用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngAfterViewChecked
&lt;ul&gt;
&lt;li&gt;在每次做完 view 的變更檢查後調用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ngOnDestroy
&lt;ul&gt;
&lt;li&gt;在 Angular 銷毀 directive/component 前調用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;component-check&#34;&gt;Component check&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作
&lt;ul&gt;
&lt;li&gt;update child component input binding&lt;/li&gt;
&lt;li&gt;update DOM interpolation&lt;/li&gt;
&lt;li&gt;update query list&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sharing-data&#34;&gt;Sharing Data&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;@Input
&lt;ul&gt;
&lt;li&gt;父元件傳遞資料給子元件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Output
&lt;ul&gt;
&lt;li&gt;子元件傳遞資料給父元件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;binding&#34;&gt;Binding&lt;/h2&gt;
&lt;h3 id=&#34;property-binding&#34;&gt;Property Binding&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用來設定 HTML 元素的屬性&lt;/li&gt;
&lt;li&gt;用中括號 &lt;code&gt;[]&lt;/code&gt; 包住屬性名稱&lt;/li&gt;
&lt;li&gt;ex: &lt;code&gt;&amp;lt;img [src]=&amp;quot;imageUrl&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;event-binding&#34;&gt;Event Binding&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用來設定 HTML 元素的事件&lt;/li&gt;
&lt;li&gt;用小括號 &lt;code&gt;()&lt;/code&gt; 包住事件名稱&lt;/li&gt;
&lt;li&gt;ex: &lt;code&gt;&amp;lt;button (click)=&amp;quot;onClick()&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$event&lt;/code&gt;: 可以取得事件物件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;two-way-binding&#34;&gt;Two-way Binding&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把屬性和事件綁定在一起&lt;/li&gt;
&lt;li&gt;用中括號和小括號 &lt;code&gt;[(ngModel)]&lt;/code&gt; 包住屬性名稱&lt;/li&gt;
&lt;li&gt;ex: &lt;code&gt;&amp;lt;input [(ngModel)]=&amp;quot;name&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Spring Boot 筆記</title>
        <link>https://roykesydon.github.io/Blog/p/spring-boot-%E7%AD%86%E8%A8%98/</link>
        <pubDate>Mon, 06 May 2024 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/spring-boot-%E7%AD%86%E8%A8%98/</guid>
        <description>&lt;h2 id=&#34;maven&#34;&gt;Maven&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;專案管理工具&lt;/li&gt;
&lt;li&gt;會先檢查 maven local repository 有沒有需要的 dependency，沒有的話就會去 maven central repository (remote repository) 下載&lt;/li&gt;
&lt;li&gt;pom.xml
&lt;ul&gt;
&lt;li&gt;project cooridnate
&lt;ul&gt;
&lt;li&gt;groupId&lt;/li&gt;
&lt;li&gt;artifactId&lt;/li&gt;
&lt;li&gt;version&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;plugin
&lt;ul&gt;
&lt;li&gt;和 dependency 的差別是，是用來執行某種 task 的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;mvnw
&lt;ul&gt;
&lt;li&gt;maven wrapper&lt;/li&gt;
&lt;li&gt;在沒有安裝 maven 的環境下，會下載正確的 maven 版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spring&#34;&gt;Spring&lt;/h2&gt;
&lt;h3 id=&#34;ioc&#34;&gt;IoC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Invocation of Constructor
&lt;ul&gt;
&lt;li&gt;把物件交給 Spring 管理&lt;/li&gt;
&lt;li&gt;loose coupling&lt;/li&gt;
&lt;li&gt;Dependency Injection&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bean
&lt;ul&gt;
&lt;li&gt;給 Spring 管理的物件&lt;/li&gt;
&lt;li&gt;創建方法
&lt;ul&gt;
&lt;li&gt;@Component
&lt;ul&gt;
&lt;li&gt;創建出的 Bean 名字是 class 的開頭轉小寫&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注入方法
&lt;ul&gt;
&lt;li&gt;@Autowired
&lt;ul&gt;
&lt;li&gt;種類
&lt;ul&gt;
&lt;li&gt;field injection
&lt;ul&gt;
&lt;li&gt;不太推薦，不利於 unit test&lt;/li&gt;
&lt;li&gt;spring boot 會先建立所有 component，在逐一注入，使元件可能短暫處於初始化不完整狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;constructor injection
&lt;ul&gt;
&lt;li&gt;最推薦&lt;/li&gt;
&lt;li&gt;建立 bean 時就注入&lt;/li&gt;
&lt;li&gt;確保 component 被使用時是處於完整的狀態&lt;/li&gt;
&lt;li&gt;有利於 unit test，因為可以把設計好的 mock bean 從 constructor 傳入&lt;/li&gt;
&lt;li&gt;spring 建議使用 constructor injection&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;setter injection
&lt;ul&gt;
&lt;li&gt;用 setter 來注入&lt;/li&gt;
&lt;li&gt;創好 component 後，再注入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限制
&lt;ol&gt;
&lt;li&gt;該 Class 也得是 Bean&lt;/li&gt;
&lt;li&gt;會根據類型注入 bean
&lt;ul&gt;
&lt;li&gt;如果同時有多個同類型的 bean，會報錯，可以用 @Qualifier 指定要注入的 bean 名稱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;@Qualifier
&lt;ul&gt;
&lt;li&gt;指定要注入的 bean 名稱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Primary
&lt;ul&gt;
&lt;li&gt;如果有多個同類型的 bean，會優先注入這個 bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cycle life
&lt;ul&gt;
&lt;li&gt;@PostConstruct
&lt;ul&gt;
&lt;li&gt;創建 bean 後，就會執行這個方法&lt;/li&gt;
&lt;li&gt;限制
&lt;ul&gt;
&lt;li&gt;必須是 public void&lt;/li&gt;
&lt;li&gt;不能有參數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@PreDestroy
&lt;ul&gt;
&lt;li&gt;bean 被銷毀前執行&lt;/li&gt;
&lt;li&gt;限制
&lt;ul&gt;
&lt;li&gt;必須是 public void&lt;/li&gt;
&lt;li&gt;不能有參數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lazy Initialization
&lt;ul&gt;
&lt;li&gt;本來 beans 不管有沒有用都會被創建&lt;/li&gt;
&lt;li&gt;@Lazy
&lt;ul&gt;
&lt;li&gt;只有在要使用時才會初始化&lt;/li&gt;
&lt;li&gt;缺點是用 @RestController 的話，第一次 request 才會創建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以在 application.properties 裡設定 spring.main.lazy-initialization=true，讓所有 beans 都變成 lazy initialization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aop&#34;&gt;AOP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Aspect Oriented Programming&lt;/li&gt;
&lt;li&gt;透過 Aspect 統一處理不同方法的共同邏輯&lt;/li&gt;
&lt;li&gt;要導入 aop 的 starter&lt;/li&gt;
&lt;li&gt;只有 Bean 才能設置 @Aspect&lt;/li&gt;
&lt;li&gt;Annotation
&lt;ul&gt;
&lt;li&gt;@Aspect
&lt;ul&gt;
&lt;li&gt;這個 class 是一個切面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Before
&lt;ul&gt;
&lt;li&gt;加上切入點，就可以在切入點 (Pointcut) 的方法執行前執行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@After
&lt;ul&gt;
&lt;li&gt;在方法之後執行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Around
&lt;ul&gt;
&lt;li&gt;在方法之前和之後都執行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常用的功能都已經被封裝好了，開發較少用到 AOP&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;run-app&#34;&gt;Run app&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;use &lt;code&gt;java -jar&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mvn clean package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java -jar target/xxx.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;mvn spring-boot:run&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mvn spring-boot:run&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;h3 id=&#34;starter&#34;&gt;Starter&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using.build-systems.starters&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring Boot Starters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;官方的 starter 命名是 &lt;code&gt;spring-boot-starter-*&lt;/code&gt;
第三方的 starter 命名是 &lt;code&gt;*-spring-boot-starter&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;外部化配置&#34;&gt;外部化配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;application.properties&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;重新啟動 jar 時會自動載入，不用改配置要重新 build jar&lt;/li&gt;
&lt;li&gt;集中管理&lt;/li&gt;
&lt;li&gt;@Value
&lt;ul&gt;
&lt;li&gt;可以注入到變數中&lt;/li&gt;
&lt;li&gt;可以用 &lt;code&gt;:&lt;/code&gt; 來設定預設值&lt;/li&gt;
&lt;li&gt;限制
&lt;ul&gt;
&lt;li&gt;只能在 Bean 和 Configuration 中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;YAML
&lt;ul&gt;
&lt;li&gt;application.properties 寫多後，沒有層級辨識度&lt;/li&gt;
&lt;li&gt;application.yml&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;profiles
&lt;ul&gt;
&lt;li&gt;可以根據不同的環境來設定不同的配置 (dev, test, prod)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application-{profile}.properties&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application-{profile}.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.profiles.active&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;指定啟用的 profile&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jar
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Dspring.profiles.active=dev&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指定配置文件
&lt;ul&gt;
&lt;li&gt;cli
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--spring.config.location&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Config 資料夾
&lt;ul&gt;
&lt;li&gt;可以在 jar 目錄下建立 config 資料夾，放配置文件，不用輸入額外的 args&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大致分類
&lt;ul&gt;
&lt;li&gt;core
&lt;ul&gt;
&lt;li&gt;logging&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;web&lt;/li&gt;
&lt;li&gt;security&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;li&gt;actuator&lt;/li&gt;
&lt;li&gt;integration&lt;/li&gt;
&lt;li&gt;devtools&lt;/li&gt;
&lt;li&gt;test&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dependency-management&#34;&gt;Dependency Management&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;parent 寫了版本號，故 dependency 可以不用寫版本號&lt;/li&gt;
&lt;li&gt;真的要指定的話，可以利用 maven 的就近原則&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;auto-configuration&#34;&gt;Auto Configuration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Component Scan
&lt;ul&gt;
&lt;li&gt;Spring Boot 會掃描主程式所在的 package 以及子 package&lt;/li&gt;
&lt;li&gt;也可以在主程式上加以下註解來指定掃描的 package
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@SpringBootApplication(scanBasePackages = &amp;quot;com.example&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有 starter 都有 &lt;code&gt;spring-boot-starter&lt;/code&gt;，&lt;code&gt;spring-boot-starter&lt;/code&gt; 又有 &lt;code&gt;spring-boot-autoconfigure&lt;/code&gt;，這個就是自動配置的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;spring boot 默認掃描不到 spring-boot-autoconfigure 的所有配置類 (因為預設只掃描 Main Application Class 的 package)，但是 @SpringBootApplication 的 @EnableAutoConfiguration 會預設掃描 spring-boot-autoconfigure 的所有配置類
&lt;ul&gt;
&lt;li&gt;它們再依據 conditional annotation 來決定是否要啟用這個配置類&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;common-annotations&#34;&gt;Common Annotations&lt;/h2&gt;
&lt;p&gt;Spring Boot 放棄了 XML 配置，改用 Annotation 配置&lt;/p&gt;
&lt;h3 id=&#34;component-registration&#34;&gt;Component registration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@Configuration, @SpringBootConfiguration
&lt;ul&gt;
&lt;li&gt;@Bean
&lt;ul&gt;
&lt;li&gt;有時候可能會想用第三方套件，此時可能不能修改套件的 code，這時候就可以用 @Configuration 來註冊 bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Controller, @Service, @Repository, @Component
&lt;ul&gt;
&lt;li&gt;三層式架構
&lt;ul&gt;
&lt;li&gt;@Controller
&lt;ul&gt;
&lt;li&gt;用來處理請求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Service
&lt;ul&gt;
&lt;li&gt;用來處理業務邏輯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Repository
&lt;ul&gt;
&lt;li&gt;用來處理資料庫操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@SpringBootApplication
&lt;ul&gt;
&lt;li&gt;由以下組成
&lt;ul&gt;
&lt;li&gt;@SpringBootConfiguration&lt;/li&gt;
&lt;li&gt;@EnableAutoConfiguration&lt;/li&gt;
&lt;li&gt;@ComponentScan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Web
&lt;ul&gt;
&lt;li&gt;@RestController
&lt;ul&gt;
&lt;li&gt;@Controller + @ResponseBody&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@RequestMapping
&lt;ul&gt;
&lt;li&gt;設置 route&lt;/li&gt;
&lt;li&gt;Method
&lt;ul&gt;
&lt;li&gt;@GetMapping&lt;/li&gt;
&lt;li&gt;@PostMapping&lt;/li&gt;
&lt;li&gt;@PutMapping&lt;/li&gt;
&lt;li&gt;@DeleteMapping&lt;/li&gt;
&lt;li&gt;@PatchMapping&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;取得參數
&lt;ul&gt;
&lt;li&gt;@RequestParam
&lt;ul&gt;
&lt;li&gt;取得 url 中的參數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@RequestBody
&lt;ul&gt;
&lt;li&gt;取得 request body&lt;/li&gt;
&lt;li&gt;根據欄位名字調用對應的 setter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@RequestHeader
&lt;ul&gt;
&lt;li&gt;取得 header&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@PathVariable
&lt;ul&gt;
&lt;li&gt;取得 route 中的參數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Scope
&lt;ul&gt;
&lt;li&gt;mode
&lt;ul&gt;
&lt;li&gt;singleton
&lt;ul&gt;
&lt;li&gt;預設，共用一個 instance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;prototype
&lt;ul&gt;
&lt;li&gt;每次注入都創建新的 instance&lt;/li&gt;
&lt;li&gt;可以用 proxy.mode = ScopedProxyMode.TARGET_CLASS，會變成每次調用 method 都創建新的 instance&lt;/li&gt;
&lt;li&gt;prototype 的元件生出後，spring 不會再管理，要自己管理生命週期，相當於 new 出物件的替代作法&lt;/li&gt;
&lt;li&gt;預設是 lazy initialization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;request
&lt;ul&gt;
&lt;li&gt;每個 request 都有一個獨立的 instance&lt;/li&gt;
&lt;li&gt;request 指的是 HTTP request，從進入 controller 到離開 controller&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;session
&lt;ul&gt;
&lt;li&gt;每個 session 都有一個獨立的 instance&lt;/li&gt;
&lt;li&gt;session 指的是 HTTP session，從進入 controller 到離開 controller&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;conditional-annotations&#34;&gt;Conditional Annotations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;條件成立則觸發指定行為&lt;/li&gt;
&lt;li&gt;ConditionalOn&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;example
&lt;ul&gt;
&lt;li&gt;ConditionalOnClass
&lt;ul&gt;
&lt;li&gt;如果 classpath 有指定的 class 才會觸發&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ConditionalOnMissingClass
&lt;ul&gt;
&lt;li&gt;如果 classpath 沒有指定的 class 才會觸發&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ConditionalOnBean
&lt;ul&gt;
&lt;li&gt;如果容器中有指定的 bean 才會觸發&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ConditionalOnMissingBean
&lt;ul&gt;
&lt;li&gt;如果容器中沒有指定的 bean 才會觸發&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scenario
&lt;ul&gt;
&lt;li&gt;如果有某個 dependency，則創建某個 bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;property-binding&#34;&gt;Property Binding&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把任意 Bean 的 property 與配置文件 (application.properties) 中的 property 綁定&lt;/li&gt;
&lt;li&gt;annotations
&lt;ul&gt;
&lt;li&gt;@ConfigurationProperties
&lt;ul&gt;
&lt;li&gt;prefix&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@EnableConfigurationProperties
&lt;ul&gt;
&lt;li&gt;如果 class 只有 @ConfigurationProperties，沒有 @Component，需要加這個 annotation&lt;/li&gt;
&lt;li&gt;用在第三方 package 上，因為默認掃不到第三方的 @component&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java-json-data-binding&#34;&gt;Java JSON Data Binding&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 Java POJO 和 JSON 之間轉換&lt;/li&gt;
&lt;li&gt;Spring 用 Jackson 來做轉換
&lt;ul&gt;
&lt;li&gt;Jackson 會 call getter, setter 來轉換&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;alias
&lt;ul&gt;
&lt;li&gt;mapping&lt;/li&gt;
&lt;li&gt;marshalling&lt;/li&gt;
&lt;li&gt;serialization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;輔助工具&#34;&gt;輔助工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Spring boot devtools
&lt;ul&gt;
&lt;li&gt;Hot reload&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spring Boot Actuator
&lt;ul&gt;
&lt;li&gt;公開用來 monitor 的 endpoint&lt;/li&gt;
&lt;li&gt;endpoints
&lt;ul&gt;
&lt;li&gt;都有固定前綴 /actuator&lt;/li&gt;
&lt;li&gt;/health
&lt;ul&gt;
&lt;li&gt;查看應用程式的 status&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;/info
&lt;ul&gt;
&lt;li&gt;查看應用程式的 info&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;/beans
&lt;ul&gt;
&lt;li&gt;查看所有 bean&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;logging&#34;&gt;Logging&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Logging 選擇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logging API
&lt;ul&gt;
&lt;li&gt;JCL&lt;/li&gt;
&lt;li&gt;SLF4J (Simple Logging Facade for Java)&lt;/li&gt;
&lt;li&gt;jboss-logging&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Logging implementation
&lt;ul&gt;
&lt;li&gt;Logback&lt;/li&gt;
&lt;li&gt;Log4j2&lt;/li&gt;
&lt;li&gt;JUL (java.util.logging)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spring Boot 預設使用 Logback 和 SLF4J&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;spring-boot-starter 引用了 spring-boot-starter-logging&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;log-format&#34;&gt;Log Format&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Default example
&lt;ul&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2024-05-06T19:21:40.751+08:00  INFO 22932 --- [demo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path &amp;#39;&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;時間, 日誌等級, pid, 分割符, thread, logger, message&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;log-level&#34;&gt;Log Level&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Type (由低到高)
&lt;ul&gt;
&lt;li&gt;ALL&lt;/li&gt;
&lt;li&gt;TRACE
&lt;ul&gt;
&lt;li&gt;一般不用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DEBUG&lt;/li&gt;
&lt;li&gt;INFO&lt;/li&gt;
&lt;li&gt;WARN&lt;/li&gt;
&lt;li&gt;ERROR&lt;/li&gt;
&lt;li&gt;FATAL&lt;/li&gt;
&lt;li&gt;OFF&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;會 print 出比設定的等級高的 log&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;log-configuration&#34;&gt;Log Configuration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;logging.level.*&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;設定不同 package 的 log 等級&lt;/li&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;logging.level.com.example=DEBUG
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;logging.group.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把多個 package 放在一組，可以統一設定&lt;/li&gt;
&lt;li&gt;預設有 web, sql 組&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;logging.file&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.name
&lt;ul&gt;
&lt;li&gt;檔名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;歸檔 and 切割&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;歸檔
&lt;ul&gt;
&lt;li&gt;每天單獨存&lt;/li&gt;
&lt;li&gt;.logback.rolllingpolicy.file-name-pattern&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;切割
&lt;ul&gt;
&lt;li&gt;超過指定大小就切割&lt;/li&gt;
&lt;li&gt;.logback.rolllingpolicy.max-file-size&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;filter&#34;&gt;Filter&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;實做 javax.servlet.Filter，就能註冊為 spring 的 filter&lt;/li&gt;
&lt;li&gt;OncePerRequestFilter
&lt;ul&gt;
&lt;li&gt;保證一次 request 只會執行一次&lt;/li&gt;
&lt;li&gt;doFilterInternal
&lt;ul&gt;
&lt;li&gt;chain.doFilter(request, response)
&lt;ul&gt;
&lt;li&gt;這行之後代表後面的 filter 都執行完了&lt;/li&gt;
&lt;li&gt;如果只有一個 filter，就代表 controller 執行完了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;shouldNotFilter
&lt;ul&gt;
&lt;li&gt;可以設定不要執行的 url pattern&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;註冊-filter&#34;&gt;註冊 Filter&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;設定 @Configuration&lt;/li&gt;
&lt;li&gt;加到 Bean
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; setUrlPatterns
&lt;ul&gt;
&lt;li&gt;只有符合 url pattern 的 request 才會經過這個 filter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; setOrder
&lt;ul&gt;
&lt;li&gt;決定 filter 的順序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 filter 要取得 request 和 response 的內容，可以用 ContentCachingRequestWrapper 和 ContentCachingResponseWrapper 重新包裝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為原本的作法是用 stream 讀取資料，只能讀一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@WebFilter&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;屬於 Java servlet 而非 Spring
&lt;ul&gt;
&lt;li&gt;要在 application 補上 @ServletComponentScan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以直接註冊 filter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spring-security&#34;&gt;Spring Security&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;名詞
&lt;ul&gt;
&lt;li&gt;Authentication
&lt;ul&gt;
&lt;li&gt;認證
&lt;ul&gt;
&lt;li&gt;檢查是不是系統的使用者，以及是哪個使用者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Authorization
&lt;ul&gt;
&lt;li&gt;授權
&lt;ul&gt;
&lt;li&gt;檢查使用者有沒有權限做某件事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;filter chain&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example
&lt;ul&gt;
&lt;li&gt;UsernamePasswordAuthenticationFilter
&lt;ul&gt;
&lt;li&gt;檢查使用者名稱和密碼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ExceptionTranslationFilter
&lt;ul&gt;
&lt;li&gt;處理例外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FilterSecurityInterceptor
&lt;ul&gt;
&lt;li&gt;檢查授權&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;authorizeHttpRequests
&lt;ul&gt;
&lt;li&gt;設定哪些 request 需要什麼權限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example: JWT 驗證流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先透過 filter chain 經過 JWT filter&lt;/li&gt;
&lt;li&gt;透過 UserDetailsService 取得使用者資訊&lt;/li&gt;
&lt;li&gt;驗證使用者資訊&lt;/li&gt;
&lt;li&gt;更新 SecurityContextHolder
&lt;ul&gt;
&lt;li&gt;用來判斷使用者是否已經通過 authentication&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;configuration&#34;&gt;Configuration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@EnableWebSecurity
&lt;ul&gt;
&lt;li&gt;啟用 web security&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;example
&lt;ul&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Configuration&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;SecurityConfig&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nd&#34;&gt;@Bean&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SecurityFilterChain&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;securityFilterChain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HttpSecurity&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;authorizeHttpRequests&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;requests&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AuthorizeHttpRequestsConfigurer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;AuthorizedUrl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;requests&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;anyRequest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;authenticated&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;httpBasic&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Customizer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;withDefaults&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SecurityFilterChain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;把 Spring Boot 預設實作的 fitler chain 的 @Order 拿掉，這是決定誰的優先序高&lt;/li&gt;
&lt;li&gt;也把 formLogin 拿掉，就不會有登入頁面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;userdetails&#34;&gt;UserDetails&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;實現 UserDetailsService 的 Bean 可以被用來取得 UserDetails&lt;/li&gt;
&lt;li&gt;implements UserDetails
&lt;ul&gt;
&lt;li&gt;getAuthorities&lt;/li&gt;
&lt;li&gt;getUsername&lt;/li&gt;
&lt;li&gt;getPassword&lt;/li&gt;
&lt;li&gt;isAccountNonExpired&lt;/li&gt;
&lt;li&gt;isAccountNonLocked&lt;/li&gt;
&lt;li&gt;isCredentialsNonExpired&lt;/li&gt;
&lt;li&gt;isEnabled&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;securitycontextholder&#34;&gt;SecurityContextHolder&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用來存放 authentication&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;commandlinerunner&#34;&gt;CommandLineRunner&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用來在 Spring Boot 啟動後執行一些任務&lt;/li&gt;
&lt;li&gt;會在所有 bean 創建完後執行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jpa&#34;&gt;JPA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Jakarta Persistence API&lt;/li&gt;
&lt;li&gt;以前叫 Java Persistence API&lt;/li&gt;
&lt;li&gt;只是一個 specifcation，提供一組 interface，需要實作
&lt;ul&gt;
&lt;li&gt;包含了 Entity, EntityManager, Query, Transaction..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DataSource
&lt;ul&gt;
&lt;li&gt;用來連接資料庫&lt;/li&gt;
&lt;li&gt;定義了連接資料庫的 info&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EntityManager
&lt;ul&gt;
&lt;li&gt;用來創建 query 的主要 component&lt;/li&gt;
&lt;li&gt;需要 DataSource&lt;/li&gt;
&lt;li&gt;EntityManager vs JpaRepositroy
&lt;ul&gt;
&lt;li&gt;EntityManager
&lt;ul&gt;
&lt;li&gt;low-level control and flexibility&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JpaRepository
&lt;ul&gt;
&lt;li&gt;high-level abstraction&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JPQL
&lt;ul&gt;
&lt;li&gt;基於 Entity name 和 fields 的 query language&lt;/li&gt;
&lt;li&gt;不是基於資料庫的 column 或 table name，是基於 Entity 的名字，要注意區別&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data access object (DAO)
&lt;ul&gt;
&lt;li&gt;common pattern&lt;/li&gt;
&lt;li&gt;需要 JPA Entity Manager&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Config
&lt;ul&gt;
&lt;li&gt;spring.jpa.hibernate.ddl-auto
&lt;ul&gt;
&lt;li&gt;create
&lt;ul&gt;
&lt;li&gt;每次都會重新創建新的 table&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;update
&lt;ul&gt;
&lt;li&gt;只會更新 table，不會刪除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;create-drop
&lt;ul&gt;
&lt;li&gt;創建 table，然後刪除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;validate
&lt;ul&gt;
&lt;li&gt;只會檢查 table 是否存在，不會創建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Annotation
&lt;ul&gt;
&lt;li&gt;@Entity, @Table
&lt;ul&gt;
&lt;li&gt;也要記得寫 getter, setter&lt;/li&gt;
&lt;li&gt;@Entity 需要 public 或 protected 的無參數建構子&lt;/li&gt;
&lt;li&gt;@Table
&lt;ul&gt;
&lt;li&gt;可選，可以設定 table 名稱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Transient
&lt;ul&gt;
&lt;li&gt;不會被序列化，不會被存到資料庫&lt;/li&gt;
&lt;li&gt;可用在可以單獨計算的欄位，比如用資料庫的生日可以算出年齡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Transactional
&lt;ul&gt;
&lt;li&gt;用在 method 上，代表這個 method 是一個 transaction&lt;/li&gt;
&lt;li&gt;propagation
&lt;ul&gt;
&lt;li&gt;用在 method 上，被別的 transaction 調用應該怎麼處理，講 transaction 的傳播&lt;/li&gt;
&lt;li&gt;REQUIRED
&lt;ul&gt;
&lt;li&gt;如果有外層 transaction 就用，沒有就創建一個&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;REQUIRES_NEW
&lt;ul&gt;
&lt;li&gt;無論有沒有外層 transaction，都創建一個新的，不受影響&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NESTED
&lt;ul&gt;
&lt;li&gt;嵌套 transaction，如果外層 transaction rollback，內層也會 rollback&lt;/li&gt;
&lt;li&gt;如果自己 rollback，外層不受影響&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Column
&lt;ul&gt;
&lt;li&gt;可以設定欄位名稱&lt;/li&gt;
&lt;li&gt;這是可選的，沒有的話就是用變數名稱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Id
&lt;ul&gt;
&lt;li&gt;Primary key&lt;/li&gt;
&lt;li&gt;@GeneratedValue
&lt;ul&gt;
&lt;li&gt;strategy
&lt;ul&gt;
&lt;li&gt;AUTO
&lt;ul&gt;
&lt;li&gt;根據資料庫自動選擇&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IDENTITY
&lt;ul&gt;
&lt;li&gt;用資料庫的 identity column&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SEQUENCE
&lt;ul&gt;
&lt;li&gt;用資料庫的 sequence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Table
&lt;ul&gt;
&lt;li&gt;用 underlying table 來確保唯一性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UUID
&lt;ul&gt;
&lt;li&gt;用 UUID 來確保唯一性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@OneToMany, @ManyToOne
&lt;ul&gt;
&lt;li&gt;用來設定關聯&lt;/li&gt;
&lt;li&gt;cascade
&lt;ul&gt;
&lt;li&gt;設定當 parent 被刪除時，child 要怎麼處理
&lt;ul&gt;
&lt;li&gt;CascadeType.ALL
&lt;ul&gt;
&lt;li&gt;parent 被刪除時，child 也會被刪除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CascadeType.PERSIST
&lt;ul&gt;
&lt;li&gt;parent 被刪除時，child 不會被刪除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Spring Data JPA
&lt;ul&gt;
&lt;li&gt;用特定語法，只需要定好 interface，不用 implement&lt;/li&gt;
&lt;li&gt;extends JpaRepository&amp;lt;Entity, ID&amp;gt;
&lt;ul&gt;
&lt;li&gt;第一個參數是 entity&lt;/li&gt;
&lt;li&gt;第二個參數是 primary key 的型態&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示範
&lt;ul&gt;
&lt;li&gt;findByXxx
&lt;ul&gt;
&lt;li&gt;用 XXX 的欄位來查詢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;findByXXXLike
&lt;ul&gt;
&lt;li&gt;用 XXX 的欄位來模糊查詢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jparepository&#34;&gt;JpaRepository&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@Repository
&lt;ul&gt;
&lt;li&gt;用來標記 DAO&lt;/li&gt;
&lt;li&gt;extends JpaRepository&amp;lt;Entity, ID&amp;gt;
&lt;ul&gt;
&lt;li&gt;第一個參數是 entity&lt;/li&gt;
&lt;li&gt;第二個參數是 entity 的 id 的型態&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以自定義方法
&lt;ul&gt;
&lt;li&gt;遵循命名規則，他會自己轉 SQL&lt;/li&gt;
&lt;li&gt;也可以用 @Query 來自定義 SQL
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;?0&amp;gt;&lt;/code&gt; 代表第一個參數，以此類推&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hibernate&#34;&gt;Hibernate&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用來儲存 java object 到資料庫的框架&lt;/li&gt;
&lt;li&gt;ORM
&lt;ul&gt;
&lt;li&gt;Object Relational Mapping&lt;/li&gt;
&lt;li&gt;用物件來操作資料庫&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一種 JPA 的實作&lt;/li&gt;
&lt;li&gt;背後用 JDBC 來操作資料庫&lt;/li&gt;
&lt;li&gt;Spring Boot 預設用 Hibernate 來實作 JPA&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;validation&#34;&gt;Validation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;field validation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@NotEmpty&lt;/li&gt;
&lt;li&gt;@Min&lt;/li&gt;
&lt;li&gt;@Max&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@Valid&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用在 controller 上，才會自動檢查參數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;exception&#34;&gt;Exception&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RuntimeException
&lt;ul&gt;
&lt;li&gt;繼承這個，可以設置 status, message, timestamp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@ExceptionHandler
&lt;ul&gt;
&lt;li&gt;放在 Controller 中的 exception handler method 上，可以處理底下 method 丟出的 exception&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@ControllerAdvice
&lt;ul&gt;
&lt;li&gt;類似 interceptor/filter&lt;/li&gt;
&lt;li&gt;可以 pre-process request, post-process response&lt;/li&gt;
&lt;li&gt;可以用在 global exception handler&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;
&lt;h3 id=&#34;integration-test&#34;&gt;Integration Test&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 test class 前面的 annotation
&lt;ul&gt;
&lt;li&gt;@RunWith(SpringRunner.class)&lt;/li&gt;
&lt;li&gt;@SpringBootTest&lt;/li&gt;
&lt;li&gt;@AutoConfigureMockMvc
&lt;ul&gt;
&lt;li&gt;測試開始時會在容器中創建 MockMvc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 test method 前面加的 annotation
&lt;ul&gt;
&lt;li&gt;@Test&lt;/li&gt;
&lt;li&gt;@Before, @After
&lt;ul&gt;
&lt;li&gt;在每個測試前後執行，可以用來清空資料庫和設置 header&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mockmvc&#34;&gt;MockMvc&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用來模擬 HTTP request&lt;/li&gt;
&lt;li&gt;example
&lt;ul&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Autowired&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MockMvc&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mockMvc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;mockMvc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;perform&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;andExpect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isOk&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;andExpect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;h3 id=&#34;lombok&#34;&gt;Lombok&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;@Getter, @Setter
&lt;ul&gt;
&lt;li&gt;生成 getter, setter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@ToString
&lt;ul&gt;
&lt;li&gt;印出所有變數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@EqualsAndHashCode
&lt;ul&gt;
&lt;li&gt;生成 equals, hashCode&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Args
&lt;ul&gt;
&lt;li&gt;@NoArgsConstructor
&lt;ul&gt;
&lt;li&gt;生成無參數建構子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@AllArgsConstructor
&lt;ul&gt;
&lt;li&gt;生成所有參數建構子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@RequiredArgsConstructor
&lt;ul&gt;
&lt;li&gt;只幫 final 變數生成建構子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Data
&lt;ul&gt;
&lt;li&gt;同時用 @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Value
&lt;ul&gt;
&lt;li&gt;把所有變數都設成 final&lt;/li&gt;
&lt;li&gt;同時用 @Getter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor&lt;/li&gt;
&lt;li&gt;和 Spring boot 的 @Value 撞名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Builder
&lt;ul&gt;
&lt;li&gt;生成 builder pattern&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@Slf4j
&lt;ul&gt;
&lt;li&gt;生成 log 變數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jackson&#34;&gt;Jackson&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ObjectMapper
&lt;ul&gt;
&lt;li&gt;用來轉換物件和 JSON&lt;/li&gt;
&lt;li&gt;readValue
&lt;ul&gt;
&lt;li&gt;把 JSON 轉成物件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用 getter, setter 來判斷欄位&lt;/li&gt;
&lt;li&gt;Annotation
&lt;ul&gt;
&lt;li&gt;@JsonIgnore
&lt;ul&gt;
&lt;li&gt;不轉換&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@JsonProperty
&lt;ul&gt;
&lt;li&gt;指定欄位名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@JsonUnwrapped
&lt;ul&gt;
&lt;li&gt;把物件的欄位展開，從巢狀變成平面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@JsonInclude
&lt;ul&gt;
&lt;li&gt;設定要不要轉換 null&lt;/li&gt;
&lt;li&gt;如果設定為 Include.NON_NULL，給 null 的話，就不會轉換&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@JsonFormat
&lt;ul&gt;
&lt;li&gt;設定日期格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>GraphQL 簡介</title>
        <link>https://roykesydon.github.io/Blog/p/graphql-%E7%B0%A1%E4%BB%8B/</link>
        <pubDate>Tue, 22 Aug 2023 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/graphql-%E7%B0%A1%E4%BB%8B/</guid>
        <description>&lt;h2 id=&#34;簡介&#34;&gt;簡介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Meta 在 2015 年公開的 API Query Language&lt;/li&gt;
&lt;li&gt;常被用來和傳統的 REST API 比較，具備查詢更加靈活等特性&lt;/li&gt;
&lt;li&gt;有在使用的公司
&lt;ul&gt;
&lt;li&gt;Facebook&lt;/li&gt;
&lt;li&gt;GitHub&lt;/li&gt;
&lt;li&gt;Twitter&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;和-rest-api-的主要差別&#34;&gt;和 REST API 的主要差別&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Single Endpoint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和 REST API 對於不同 resource 需要不同 endpoint 不同，GraphQL 對於所有 resource 都是從同一個 endpoint 進行存取&lt;/li&gt;
&lt;li&gt;但 GraphQL 不能輕易地用 HTTP caching，因為現在只剩一種 URL 了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解決 Under-fetching 和 Over-fetching 問題&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Under-fetching&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一個 API call 沒辦法取得所有想要的資料，需要多次 API call&lt;/li&gt;
&lt;li&gt;假如要用 RESTful API 取得一個文章的作者，可能得先取得文章，再取得作者，這樣就需要兩次 API call
&lt;ul&gt;
&lt;li&gt;但 GraphQL 可以在一次 API call 中取得文章和作者，透過 nested query&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Over-fetching&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一個 API call 取得的資料比想要的還多，造成資源浪費&lt;/li&gt;
&lt;li&gt;GraphQL 可以透過 query 定義只想取得的欄位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;和 RESTful API 不同，需要特別架個 GraphQL server，可以考慮用 Apollo Server&lt;/p&gt;
&lt;p&gt;要定義不同 Data type 的 schema、relationship，以及寫對應不同 query 的 resolver&lt;/p&gt;
&lt;h3 id=&#34;query&#34;&gt;Query&lt;/h3&gt;
&lt;p&gt;可能會是長這樣的東西&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-graphql&#34; data-lang=&#34;graphql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;postQuery&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;ID&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;!)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;py&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;author&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;mutation&#34;&gt;Mutation&lt;/h3&gt;
&lt;p&gt;新增、修改、刪除資料都屬於這塊&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-graphql&#34; data-lang=&#34;graphql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;addPost&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$post&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;AddPostInput&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;!)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;addPost&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;py&#34;&gt;post&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$post&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;author&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;py&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>Redis</title>
        <link>https://roykesydon.github.io/Blog/p/redis/</link>
        <pubDate>Mon, 05 Jun 2023 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/redis/</guid>
        <description>&lt;h2 id=&#34;use-cases&#34;&gt;Use Cases&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Cache
&lt;ul&gt;
&lt;li&gt;把常用的資料回傳，省略長時間的 IO 操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Shared Session
&lt;ul&gt;
&lt;li&gt;在 stateless server 間共享 session&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Distributed lock
&lt;ul&gt;
&lt;li&gt;用在程式間想共用某種資源的時候&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;setnx&lt;/code&gt; (set if not exists)
&lt;ul&gt;
&lt;li&gt;atomic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rate Limiter
&lt;ul&gt;
&lt;li&gt;用 increment 和 expiration 實現&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;快取常見策略&#34;&gt;快取常見策略&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cache aside
&lt;ul&gt;
&lt;li&gt;先問 cache，沒有的話再問 db，並把 db 回傳的資料放到 cache&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;read through
&lt;ul&gt;
&lt;li&gt;client 只能存取到 cache，如果沒資料，cache 會去 db 拿資料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;write through
&lt;ul&gt;
&lt;li&gt;client 寫資料時，cache 會留一份資料，並把資料寫到 db&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;write behind
&lt;ul&gt;
&lt;li&gt;和 write through 很像，但是不會立即寫到 db，會等到有更多的資料時，才一次寫到 db&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;feature&#34;&gt;Feature&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NoSQL&lt;/li&gt;
&lt;li&gt;In-memory&lt;/li&gt;
&lt;li&gt;Key-Value&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;basic-command&#34;&gt;Basic Command&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;redis-server&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;default port: 6379&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-cli&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;access-data&#34;&gt;Access data&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;set &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pretty much everything stored in Redis is going to be a type of string by default&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;get &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;del &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exists &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;keys &amp;lt;pattern&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find keys with certain pattern&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keys *&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;get all keys&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flushall&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get rid of everything&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;expiration&#34;&gt;Expiration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ttl &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;show time to live
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;-1&amp;rdquo; for no expiration&lt;/li&gt;
&lt;li&gt;&amp;ldquo;-2&amp;rdquo; already expired&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;expire &amp;lt;key&amp;gt; &amp;lt;second&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;setex &amp;lt;key&amp;gt; &amp;lt;seconds&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set with expiration&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-structure&#34;&gt;Data Structure&lt;/h3&gt;
&lt;h4 id=&#34;list&#34;&gt;List&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lpush/rpush &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lrange &amp;lt;key&amp;gt; &amp;lt;start index&amp;gt; &amp;lt;end index&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;end index&amp;gt;&lt;/code&gt; can be -1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lpop/rpop &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;set&#34;&gt;Set&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sadd &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smembers &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;srem &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;hash&#34;&gt;Hash&lt;/h4&gt;
&lt;p&gt;Key-value in Key-value&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hset &amp;lt;key&amp;gt; &amp;lt;field&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hget &amp;lt;key&amp;gt; &amp;lt;field&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hgetall &amp;lt;key&amp;gt;&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;get everything about &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hdel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexists &amp;lt;key&amp;gt; &amp;lt;field&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Redis doesn&amp;rsquo;t support nested hash struct&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;刪除過期-key&#34;&gt;刪除過期 key&lt;/h2&gt;
&lt;h3 id=&#34;定期刪除&#34;&gt;定期刪除&lt;/h3&gt;
&lt;p&gt;在固定間隔時間隨機抽 key 檢查並刪除&lt;/p&gt;
&lt;h3 id=&#34;惰性刪除&#34;&gt;惰性刪除&lt;/h3&gt;
&lt;p&gt;在訪問 key 的時候發現過期就刪除&lt;/p&gt;
&lt;h2 id=&#34;maxmemory-policy-eviction&#34;&gt;maxmemory-policy (Eviction)&lt;/h2&gt;
&lt;p&gt;可以設定這些 policy，在記憶體依然額滿的情況下做對應的處理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;noeviction&lt;/li&gt;
&lt;li&gt;allkeys-lru&lt;/li&gt;
&lt;li&gt;allkeys-lfu&lt;/li&gt;
&lt;li&gt;volatile-lru&lt;/li&gt;
&lt;li&gt;volatile-lfu&lt;/li&gt;
&lt;li&gt;allkeys-random&lt;/li&gt;
&lt;li&gt;volatile-random&lt;/li&gt;
&lt;li&gt;volatile-ttl&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快取情境問題&#34;&gt;快取情境問題&lt;/h2&gt;
&lt;h3 id=&#34;快取雪崩-cache-avalanche&#34;&gt;快取雪崩 Cache Avalanche&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;某個時刻大量 cache 失效，使資料庫需要承擔很大的流量。&lt;/li&gt;
&lt;li&gt;解法
&lt;ul&gt;
&lt;li&gt;幫 cache 加上額外的隨機過期時間&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;快取擊穿-hotspot-invalid&#34;&gt;快取擊穿 Hotspot Invalid&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;某個 hotspot 的 cache 失效，使大量請求跑到資料庫&lt;/li&gt;
&lt;li&gt;解法
&lt;ul&gt;
&lt;li&gt;讓 hotspot 永不過期&lt;/li&gt;
&lt;li&gt;查詢資料庫的部分加上 lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;快取穿透-cache-penetration&#34;&gt;快取穿透 Cache Penetration&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;client request 不存在的資料，因為同時不存在於 cache 和資料庫中，所以直接跑到資料庫&lt;/li&gt;
&lt;li&gt;解法
&lt;ul&gt;
&lt;li&gt;在 application 先過濾掉非法請求&lt;/li&gt;
&lt;li&gt;Bloom Filter 布隆過濾器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;persistence&#34;&gt;Persistence&lt;/h2&gt;
&lt;h3 id=&#34;rdb&#34;&gt;RDB&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;固定時間對所有資料做快照，memory dump 出來&lt;/li&gt;
&lt;li&gt;recovery 比 AOF 快&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save&lt;/code&gt;、&lt;code&gt;bgsave&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aof&#34;&gt;AOF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;紀錄操作流程&lt;/li&gt;
&lt;li&gt;檔案比較肥&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rewrite&#34;&gt;Rewrite&lt;/h4&gt;
&lt;p&gt;當 AOF 太大，Redis 會生一個新文件取代舊的，用最少操作生出目前的資料&lt;/p&gt;
&lt;h3 id=&#34;混合&#34;&gt;混合&lt;/h3&gt;
&lt;p&gt;在 AOF 重寫的時候也利用 RDB
前面是 RDB，後面是 AOF&lt;/p&gt;
&lt;h2 id=&#34;availability&#34;&gt;Availability&lt;/h2&gt;
&lt;h3 id=&#34;主從同步&#34;&gt;主從同步&lt;/h3&gt;
&lt;p&gt;一主多從，把讀取壓力分擔到 slave 上&lt;/p&gt;
&lt;h3 id=&#34;哨兵模式-sentinel&#34;&gt;哨兵模式 Sentinel&lt;/h3&gt;
&lt;p&gt;會有哨兵不斷地 Ping 主從伺服器，確認是否有異常&lt;/p&gt;
&lt;p&gt;如果哨兵是集群，有哨兵檢測到異常，會判斷某伺服器主觀下線，當有一定數量的哨兵投票認為伺服器不可能用，就會變成客觀下線，進行 failover&lt;/p&gt;
&lt;h3 id=&#34;cluster&#34;&gt;Cluster&lt;/h3&gt;
&lt;p&gt;分擔寫入壓力&lt;/p&gt;
&lt;p&gt;Redis 有 16384 個 slot，透過 hash 分配 key 到不同的 slot&lt;/p&gt;
&lt;p&gt;預設會另外用 port 16379 來讓節點間溝通&lt;/p&gt;
&lt;p&gt;可以混和主從同步達到高可用&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
