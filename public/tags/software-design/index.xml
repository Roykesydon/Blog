<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>software-design on Roykesydon</title>
        <link>https://roykesydon.github.io/Blog/tags/software-design/</link>
        <description>Recent content in software-design on Roykesydon</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 27 Jun 2024 02:00:17 +0800</lastBuildDate><atom:link href="https://roykesydon.github.io/Blog/tags/software-design/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Software Development Model</title>
        <link>https://roykesydon.github.io/Blog/p/software-development-model/</link>
        <pubDate>Thu, 27 Jun 2024 02:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/software-development-model/</guid>
        <description>&lt;h2 id=&#34;terms&#34;&gt;Terms&lt;/h2&gt;
&lt;h3 id=&#34;incremental-vs-iterative&#34;&gt;Incremental vs Iterative&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Incremental
&lt;ul&gt;
&lt;li&gt;隨時間一步一步完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Iterative
&lt;ul&gt;
&lt;li&gt;建立 prototype，然後不斷改進&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;model-type&#34;&gt;Model type&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linear/Predictive
&lt;ul&gt;
&lt;li&gt;有類似的專案經驗&lt;/li&gt;
&lt;li&gt;有明確的流程&lt;/li&gt;
&lt;li&gt;沒什麼可以改動的空間&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Flexible/Adaptive
&lt;ul&gt;
&lt;li&gt;專案屬於 new idea&lt;/li&gt;
&lt;li&gt;專案很有可能隨時間改變&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;waterfall-model&#34;&gt;Waterfall Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;像瀑布一樣，一個階段完成後才能進行下一個階段&lt;/li&gt;
&lt;li&gt;Requirement -&amp;gt; Design -&amp;gt; Implementation -&amp;gt; Testing -&amp;gt; Deployment -&amp;gt; Maintenance&lt;/li&gt;
&lt;li&gt;非常 predictive，沒有彈性&lt;/li&gt;
&lt;li&gt;如果在 Testing 發現重大問題，可能要從 Requirement 重新開始&lt;/li&gt;
&lt;li&gt;隨著進度推進，fix 成本增長很快&lt;/li&gt;
&lt;li&gt;每一步都得考慮周密&lt;/li&gt;
&lt;li&gt;用戶很晚才能看到結果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;v-model&#34;&gt;V-Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基於 Waterfall Model 的改進&lt;/li&gt;
&lt;li&gt;V 的左半邊
&lt;ul&gt;
&lt;li&gt;Requirement -&amp;gt; Design -&amp;gt; Architecture -&amp;gt; Module -&amp;gt; Implementation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;V 的右半邊
&lt;ul&gt;
&lt;li&gt;Unit Testing -&amp;gt; Integration Testing -&amp;gt; System Testing -&amp;gt; Acceptance Testing&lt;/li&gt;
&lt;li&gt;四個 testing 和左半邊的四個階段一一對應&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;強調開發和測試並行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sashimi-model&#34;&gt;Sashimi Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在大公司，不同 phase 常常有專人負責&lt;/li&gt;
&lt;li&gt;前面瀑布式開發，會讓後面 phase 的人閒置&lt;/li&gt;
&lt;li&gt;讓不同 phase 的人在某些時間點同時工作&lt;/li&gt;
&lt;li&gt;可能會導致錯誤還有 redesign&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;incremental-model&#34;&gt;Incremental Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在整個開發過程中多次完成軟體開發過程&lt;/li&gt;
&lt;li&gt;每個子開發過程都有明確的目標&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unified-process-framework&#34;&gt;Unified Process Framework&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Phase
&lt;ul&gt;
&lt;li&gt;Inception
&lt;ul&gt;
&lt;li&gt;確定可行性&lt;/li&gt;
&lt;li&gt;Deliverable
&lt;ul&gt;
&lt;li&gt;Lifecycle goals&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Elaboration
&lt;ul&gt;
&lt;li&gt;細化階段&lt;/li&gt;
&lt;li&gt;Deliverable
&lt;ul&gt;
&lt;li&gt;Software architecture plans &amp;amp; prototypes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Construction
&lt;ul&gt;
&lt;li&gt;基於 elaboration 階段的基礎改進&lt;/li&gt;
&lt;li&gt;用多個 iteration 來完成&lt;/li&gt;
&lt;li&gt;Deliverable
&lt;ul&gt;
&lt;li&gt;持續改進軟體&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Transition
&lt;ul&gt;
&lt;li&gt;交付系統&lt;/li&gt;
&lt;li&gt;Deliverable
&lt;ul&gt;
&lt;li&gt;Final Product&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;優點
&lt;ul&gt;
&lt;li&gt;Adaptive&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺點
&lt;ul&gt;
&lt;li&gt;複雜&lt;/li&gt;
&lt;li&gt;對小專案來說太過頭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spiral-model&#34;&gt;Spiral Model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;4 個象限
&lt;ul&gt;
&lt;li&gt;Determine objectives&lt;/li&gt;
&lt;li&gt;Identify and resolve risks&lt;/li&gt;
&lt;li&gt;Developments and test&lt;/li&gt;
&lt;li&gt;Plan the next iteration&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 4 個階段不斷輪替&lt;/li&gt;
&lt;li&gt;優點
&lt;ul&gt;
&lt;li&gt;adaptive&lt;/li&gt;
&lt;li&gt;risk-focused&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺點
&lt;ul&gt;
&lt;li&gt;複雜&lt;/li&gt;
&lt;li&gt;需要 stackholder 持續參與&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;agile&#34;&gt;Agile&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一種思維方法，不是模型&lt;/li&gt;
&lt;li&gt;Manifesto
&lt;ul&gt;
&lt;li&gt;Individuals and interactions over processes and tools
&lt;ul&gt;
&lt;li&gt;如果一組人決定要用一組新的工具，那他們應該有更高的優先權&lt;/li&gt;
&lt;li&gt;過往的做法可能偏向使用過的工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Working software over comprehensive documentation
&lt;ul&gt;
&lt;li&gt;document 很重要，但是只有大量的 document 沒辦法讓客戶給出反饋&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Customer collaboration over contract negotiation
&lt;ul&gt;
&lt;li&gt;強調和客戶的合作，而不是只在意合同上的項目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Responding to change over following a plan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;瀑布式開發的缺點
&lt;ul&gt;
&lt;li&gt;現在的技術環境變化太快，Agile 希望在開發過程中能夠快速適應
&lt;ul&gt;
&lt;li&gt;傳統的開發方法考量到金錢損失，不太可能辦到。但透過小的 increment，可以在每個 increment 中朝正確的方向前進&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;軟體系統不可能被 100% 預測&lt;/li&gt;
&lt;li&gt;系統可能不符合用戶要求&lt;/li&gt;
&lt;li&gt;市場變化很快，Agile 可以在短時間內推出最小可行產品，先行推向市場&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kanban&#34;&gt;Kanban&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;會存在多張卡片&lt;/li&gt;
&lt;li&gt;可以直觀看到某個欄位是否堆積大量工作&lt;/li&gt;
&lt;li&gt;Properties
&lt;ul&gt;
&lt;li&gt;Visualize workflow&lt;/li&gt;
&lt;li&gt;Limit work in progress&lt;/li&gt;
&lt;li&gt;Manage flow&lt;/li&gt;
&lt;li&gt;Make process policies explicit&lt;/li&gt;
&lt;li&gt;Improve collaboratively&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Principles
&lt;ul&gt;
&lt;li&gt;Start with what you do now&lt;/li&gt;
&lt;li&gt;Agree to pursue incremental, evolutionary change
&lt;ul&gt;
&lt;li&gt;並非試著立刻改變所有事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Respect the current process, roles, responsibilities &amp;amp; titles&lt;/li&gt;
&lt;li&gt;Encourage acts of leadership at all levels
&lt;ul&gt;
&lt;li&gt;這裡的 leadership 不一定指領導他人，也可以是激勵他人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;欄位
&lt;ul&gt;
&lt;li&gt;Backlog&lt;/li&gt;
&lt;li&gt;Analyze&lt;/li&gt;
&lt;li&gt;Develop&lt;/li&gt;
&lt;li&gt;Test&lt;/li&gt;
&lt;li&gt;Release&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lean-startup&#34;&gt;Lean Startup&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;實驗性的生產方法&lt;/li&gt;
&lt;li&gt;盡快生出產品，看看市場反應&lt;/li&gt;
&lt;li&gt;loop step
&lt;ul&gt;
&lt;li&gt;learn
&lt;ul&gt;
&lt;li&gt;assumption&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;build
&lt;ul&gt;
&lt;li&gt;experiment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;measure
&lt;ul&gt;
&lt;li&gt;metrics&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;example:
&lt;ul&gt;
&lt;li&gt;zappos
&lt;ul&gt;
&lt;li&gt;假設人們會上網買鞋&lt;/li&gt;
&lt;li&gt;拍鞋子照片，建立網站丟上去&lt;/li&gt;
&lt;li&gt;看有多少人會買&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;scrum&#34;&gt;Scrum&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以利用 back-to-back testing 來確認沒有弄壞之前 sprint 的功能&lt;/li&gt;
&lt;li&gt;roles
&lt;ul&gt;
&lt;li&gt;Product Owner
&lt;ul&gt;
&lt;li&gt;決定要用什麼方式完成什麼事&lt;/li&gt;
&lt;li&gt;與外部世界溝通的人，和利害關係人溝通&lt;/li&gt;
&lt;li&gt;目標
&lt;ul&gt;
&lt;li&gt;最大化產品價值
&lt;ul&gt;
&lt;li&gt;價低成本、提高收益&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;職責
&lt;ul&gt;
&lt;li&gt;維護 open, healthy product backlog&lt;/li&gt;
&lt;li&gt;回答產品相關問題&lt;/li&gt;
&lt;li&gt;管理預算、release schedule&lt;/li&gt;
&lt;li&gt;確保團隊價值，找出問題&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scrum Master
&lt;ul&gt;
&lt;li&gt;確保團隊遵守 Scrum 的規則，促成會議、解決衝突&lt;/li&gt;
&lt;li&gt;Servant Leader
&lt;ul&gt;
&lt;li&gt;有一點領導，但和大家平等。促成團隊工作而不是指揮別人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目標
&lt;ul&gt;
&lt;li&gt;促成 Daily Standup&lt;/li&gt;
&lt;li&gt;移除障礙&lt;/li&gt;
&lt;li&gt;確保大家的心情&lt;/li&gt;
&lt;li&gt;確保 Scurm values&lt;/li&gt;
&lt;li&gt;團隊的調解人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dev Team
&lt;ul&gt;
&lt;li&gt;包含工程師、設計師等等&lt;/li&gt;
&lt;li&gt;目標
&lt;ul&gt;
&lt;li&gt;和 Product Owner 合作，create user stories&lt;/li&gt;
&lt;li&gt;寫 code 和測試，確保符合預期&lt;/li&gt;
&lt;li&gt;research, design, prototype&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;流程
&lt;ul&gt;
&lt;li&gt;product backlog
&lt;ul&gt;
&lt;li&gt;待完成的事情&lt;/li&gt;
&lt;li&gt;可能的欄位
&lt;ul&gt;
&lt;li&gt;優先度&lt;/li&gt;
&lt;li&gt;預計花費時間&lt;/li&gt;
&lt;li&gt;誰來執行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;spring planning meeting
&lt;ul&gt;
&lt;li&gt;決定要在這個 sprint 完成的事情&lt;/li&gt;
&lt;li&gt;時間點會是 sprint 的第一天&lt;/li&gt;
&lt;li&gt;目標
&lt;ul&gt;
&lt;li&gt;把 product backlog 轉換成 sprint backlog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;職責
&lt;ul&gt;
&lt;li&gt;Scrum Master
&lt;ul&gt;
&lt;li&gt;促成會議&lt;/li&gt;
&lt;li&gt;確保和準備會議地點&lt;/li&gt;
&lt;li&gt;確保會議有在持續推進，好達成 timebox
&lt;ul&gt;
&lt;li&gt;如果有講太久的部分，可能稍後再排單獨會議&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;確保一切都和 sprint goal 一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Product Owner
&lt;ul&gt;
&lt;li&gt;準備好 product backlog&lt;/li&gt;
&lt;li&gt;澄清 product backlog 的細節&lt;/li&gt;
&lt;li&gt;要準備好描述 acceptance criteria
&lt;ul&gt;
&lt;li&gt;比如搜索速度要多快？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dev Team
&lt;ul&gt;
&lt;li&gt;協助判斷哪些任務可達成且符合 sprint goal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sprint backlog
&lt;ul&gt;
&lt;li&gt;這個 sprint 要完成的事情&lt;/li&gt;
&lt;li&gt;開發人員去自己選擇要做的事情&lt;/li&gt;
&lt;li&gt;然後就會花 1-4 週完成一個 sprint&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Daily Scrum (Daily standup)
&lt;ul&gt;
&lt;li&gt;不該花太久，比如最多 15 分鐘&lt;/li&gt;
&lt;li&gt;職責
&lt;ul&gt;
&lt;li&gt;Scrum Master
&lt;ul&gt;
&lt;li&gt;確保會議的進行，確保 timebox&lt;/li&gt;
&lt;li&gt;紀錄關於目前障礙的筆記，規劃時間移除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dev Team
&lt;ul&gt;
&lt;li&gt;回答問題
&lt;ul&gt;
&lt;li&gt;做了什麼&lt;/li&gt;
&lt;li&gt;計畫做什麼&lt;/li&gt;
&lt;li&gt;遇到什麼問題&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sprint review
&lt;ul&gt;
&lt;li&gt;找 stakeholders 來看看這個 sprint 的成果&lt;/li&gt;
&lt;li&gt;秀出 product increment
&lt;ul&gt;
&lt;li&gt;product increment 意味著他本身就是一個完成的產品，經過測試且準備 release&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任務
&lt;ul&gt;
&lt;li&gt;review sprint result
&lt;ul&gt;
&lt;li&gt;回顧那些任務做得好和不好
&lt;ul&gt;
&lt;li&gt;如果有事情沒完成，要解釋為什麼推遲&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;這個 sprint 有沒有達到目標&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Discuss and demonstrate work
&lt;ul&gt;
&lt;li&gt;product owner 全程記錄筆記&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Update status of the project&lt;/li&gt;
&lt;li&gt;Collaborate on the plan ahead&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sprint retrospective
&lt;ul&gt;
&lt;li&gt;團隊討論這個 sprint 的問題，並且改進&lt;/li&gt;
&lt;li&gt;常見方法
&lt;ul&gt;
&lt;li&gt;start-stop-continue
&lt;ul&gt;
&lt;li&gt;每個人說出一個想開始做的事情，一個想停止做的事情，一個想繼續做的事情&lt;/li&gt;
&lt;li&gt;可以保持匿名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-5-3-structure&#34;&gt;3-5-3 Structure&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;3 artifacts
&lt;ul&gt;
&lt;li&gt;Sprint Backlog&lt;/li&gt;
&lt;li&gt;Product Backlog&lt;/li&gt;
&lt;li&gt;Product Increment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5 events
&lt;ul&gt;
&lt;li&gt;Sprint Planning&lt;/li&gt;
&lt;li&gt;Daily Scrum&lt;/li&gt;
&lt;li&gt;The Sprint&lt;/li&gt;
&lt;li&gt;Sprint Review&lt;/li&gt;
&lt;li&gt;Sprint Retrospective&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3 roles
&lt;ul&gt;
&lt;li&gt;Product Owner&lt;/li&gt;
&lt;li&gt;Scrum Master&lt;/li&gt;
&lt;li&gt;Dev Team&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以再加上
&lt;ul&gt;
&lt;li&gt;5 values
&lt;ul&gt;
&lt;li&gt;Focus&lt;/li&gt;
&lt;li&gt;Respect&lt;/li&gt;
&lt;li&gt;Commitment&lt;/li&gt;
&lt;li&gt;Courage&lt;/li&gt;
&lt;li&gt;Openness&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3 pillars
&lt;ul&gt;
&lt;li&gt;Transparency&lt;/li&gt;
&lt;li&gt;Inspection&lt;/li&gt;
&lt;li&gt;Adaptation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Testing</title>
        <link>https://roykesydon.github.io/Blog/p/testing/</link>
        <pubDate>Thu, 27 Jun 2024 00:01:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/testing/</guid>
        <description>&lt;h2 id=&#34;通用術語&#34;&gt;通用術語&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Test data
&lt;ul&gt;
&lt;li&gt;用來測試系統的輸入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Test case&lt;/li&gt;
&lt;li&gt;Oracle
&lt;ul&gt;
&lt;li&gt;理想的結果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bug
&lt;ul&gt;
&lt;li&gt;error 或是偏離預期的行為&lt;/li&gt;
&lt;li&gt;用詞
&lt;ul&gt;
&lt;li&gt;failure
&lt;ul&gt;
&lt;li&gt;偏離預期的 event&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;error
&lt;ul&gt;
&lt;li&gt;導致 failure 的 code part&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;fault
&lt;ul&gt;
&lt;li&gt;outcome&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;verification-and-validation&#34;&gt;Verification and Validation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Verification
&lt;ul&gt;
&lt;li&gt;確認系統是否符合 specifcation&lt;/li&gt;
&lt;li&gt;build the system right&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Validation
&lt;ul&gt;
&lt;li&gt;確認系統是否符合使用者需求&lt;/li&gt;
&lt;li&gt;build the right system&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unit-testing&#34;&gt;Unit Testing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;專注在測試 smallest unit of software&lt;/li&gt;
&lt;li&gt;要 isolate unit，避免其他 unit 影響測試結果
&lt;ul&gt;
&lt;li&gt;用 dummy value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;integration-testing&#34;&gt;Integration Testing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;專注在測試 communication 和 architecture&lt;/li&gt;
&lt;li&gt;type
&lt;ul&gt;
&lt;li&gt;non-incremental
&lt;ul&gt;
&lt;li&gt;一次測試所有 component，測試整個應用程式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;incremental
&lt;ul&gt;
&lt;li&gt;每次新增一個 module，做一些測試，反覆執行&lt;/li&gt;
&lt;li&gt;Top-Down Testing
&lt;ul&gt;
&lt;li&gt;用詞
&lt;ul&gt;
&lt;li&gt;Stub
&lt;ul&gt;
&lt;li&gt;將要實現的 model 的 template，通常是 hard-coded value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;從最上層開始，下面調用的部分用 stub 代替&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bottom-Up Testing
&lt;ul&gt;
&lt;li&gt;用詞
&lt;ul&gt;
&lt;li&gt;Driver
&lt;ul&gt;
&lt;li&gt;用來執行 commands 還有初始化變數的 template&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;從最底層開始，上面呼叫的部分用 driver 代替&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Back-to-Back Testing
&lt;ul&gt;
&lt;li&gt;把已知良好的版本和新版本比較&lt;/li&gt;
&lt;li&gt;如果 output 一樣，就代表新版本舊的功能是正確的&lt;/li&gt;
&lt;li&gt;可以是 incremental testing 的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;black-box-vs-white-box-testing&#34;&gt;Black Box vs White Box Testing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Black Box Testing
&lt;ul&gt;
&lt;li&gt;不需要知道內部結構&lt;/li&gt;
&lt;li&gt;用 input 和 output 來測試&lt;/li&gt;
&lt;li&gt;Boundary Value
&lt;ul&gt;
&lt;li&gt;測試高低邊界值，過了就假設中間都過了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cause-Effect Graph
&lt;ul&gt;
&lt;li&gt;不同的 cause 會導致不同的 effect&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pair-wise Testing
&lt;ul&gt;
&lt;li&gt;多個參數一起測試好確認所有條件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;State-based Testing
&lt;ul&gt;
&lt;li&gt;測試輸入，確認 state 改變的情形&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;White Box Testing
&lt;ul&gt;
&lt;li&gt;知道內部原理，嘗試測試程式碼本身&lt;/li&gt;
&lt;li&gt;Control Flow Testing
&lt;ul&gt;
&lt;li&gt;寫涵蓋所有 branch condition 的 test case&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data Flow Testing
&lt;ul&gt;
&lt;li&gt;test case 要涵蓋所有的變數，包含 declaration 和 use&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Design</title>
        <link>https://roykesydon.github.io/Blog/p/design/</link>
        <pubDate>Thu, 27 Jun 2024 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/design/</guid>
        <description>&lt;h2 id=&#34;modularity&#34;&gt;Modularity&lt;/h2&gt;
&lt;h3 id=&#34;coupling&#34;&gt;Coupling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type
&lt;ul&gt;
&lt;li&gt;Tight coupling
&lt;ul&gt;
&lt;li&gt;Content coupling
&lt;ul&gt;
&lt;li&gt;一個模組依賴另一個模組的內部運作&lt;/li&gt;
&lt;li&gt;ex: 一個模組直接存取另一個模組的變數，假設回傳的數值是公尺，如果另一個模組要修改成公分，就會影響到這個模組
&lt;ul&gt;
&lt;li&gt;可以用 getter 抽象出 getMeter()，這樣就不會直接存取變數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Common coupling
&lt;ul&gt;
&lt;li&gt;多個模組共同存取和修改同個 global data&lt;/li&gt;
&lt;li&gt;ex: 一個模組錯誤修改會導致其他人都壞掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;External coupling
&lt;ul&gt;
&lt;li&gt;多個模組直接存取同個 external I/O&lt;/li&gt;
&lt;li&gt;ex: API 要改就會全部都影響到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Medium coupling
&lt;ul&gt;
&lt;li&gt;Control coupling
&lt;ul&gt;
&lt;li&gt;一個模組影響另一個模組的內部邏輯（比如說透過參數）&lt;/li&gt;
&lt;li&gt;ex: 參數要改個寫法就會影響一堆模組&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data-Sructure coupling
&lt;ul&gt;
&lt;li&gt;多個模組共同存取同個 data structure&lt;/li&gt;
&lt;li&gt;ex: Data structure 要改就會影響到其他模組&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Loose coupling
&lt;ul&gt;
&lt;li&gt;Data Coupling
&lt;ul&gt;
&lt;li&gt;兩個模組 share/pass 同樣的資料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Message Coupling
&lt;ul&gt;
&lt;li&gt;多個模組間透過 message 或是 command 來溝通&lt;/li&gt;
&lt;li&gt;和 control coupling 的差別在於，並沒有去控制某個模組，只是叫他做某件事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No Coupling
&lt;ul&gt;
&lt;li&gt;不是好的設計&lt;/li&gt;
&lt;li&gt;模組間沒有關聯，或是有個超巨大的模組&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cohesion&#34;&gt;Cohesion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;type
&lt;ul&gt;
&lt;li&gt;Weak cohesion
&lt;ul&gt;
&lt;li&gt;Coincidental cohesion
&lt;ul&gt;
&lt;li&gt;唯一的關聯是他們在同個檔案&lt;/li&gt;
&lt;li&gt;ex: single file program&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Temporal cohesion
&lt;ul&gt;
&lt;li&gt;關聯的地方是他們在同個時間點被執行&lt;/li&gt;
&lt;li&gt;ex: 「執行 shutdown  相關的活動」&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Logical cohesion
&lt;ul&gt;
&lt;li&gt;活動間可以被歸類在同個 general category&lt;/li&gt;
&lt;li&gt;ex: Backup Controller，可能有很多地方需要 Backup&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Medium cohesion
&lt;ul&gt;
&lt;li&gt;Procedureal cohesion
&lt;ul&gt;
&lt;li&gt;command 間存在執行順序&lt;/li&gt;
&lt;li&gt;ex: Clean car module 可能包含噴水、填表格、擦乾等等
&lt;ul&gt;
&lt;li&gt;但是 Clean car module 此處包含了操控財務資料的狀況&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Communicational cohesion
&lt;ul&gt;
&lt;li&gt;所有的 activities 都支援相同的 input/output&lt;/li&gt;
&lt;li&gt;ex: 提取文章的作者、提取文章的標題、提取文章的內容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sequential cohesion
&lt;ul&gt;
&lt;li&gt;某個 activities 的輸出是另一個 activities 的輸入，且具有順序性&lt;/li&gt;
&lt;li&gt;Procedureal cohesion 和 Communicational cohesion 的結合&lt;/li&gt;
&lt;li&gt;這個沒那麼糟糕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Strong cohesion
&lt;ul&gt;
&lt;li&gt;Functional cohesion
&lt;ul&gt;
&lt;li&gt;Module 只支援只和一個問題相關的 activities&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Object cohesion
&lt;ul&gt;
&lt;li&gt;所有的 activities 都只會修改一個 object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Requirements &amp; Specifications</title>
        <link>https://roykesydon.github.io/Blog/p/requirements-specifications/</link>
        <pubDate>Wed, 26 Jun 2024 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/requirements-specifications/</guid>
        <description>&lt;h2 id=&#34;definition&#34;&gt;definition&lt;/h2&gt;
&lt;h3 id=&#34;requirement&#34;&gt;Requirement&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;找出系統目標的過程&lt;/li&gt;
&lt;li&gt;系統需求的 non-technical definition&lt;/li&gt;
&lt;li&gt;應該要可以被任何人理解&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;specification&#34;&gt;Specification&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;系統需求的 technical definition&lt;/li&gt;
&lt;li&gt;盡量保持簡單，不是要 design&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;functional--non-functional-requirement&#34;&gt;Functional / Non-Functional Requirement&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Functional Requirement
&lt;ul&gt;
&lt;li&gt;系統應該要做什麼 (What)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-Functional Requirement
&lt;ul&gt;
&lt;li&gt;系統應該要怎麼做 (How)&lt;/li&gt;
&lt;li&gt;專注在 user experience&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wrspm&#34;&gt;WRSPM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用來理解 requirements, specifications 和 real world 之間的關聯的 reference model&lt;/li&gt;
&lt;li&gt;part
&lt;ul&gt;
&lt;li&gt;World
&lt;ul&gt;
&lt;li&gt;現實世界的假設&lt;/li&gt;
&lt;li&gt;ex: 有沒有網路？網速多快？使用者會自備 1 吋照片？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Requirements&lt;/li&gt;
&lt;li&gt;Specifications&lt;/li&gt;
&lt;li&gt;Program
&lt;ul&gt;
&lt;li&gt;code 本身&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Machine
&lt;ul&gt;
&lt;li&gt;硬體&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WRSPM Variables
&lt;ul&gt;
&lt;li&gt;Eh (Environment hidden)
&lt;ul&gt;
&lt;li&gt;Environment 中的元素，對 system 是不可見（隱藏）的&lt;/li&gt;
&lt;li&gt;ex: ATM 卡本身&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ev (Environment visible)
&lt;ul&gt;
&lt;li&gt;Environment 中的元素，對 system 是可見的&lt;/li&gt;
&lt;li&gt;ex: ATM 卡的晶片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sv (System visible)
&lt;ul&gt;
&lt;li&gt;System 中的元素，對 environment 是可見的&lt;/li&gt;
&lt;li&gt;ex: ATM 機的螢幕（UI）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sh (System hidden)
&lt;ul&gt;
&lt;li&gt;System 中的元素，對 environment 是不可見的&lt;/li&gt;
&lt;li&gt;ex: ATM 機連接的後端系統&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WRSPM visual model
&lt;ul&gt;
&lt;li&gt;分成 Environment 和 System，中間交界是 Interface
&lt;ul&gt;
&lt;li&gt;Environment
&lt;ul&gt;
&lt;li&gt;World&lt;/li&gt;
&lt;li&gt;Requirements&lt;/li&gt;
&lt;li&gt;Eh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interface
&lt;ul&gt;
&lt;li&gt;Specifications&lt;/li&gt;
&lt;li&gt;Ev&lt;/li&gt;
&lt;li&gt;Sv&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;System
&lt;ul&gt;
&lt;li&gt;Program&lt;/li&gt;
&lt;li&gt;Machine&lt;/li&gt;
&lt;li&gt;Sh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>設計模式 Desing Pattern</title>
        <link>https://roykesydon.github.io/Blog/p/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-desing-pattern/</link>
        <pubDate>Tue, 10 Oct 2023 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-desing-pattern/</guid>
        <description>&lt;h2 id=&#34;creational-patterns&#34;&gt;Creational patterns&lt;/h2&gt;
&lt;p&gt;關於 object creation 的 patterns。&lt;/p&gt;
&lt;h3 id=&#34;factory-method&#34;&gt;Factory Method&lt;/h3&gt;
&lt;p&gt;將不同 Product 定義一個共有的 Interface，並由子類別實作，透過工廠類別來產生實體。&lt;/p&gt;
&lt;p&gt;將建立 Product 的方法獨立出來，符合 Single Responsibility Principle。
可以輕易擴充新的 Product，而不用修改原本的程式碼，符合 Open-Closed Principle。&lt;/p&gt;
&lt;h3 id=&#34;abstract-factory&#34;&gt;Abstract Factory&lt;/h3&gt;
&lt;p&gt;相比 Factory Method，現在的情境是有多個 Product，而且每次都是使用同一系列的 Product。&lt;/p&gt;
&lt;h3 id=&#34;builder&#34;&gt;Builder&lt;/h3&gt;
&lt;p&gt;對於建構一個複雜且具備多種組合的產品，可以透過建構巨大的建構函式或是覆蓋所有可能的子類別來解決。&lt;/p&gt;
&lt;p&gt;但都存在其問題，要不是大量的子類別，不然就是難以呼叫的建構函式。&lt;/p&gt;
&lt;p&gt;把建立物件的每個 component 獨立出來，並且切成多個可分開執行的 step。&lt;/p&gt;
&lt;p&gt;由 Builder 來負責生出每一個 component，Director 不是必需的，但有需要的話可以讓他幫忙調用 Builder 的 method，好在專案中重複使用。&lt;/p&gt;
&lt;h3 id=&#34;prototype&#34;&gt;Prototype&lt;/h3&gt;
&lt;p&gt;使用在想要獲得某個對象的 clone 的情境。&lt;/p&gt;
&lt;p&gt;把 clone 的責任交給對象本身，而不是交給 Client。由對象本身提供 clone method。&lt;/p&gt;
&lt;h3 id=&#34;singleton&#34;&gt;Singleton&lt;/h3&gt;
&lt;p&gt;確保某個類別只有一個 instance，並且提供一個 global access point。&lt;/p&gt;
&lt;p&gt;但是這樣違反了 Single Responsibility Principle，因為除了原本的功能外，還要負責管理自己的 instance。&lt;/p&gt;
&lt;h2 id=&#34;structural-patterns&#34;&gt;Structural patterns&lt;/h2&gt;
&lt;p&gt;探討如何組裝類別和物件成為更大的結構。&lt;/p&gt;
&lt;h3 id=&#34;adapter&#34;&gt;Adapter&lt;/h3&gt;
&lt;p&gt;轉換某個對象的 interface 到另外一種 interface，讓另外一個 Object 可以理解他。
就像 XML 要轉到 JSON。&lt;/p&gt;
&lt;h3 id=&#34;brdige&#34;&gt;Brdige&lt;/h3&gt;
&lt;p&gt;使用在需要在多個 orthogonal (independent) 的維度上擴展類別時的情境。
讓情況從難以計數的子類別數，變成多組功能聯合起來。&lt;/p&gt;
&lt;p&gt;拆成 abstraction (high-level control) 和 implementation (實際工作)，
由 abstraction 來控制 implementation，比如 GUI 來控制底下的 API&lt;/p&gt;
&lt;h3 id=&#34;composite&#34;&gt;Composite&lt;/h3&gt;
&lt;p&gt;用在某些層級結構。&lt;/p&gt;
&lt;p&gt;對於 Composite (Container)，不但實現 Component，也提供一個 list 來存放子 component。&lt;/p&gt;
&lt;p&gt;對 Composite 的操作，會被委託給子 component，不需要 client 擔心。&lt;/p&gt;
&lt;p&gt;就像指揮官只需要對高階軍官下命令。&lt;/p&gt;
&lt;h3 id=&#34;decorator&#34;&gt;Decorator&lt;/h3&gt;
&lt;p&gt;當今天有多種同類型的東西，你可以能會同時用到多種子類別所形成的組合時，就可以用 Decorator。&lt;/p&gt;
&lt;p&gt;比如多種類型的 notification，你可能同時想要 FB 和 TG 的，或是只想要其中一個。
或是多件衣服，有超級多種的穿搭。&lt;/p&gt;
&lt;p&gt;但這是一層層的感覺，具有順序性。
Decorator 和 Component 都繼承同一個 interface。
就像是 &lt;code&gt;Data data = new Encrypt(new Compress(new FileData()))&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;存在很難從 stack 中刪除特定 decorator 的缺點。&lt;/p&gt;
&lt;h3 id=&#34;facade&#34;&gt;Facade&lt;/h3&gt;
&lt;p&gt;為複雜的一堆子系統提供一個 Class，讓 client 可以使用他們關心的功能。
實際怎麼調用 client 無須知道。&lt;/p&gt;
&lt;p&gt;容易形成 god object。&lt;/p&gt;
&lt;h3 id=&#34;flyweight&#34;&gt;Flyweight&lt;/h3&gt;
&lt;p&gt;對於大量類似的物件，為求節省記憶體而誕生的 pattern。&lt;/p&gt;
&lt;p&gt;把物件的內容分成 intrinsic 和 extrinsic，intrinsic 是不會改變的 (unique)，而 extrinsic 是會改變的 (repeating)。&lt;/p&gt;
&lt;p&gt;讓 extrinsic 的東西用同一塊記憶體。&lt;/p&gt;
&lt;h3 id=&#34;proxy&#34;&gt;Proxy&lt;/h3&gt;
&lt;p&gt;用在多個服務想要調用某個重量級資源的情境下。&lt;/p&gt;
&lt;p&gt;存在多種 proxy 的應用類型，比如 cache 機制來加速資源的存取，並減少系統資源消耗。&lt;/p&gt;
&lt;h2 id=&#34;behavioral-patterns&#34;&gt;Behavioral patterns&lt;/h2&gt;
&lt;h3 id=&#34;chain-of-responsibility&#34;&gt;Chain of Responsibility&lt;/h3&gt;
&lt;p&gt;對於一系列檢查的情況，可以用這種作法，有兩種形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一路檢查，檢查失敗則中斷請求。&lt;/li&gt;
&lt;li&gt;每個 Handler 自行決定要不要處理該請求，要的話則不會往下傳。
&lt;ul&gt;
&lt;li&gt;這樣可能會最後沒人處理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就像網頁點擊事件，一層層元素往下問。&lt;/p&gt;
&lt;h3 id=&#34;command&#34;&gt;Command&lt;/h3&gt;
&lt;p&gt;把請求獨立出來，讓該請求可以被用作參數、佇列、撤銷行為等。&lt;/p&gt;
&lt;p&gt;比如多種不同的按鈕背後都執行同一個存檔功能。存檔就可以作為 command 獨立出來。
背後再根據這個 command 實施對應的業務邏輯。&lt;/p&gt;
&lt;h3 id=&#34;iterator&#34;&gt;Iterator&lt;/h3&gt;
&lt;p&gt;用來需要遍歷集合中元素的情境，把不同種類的遍歷行為細節隱藏起來。&lt;/p&gt;
&lt;p&gt;提供多種不同的 iterator，但遵循同一種 interface，讓使用者可以根據需要選擇 iterator。
對於不關心用哪種 iterator 的使用者，也能受益於 iterator 的 interface，而不必耦合於特定的演算法。&lt;/p&gt;
&lt;h3 id=&#34;mediator&#34;&gt;Mediator&lt;/h3&gt;
&lt;p&gt;禁止多個 component 間的直接溝通，迫使他們透過 mediator 來溝通，避免複雜的關係。
所有人只能透過 notify mediator 來溝通，mediator 根據 sender 和 event，來做出相應處理。&lt;/p&gt;
&lt;h3 id=&#34;memento&#34;&gt;Memento&lt;/h3&gt;
&lt;p&gt;讓你可以儲存和復原到先前的狀態。&lt;/p&gt;
&lt;p&gt;讓要儲存的對象自己生成 snapshot。&lt;/p&gt;
&lt;p&gt;建議存在名為 momento 的 special object，這個 object 不能讓除了 producer 外的其他 object 直接存取。
其他 object 只能透過 limited interface 來取得 metadata。&lt;/p&gt;
&lt;p&gt;這些限制讓 momento 可以交給其他 object 來管理，稱為 caretaker。&lt;/p&gt;
&lt;h3 id=&#34;observer&#34;&gt;Observer&lt;/h3&gt;
&lt;p&gt;定義 subscription 機制。&lt;/p&gt;
&lt;p&gt;有 interesting state 的 object 稱為 subject，但由於他也會通知其他人，所以又稱為 publisher。追蹤它的人稱為 Subscriber。&lt;/p&gt;
&lt;h3 id=&#34;state&#34;&gt;State&lt;/h3&gt;
&lt;p&gt;用在類似 Finite-State Machine 的情況。&lt;/p&gt;
&lt;p&gt;該 pattern 把每個 state 獨立成一個 Class，把實際的行為委託給 state，而不是由 context (原始物件) 來控制。Context 只管切換 state。&lt;/p&gt;
&lt;h3 id=&#34;strategy&#34;&gt;Strategy&lt;/h3&gt;
&lt;p&gt;把不同實現方法的演算法定義為遵循同一個 interface 的類別，讓使用者可以根據需要選擇演算法。&lt;/p&gt;
&lt;h3 id=&#34;template-method&#34;&gt;Template Method&lt;/h3&gt;
&lt;p&gt;把演算法拆成多個步驟，讓子類別可以覆寫其中的步驟，但不改變演算法的結構。&lt;/p&gt;
&lt;h3 id=&#34;visitor&#34;&gt;Visitor&lt;/h3&gt;
&lt;p&gt;讓我們可以把演算法從執行他們的 object 中分離出來。&lt;/p&gt;
&lt;p&gt;假設我們要對一堆繼承 client 屬性的公司新增 sendEmail 功能，如果我們在 client 新增 sendEmail 並且 override 每個子 class，就會違反 Single Responsibility Principle 和 Open-Closed Principle。&lt;/p&gt;
&lt;p&gt;要利用 Double-Dispatch，讓 Object 本身選擇該用的演算法。&lt;/p&gt;
&lt;p&gt;雖然這樣依然會修改到子 class，但這屬於微不足道的改變，而且可以讓之後新增的一些功能不用再去修改這些子 class。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>領域驅動設計 Domain-Driven Design</title>
        <link>https://roykesydon.github.io/Blog/p/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88-domain-driven-design/</link>
        <pubDate>Mon, 22 May 2023 00:00:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88-domain-driven-design/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;軟體要對 domain 做 Modeling，呈現出 domain 裡的核心概念，才能滿足使用者需求，因此不乏與領域專家的討論&lt;/p&gt;
&lt;p&gt;寫這篇的時候我還沒嗑完 Eric 的聖經，可能嗑完了之後會回來修改&lt;/p&gt;
&lt;h2 id=&#34;通用語言-ubiquitous-language&#34;&gt;通用語言 Ubiquitous Language&lt;/h2&gt;
&lt;p&gt;鑒於程式開發人員與領域專家熟悉知識的差異，會產生交流困難&lt;/p&gt;
&lt;p&gt;因此領域專家和開發團隊要訂定共同的語言，並且盡可能少用自己知道的術語&lt;/p&gt;
&lt;h2 id=&#34;uml&#34;&gt;UML&lt;/h2&gt;
&lt;p&gt;UML 適合用在小型模型上，它擅長表達類別間的關係，但對於抽象概念卻沒那麼好傳達&lt;/p&gt;
&lt;p&gt;因此用 UML 建構模型時，理想上要添加額外的文字，傳達一些圖所不能表達的 behavior 和 constraint&lt;/p&gt;
&lt;p&gt;並且不能一次寫過於複雜，而是分塊處理&lt;/p&gt;
&lt;h2 id=&#34;layered-architecture&#34;&gt;Layered Architecture&lt;/h2&gt;
&lt;p&gt;分為四個概念層，只會往下調用，可能會跨層&lt;/p&gt;
&lt;p&gt;可以達到關注點分離 (separation of concerns)，提高各個方面的 cohesive&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User Interface (Presentation Layer)
&lt;ul&gt;
&lt;li&gt;呈現給 user 的 UI，User 可能是另一個系統&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Application Layer
&lt;ul&gt;
&lt;li&gt;不含 bussiness logic，指揮表達領域概念的物件來完成任務&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Domain Layer
&lt;ul&gt;
&lt;li&gt;有關 domain 的資訊都在這裡，業務邏輯在此處理&lt;/li&gt;
&lt;li&gt;表達業務概念、狀態、規則&lt;/li&gt;
&lt;li&gt;劃分出這層是 Model-Driven Design 的關鍵&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Infrastructure layer
&lt;ul&gt;
&lt;li&gt;supporting library&lt;/li&gt;
&lt;li&gt;保存業務狀態的技術細節在此實作&lt;/li&gt;
&lt;li&gt;為前三個 layer 服務&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;entity&#34;&gt;Entity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;具備 identity&lt;/li&gt;
&lt;li&gt;identity 在 status 經過改變後依然不變&lt;/li&gt;
&lt;li&gt;追蹤 entity 需要高成本&lt;/li&gt;
&lt;li&gt;mutable&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;value-object&#34;&gt;Value Object&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;沒有 identity&lt;/li&gt;
&lt;li&gt;只關心 obejct 的 value&lt;/li&gt;
&lt;li&gt;可以輕易創建丟棄&lt;/li&gt;
&lt;li&gt;immutable (不變的)
&lt;ul&gt;
&lt;li&gt;如果想修改數值就創新的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可被共用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有些動作不屬於某個 Entity 或 Value Object，因為它是跨物件的&lt;/li&gt;
&lt;li&gt;Stateless
&lt;ul&gt;
&lt;li&gt;每個請求不互相影響&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aggregate&#34;&gt;Aggregate&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;把複雜關聯的物件圈在一起考量&lt;/li&gt;
&lt;li&gt;確保 consistency 和 inveraints
&lt;ul&gt;
&lt;li&gt;consistency (一致性)
&lt;ul&gt;
&lt;li&gt;相關物件的資料一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;invariants (不變量)
&lt;ul&gt;
&lt;li&gt;資料改變時要維護的規則&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;aggregate-root&#34;&gt;Aggregate root&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;具備 global identity，其他內部 entity 只有 local identity&lt;/li&gt;
&lt;li&gt;通常是 entity 擔任&lt;/li&gt;
&lt;li&gt;外部只能存取它，不能存取 aggregate 的其他 entity 或 value obejct&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;factory&#34;&gt;Factory&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;若創建 aggregate、entity、value object 的過程很複雜，或是涉及專業知識，就該用 factory 包起來&lt;/li&gt;
&lt;li&gt;對於不複雜的情況，或是想控制更多細節，可以只依賴於簡單的建構函式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;repository&#34;&gt;Repository&lt;/h2&gt;
&lt;p&gt;如果大家都直接存取資料庫的各種物件，會破壞原本精心設計的結構，破壞封裝性&lt;/p&gt;
&lt;p&gt;Repositoy 用來存取物件，封裝了資料庫操作&lt;/p&gt;
&lt;h2 id=&#34;domain-event&#34;&gt;Domain event&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Domain 中重要的事情&lt;/li&gt;
&lt;li&gt;可以用在其他物件和 aggrgate 訂閱，讓 aggregate 通知他們 domain event 的發生&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;anti-pattern&#34;&gt;Anti-Pattern&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;應該避免的情形&lt;/li&gt;
&lt;li&gt;Smart UI
&lt;ul&gt;
&lt;li&gt;超肥的萬能 UI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Anemic Domain Model
&lt;ul&gt;
&lt;li&gt;貧血模型&lt;/li&gt;
&lt;li&gt;只有 getter 和 setter，沒有業務邏輯的模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;subdomain&#34;&gt;Subdomain&lt;/h2&gt;
&lt;p&gt;把 domain 切分成小塊，理想上 subdomain 和 bounded context 有 one-to-one 的關係&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types
&lt;ul&gt;
&lt;li&gt;core subdomain
&lt;ul&gt;
&lt;li&gt;和其他競爭者相比不同的部分，最核心的業務，比如搜尋引擎中的搜尋演算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;generic subdomain
&lt;ul&gt;
&lt;li&gt;大家都會弄的部分，比如登入系統&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;supporting subdomain
&lt;ul&gt;
&lt;li&gt;用來輔助 core subdomain 的部分，比如篩選網頁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bounded-context&#34;&gt;Bounded Context&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;劃出 boundary，確保 boundary 內用的概念、規則皆一致&lt;/li&gt;
&lt;li&gt;同個名詞可能出現在不同的 context，但有不同意思&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;context-map&#34;&gt;Context Map&lt;/h2&gt;
&lt;p&gt;描述 BC 和 BC 間的關係&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上下游 (U/D)
&lt;ul&gt;
&lt;li&gt;上游提供下游 (下游依賴上游)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Shared Kernel
&lt;ul&gt;
&lt;li&gt;兩個 BC 共用的部份&lt;/li&gt;
&lt;li&gt;違反 BC 的基本原則，是一種例外設計&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Customer-Supplier
&lt;ul&gt;
&lt;li&gt;一個子系統重度依賴另一個子系統&lt;/li&gt;
&lt;li&gt;Conformist
&lt;ul&gt;
&lt;li&gt;Customer 完全配合 Supplier&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Partnership
&lt;ul&gt;
&lt;li&gt;兩個 BC 互相合作，沒有以誰為主&lt;/li&gt;
&lt;li&gt;一起成功或一起失敗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Anticorruption Layer (ACL)
&lt;ul&gt;
&lt;li&gt;開發系統和外部系統的中間層&lt;/li&gt;
&lt;li&gt;可能出現在調用 legacy system&lt;/li&gt;
&lt;li&gt;常用到 Facade 和 Adapter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Open Host Service (OHS)
&lt;ul&gt;
&lt;li&gt;如果外部子系統要給一堆用戶端子系統調用，就得在所有用戶端子系統搞 ACL&lt;/li&gt;
&lt;li&gt;外部系統做為服務提供，常會搭配 Published Language (PL)
&lt;ul&gt;
&lt;li&gt;PL 是協定傳送資料的格式，比如 XML、JSON 或是 Protocol Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pratical-ddd&#34;&gt;Pratical DDD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The strangler migration
&lt;ul&gt;
&lt;li&gt;透過 Facade，把一些服務慢慢移植給新系統，最後取代 legacy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>重構 Refactoring</title>
        <link>https://roykesydon.github.io/Blog/p/%E9%87%8D%E6%A7%8B-refactoring/</link>
        <pubDate>Tue, 25 Apr 2023 14:26:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/%E9%87%8D%E6%A7%8B-refactoring/</guid>
        <description>&lt;h2 id=&#34;重構&#34;&gt;重構&lt;/h2&gt;
&lt;p&gt;在不改變軟體行為的情況下，對軟體內部構造進行改善&lt;/p&gt;
&lt;h2 id=&#34;code-smell&#34;&gt;Code Smell&lt;/h2&gt;
&lt;p&gt;也稱 Bad Smell，代表程式碼中需要重構的部分&lt;/p&gt;
&lt;h3 id=&#34;duplicated-code&#34;&gt;Duplicated Code&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重複程式碼
&lt;ul&gt;
&lt;li&gt;在同個 Class
&lt;ul&gt;
&lt;li&gt;Extract Method&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在不同 Class
&lt;ul&gt;
&lt;li&gt;Extract Class&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;long-method&#34;&gt;Long Method&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用 Extract Method 拆解過長的 function&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;long-parameter-list&#34;&gt;Long Parameter List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Preserve Whole Object
&lt;ul&gt;
&lt;li&gt;把來自同一物件的資料直接該物件取代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Introduce Parameter Object
&lt;ul&gt;
&lt;li&gt;把相關的資料包成一個 Object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;large-class&#34;&gt;Large Class&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一個 Class 有太多 fields / methods / lines&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;magic-number&#34;&gt;Magic Number&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;特殊數值直接用數字表示，日後修改每個地方都要改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lack-of-comments&#34;&gt;Lack of Comments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加註解的好時機：寫程式前寫上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;switch-statements&#34;&gt;Switch Statements&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可利用「多型 (Polymorphism)」解決&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;divergent-change&#34;&gt;Divergent Change&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一個類別有太多改變的原因&lt;/li&gt;
&lt;li&gt;盡量讓其遵守 SRP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;shotgun-surgery&#34;&gt;Shotgun Surgery&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;某個責任被分散到大量的 Class 身上，使修改其時要大量修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;feature-envy&#34;&gt;Feature Envy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存取別的 Object 的 Data 的情形比自己的還頻繁&lt;/li&gt;
&lt;li&gt;這方法可能應該屬於另一個 Object&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;data-clumps&#34;&gt;Data Clumps&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常一起出現的資料群應該被單獨抽成一個 Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;primitive-obsession&#34;&gt;Primitive Obsession&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;過度使用基本類別，造成 Shotgun Surgery&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;message-chains&#34;&gt;Message Chains&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Client 請求 A 物件，A 物件又請求 B 物件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lazy-class&#34;&gt;Lazy Class&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把冗員類別移除&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;temporary-field&#34;&gt;Temporary Field&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Instance variable 只有在特殊情形才被使用，應該改為區域變數或參數&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;inappropriate-intimacy&#34;&gt;Inappropriate Intimacy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Classes 間頻繁讀取對方資料&lt;/li&gt;
&lt;li&gt;理解程式要同時看懂兩者&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;alternative-classes-with-different-interfaces&#34;&gt;Alternative Classes with Different Interfaces&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;兩個 Class 具有功能相同、命名不同的 function&lt;/li&gt;
&lt;li&gt;可汲取共同部分為 Super Class 來解決&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>軟體設計原則</title>
        <link>https://roykesydon.github.io/Blog/p/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</link>
        <pubDate>Wed, 08 Mar 2023 14:26:17 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87/</guid>
        <description>&lt;h2 id=&#34;uml-類別圖&#34;&gt;UML 類別圖&lt;/h2&gt;
&lt;h3 id=&#34;relationship&#34;&gt;Relationship&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Dependency
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;uses-a&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Association
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;knows-a&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Composition
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;has-a&amp;rdquo;&lt;/li&gt;
&lt;li&gt;child 的存在依賴於 parent，若刪除 parent，child 也會隨之刪除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Aggregation
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;has-a&amp;rdquo;&lt;/li&gt;
&lt;li&gt;child 的存在獨立於 parent，若刪除 parent，child 不會隨之刪除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Inheritance
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;is-a&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;can-do&amp;rdquo;&lt;/li&gt;
&lt;li&gt;實現 interface&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;other-features&#34;&gt;other features&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Navigation
&lt;ul&gt;
&lt;li&gt;當兩個 class 都可以看到對方，就用沒箭頭的關聯線，否則有箭頭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Role Name
&lt;ul&gt;
&lt;li&gt;類別中的 Attribute&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multiplicity
&lt;ul&gt;
&lt;li&gt;關聯端點上可以寫數量，代表物件個數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Self-Association
&lt;ul&gt;
&lt;li&gt;同個類別的物件彼此有關係&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;軟體設計原則&#34;&gt;軟體設計原則&lt;/h2&gt;
&lt;h3 id=&#34;encapsulate-what-varies&#34;&gt;Encapsulate What Varies&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把經常改變的程式碼封裝起來，使日後修改時不會影響其他區塊的程式碼&lt;/li&gt;
&lt;li&gt;實際使用的情境，可以把常改變的東西放在 interface 後，使日後改變實作時不影響呼叫該 interface 的程式碼&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;favor-composition-over-inheritance&#34;&gt;Favor Composition over Inheritance&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Composition(組合)在很多情境可以取代掉 Inheritance(繼承)，甚至實現 Polymorphism(多型)&lt;/li&gt;
&lt;li&gt;只有當 is-a 的情境出現，才用繼承比較好&lt;/li&gt;
&lt;li&gt;Composition 使用起來更有彈性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;solid-設計原則&#34;&gt;SOLID 設計原則&lt;/h2&gt;
&lt;h3 id=&#34;single-responsibility-principle-srp&#34;&gt;Single Responsibility Principle, SRP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;單一職責原則&lt;/li&gt;
&lt;li&gt;A class should have only one reason to change.&lt;/li&gt;
&lt;li&gt;可以把一個複雜的 module 拆成多個&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;open-close-principle-ocp&#34;&gt;Open-Close Principle, OCP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;開放封閉原則&lt;/li&gt;
&lt;li&gt;You should be able to extend the behavior of a system without having to modify that system.&lt;/li&gt;
&lt;li&gt;要可以擴充，同時不修改到原系統&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;liskovsubstitution-principle-lsp&#34;&gt;LiskovSubstitution Principle, LSP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;里氏替換原則&lt;/li&gt;
&lt;li&gt;父類別有的功能，子類別必須遵從，父類別的部分要可以直接替換成子類別&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;interface-segregation-principle-isp&#34;&gt;Interface Segregation Principle, ISP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;介面隔離原則&lt;/li&gt;
&lt;li&gt;No client should be forced to depend on methods it does not use&lt;/li&gt;
&lt;li&gt;以 interface 來說，不該讓 module 實現它不需要的功能，可以把 interface 拆小&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dependency-inversion-principle-dip&#34;&gt;Dependency Inversion Principle, DIP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;反向依賴原則&lt;/li&gt;
&lt;li&gt;高階模組不應該依賴低階模組，兩者都應依賴抽象層&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
