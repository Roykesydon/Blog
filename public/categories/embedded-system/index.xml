<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Embedded System on Roykesydon</title>
        <link>https://roykesydon.github.io/Blog/categories/embedded-system/</link>
        <description>Recent content in Embedded System on Roykesydon</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 08 May 2023 00:00:54 +0800</lastBuildDate><atom:link href="https://roykesydon.github.io/Blog/categories/embedded-system/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>電路學 - III</title>
        <link>https://roykesydon.github.io/Blog/p/%E9%9B%BB%E8%B7%AF%E5%AD%B8-iii/</link>
        <pubDate>Mon, 08 May 2023 00:00:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/%E9%9B%BB%E8%B7%AF%E5%AD%B8-iii/</guid>
        <description>&lt;h2 id=&#34;運算放大器-operational-amplifiers&#34;&gt;運算放大器 (Operational Amplifiers)&lt;/h2&gt;
&lt;h3 id=&#34;介紹&#34;&gt;介紹&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;運算放大器 (Operational Amplifiers)
&lt;ul&gt;
&lt;li&gt;特性
&lt;ul&gt;
&lt;li&gt;類似於電壓控制電壓相依電源的電子元件&lt;/li&gt;
&lt;li&gt;主動電路元件&lt;/li&gt;
&lt;li&gt;用於執行加、減、乘、除、微分與積分等運數學運算的主動電路元件&lt;/li&gt;
&lt;li&gt;由電阻、電晶體、電容和二極體等所構成的電子元件，但因內部電路的討論已超出範圍，先看作是電路模組&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;封裝形式
&lt;ul&gt;
&lt;li&gt;DIP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;輸出電壓 $v_O$
&lt;ul&gt;
&lt;li&gt;$v_O=Av_d=A(v_2-v_1)$
&lt;ul&gt;
&lt;li&gt;$v_2$ 是非反相輸入 (noninverting input)&lt;/li&gt;
&lt;li&gt;$v_1$ 是反相輸入  (inverting input)&lt;/li&gt;
&lt;li&gt;$A$ 是開迴路電壓增益 (open-loop voltage gain)
&lt;ul&gt;
&lt;li&gt;是沒有任何從輸出到輸入的回授 (feedback) 時，運算放大器的增益&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回授
&lt;ul&gt;
&lt;li&gt;負回授 (negative feedback)
&lt;ul&gt;
&lt;li&gt;輸出回授至反相輸入端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;閉迴路增益 (closed-loop gain)
&lt;ul&gt;
&lt;li&gt;如果存在由輸出到輸入的回授，輸出電壓與輸入電壓的比例稱為閉迴路增益&lt;/li&gt;
&lt;li&gt;對負回授電路而言，可以證明閉迴路增益和開迴路增益無關，因此運算放大器總是用於具回授的電路中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作模式
&lt;ul&gt;
&lt;li&gt;正飽和區
&lt;ul&gt;
&lt;li&gt;$v_O=V_{CC}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;線性區
&lt;ul&gt;
&lt;li&gt;$-V_{CC} \leq v_O = Av_d \leq V_{CC}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;負飽和區
&lt;ul&gt;
&lt;li&gt;$v_O=-V_{CC}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;符號
&lt;ul&gt;
&lt;li&gt;$v_O$ 是輸出電壓&lt;/li&gt;
&lt;li&gt;$v_d$ 是輸入電壓差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;理想運算放大器-ideal-op-amp&#34;&gt;理想運算放大器 (Ideal Op Amp)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;假定運算放大器是理想的是符合實際的，因位目前絕大多數運算放大器都有很大的增益和輸入電阻&lt;/li&gt;
&lt;li&gt;具有以下特性的運算放大器，稱為理想運算放大器
&lt;ul&gt;
&lt;li&gt;$A \simeq \inf$
&lt;ul&gt;
&lt;li&gt;開迴路增益無窮大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$R_i \simeq \inf$
&lt;ul&gt;
&lt;li&gt;輸入電阻無窮大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$R_O \simeq 0$
&lt;ul&gt;
&lt;li&gt;輸出電阻為零&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特性
&lt;ul&gt;
&lt;li&gt;流入兩個輸入端的電流均為 0，因為輸入電阻無窮大，輸入端間開路&lt;/li&gt;
&lt;li&gt;輸入端間的電壓差等於零，$v_d=v_2-v_1=0$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反相放大器-inverting-amplifier&#34;&gt;反相放大器 (Inverting Amplifier)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;對輸入信號放大的同時反轉極性&lt;/li&gt;
&lt;li&gt;公式
&lt;ul&gt;
&lt;li&gt;$v_0=-\frac{R_f}{R_1}v_i$
&lt;ul&gt;
&lt;li&gt;$R_f$ 是回授電阻&lt;/li&gt;
&lt;li&gt;$R_1$ 是進到負回授節點前的電阻&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非反相放大器-noninverting-amplifier&#34;&gt;非反相放大器 (Noninverting Amplifier)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提供正電壓增益的運算放大器電路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_0=(1+\frac{R_f}{R_1})v_i$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;電壓隨耦器 (voltage follewer)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;又稱單位增益放大器 (unity gain amplifier)&lt;/li&gt;
&lt;li&gt;條件
&lt;ul&gt;
&lt;li&gt;$R_f=0 或 R_1=\inf 或 (R_f=0 且 R_1=\inf)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公式
&lt;ul&gt;
&lt;li&gt;$v_0=v_i$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;加法放大器-summing-amplifier&#34;&gt;加法放大器 (Summing Amplifier)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;將多個輸入結合，在輸出產生輸入的加權總合&lt;/li&gt;
&lt;li&gt;公式
&lt;ul&gt;
&lt;li&gt;$v_O=-(\frac{R_f}{R_1}v_1+\frac{R_f}{R_2}v_2+\frac{R_f}{R_3}v_3)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;差動放大器-difference-amplifier&#34;&gt;差動放大器 (Difference Amplifier)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;放大兩個輸入信號的差而抑制兩個輸入的共模信號 (Common-mode signal)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_O=\frac{R_2(1+R_1/R_2)}{R1(1+R_3/R_4)}v_2-\frac{R_2}{R_1}v_1$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 $R_2=R_1$ 且 $R_3=R_4$，動差放大器為減法器 (subtractor)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v_O=v_2-v_1$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;串級運算放大器電路-cascaded-op-amp-circuits&#34;&gt;串級運算放大器電路 (Cascaded Op Amp Circuits)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;串級
&lt;ul&gt;
&lt;li&gt;兩個以上的運算放大器首尾相接，前一級的輸出是下一級的輸入&lt;/li&gt;
&lt;li&gt;多個運算放大器串級時，每個電路都稱為一級 (stage)&lt;/li&gt;
&lt;li&gt;運算放大器的優點
&lt;ul&gt;
&lt;li&gt;串級不會改變各自輸入-輸出
&lt;ul&gt;
&lt;li&gt;因為理想的運算放大器輸入電阻無窮大，輸出電阻為 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;總增益為個別增益的乘積
&lt;ul&gt;
&lt;li&gt;$A=A_1A_2A_3$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;數位-類比轉換器-digital-to-analog-converter-dac&#34;&gt;數位-類比轉換器 (Digital-to-Analog Converter, DAC)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DAC 把數位信號轉成類比信號&lt;/li&gt;
&lt;li&gt;實現方法
&lt;ul&gt;
&lt;li&gt;二進位加權階梯電路 (binary weighted ladder)
&lt;ul&gt;
&lt;li&gt;把權重設計成二進位的加法放大器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;輸入
&lt;ul&gt;
&lt;li&gt;最高位元 (most significant bit, MSB)&lt;/li&gt;
&lt;li&gt;最低位元 (least significant bit, LSB)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;儀表放大器-instrumentation-amplifiers&#34;&gt;儀表放大器 (Instrumentation Amplifiers)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;差動放大器的延伸&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;電容器與電感器&#34;&gt;電容器與電感器&lt;/h2&gt;
&lt;h3 id=&#34;介紹-1&#34;&gt;介紹&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;電容器與電感器是能儲存能量的儲能元件 (storage element)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電容器-capacitors&#34;&gt;電容器 (Capacitors)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;將能量儲存在電場中的被動元件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由兩片導電板夾著絕緣體 (電介質) 組成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$q=Cv$
&lt;ul&gt;
&lt;li&gt;q 是儲存的電荷量&lt;/li&gt;
&lt;li&gt;C 是比例常數，又稱電容 (capacitance)
&lt;ul&gt;
&lt;li&gt;單位是法拉 (farad, F)&lt;/li&gt;
&lt;li&gt;C 不是由 q 和 v 決定
&lt;ul&gt;
&lt;li&gt;$C=\frac{\epsilon A}{d}$
&lt;ul&gt;
&lt;li&gt;$\epsilon$ 是介電常數&lt;/li&gt;
&lt;li&gt;$A$ 是導電極版的截面積&lt;/li&gt;
&lt;li&gt;$d$ 是兩極板的間距&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$v(t)=\frac{1}{C}\int_{t_0}^t i (\tau)d\tau + v(t_0)$&lt;/li&gt;
&lt;li&gt;$w=\frac{1}{2}Cv^2$
&lt;ul&gt;
&lt;li&gt;電場儲存的能量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;線性電容 (linear capacitor)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滿足 $i=C\frac{dv}{dt}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非線性電容 (nonlinear capacitor)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;電流電壓關係曲線非直線，不過多數電容是線性的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重要性質&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;電容器在直流下工作，等同開路
&lt;ul&gt;
&lt;li&gt;電壓不隨時間改變的話電流是 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;電容器上的電壓必須是連續的
&lt;ul&gt;
&lt;li&gt;因為不連續變化的電壓需要無限大的電流&lt;/li&gt;
&lt;li&gt;電容會反抗電壓的突然改變&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理想電容器不消耗能量&lt;/li&gt;
&lt;li&gt;實際的非理想電容器會並聯一個漏電阻，可高達 $100M \Omega$，在多數情況可忽略不計&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電容器串並聯&#34;&gt;電容器串並聯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;並聯
&lt;ul&gt;
&lt;li&gt;$C_{eq} = C_1 + C_2 + C_3 + &amp;hellip; + C_N$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;串聯
&lt;ul&gt;
&lt;li&gt;$\frac{1}{C_{eq}} = \frac{1}{C_{1}} + \frac{1}{C_{2}} + \frac{1}{C_{3}} + &amp;hellip; + \frac{1}{C_{N}}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電感器-inductors&#34;&gt;電感器 (Inductors)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;將能量儲存於磁場中的被動元件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v=L\frac{di}{dt}$
&lt;ul&gt;
&lt;li&gt;L 是比例常數，又稱為電感 (inductance)
&lt;ul&gt;
&lt;li&gt;單位是亨利 (henry, H)&lt;/li&gt;
&lt;li&gt;由物理尺寸和結構決定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$i=\frac{1}{L}\int_{t_0}^t v (\tau)d\tau + i(t_0)$&lt;/li&gt;
&lt;li&gt;$w=\frac{1}{2}Li^2$
&lt;ul&gt;
&lt;li&gt;儲存的能量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;電感反應電感器反抗電流變化的特性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;線性電感 (linear inductor)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滿足 $v=L\frac{di}{dt}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非線性電感 (nonlinear inductor)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$v$ 和 $di/dt$ 關係曲線非直線&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重要性質&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在直流中，電感器等同短路&lt;/li&gt;
&lt;li&gt;電感器上的電流必須是連續的
&lt;ul&gt;
&lt;li&gt;因為不連續變化的電流需要無限大的電壓&lt;/li&gt;
&lt;li&gt;電容會反抗電流的突然改變&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理想電感器不消耗能量&lt;/li&gt;
&lt;li&gt;實際的非理想電容器會串聯一個繞線電阻 (winding resistance)，由製成電感的導電材料產生，通常很小。並由於線圈間的電容性耦合，也存在繞線電容 (winding capacitance)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電感器串並聯&#34;&gt;電感器串並聯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;串聯
&lt;ul&gt;
&lt;li&gt;$L_{eq} = L_1 + L_2 + L_3 + &amp;hellip; + L_N$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;並聯
&lt;ul&gt;
&lt;li&gt;$\frac{1}{L_{eq}} = \frac{1}{L_{1}} + \frac{1}{L_{2}} + \frac{1}{L_{3}} + &amp;hellip; + \frac{1}{L_{N}}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;應用&#34;&gt;應用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;電感電容的特殊性質
&lt;ul&gt;
&lt;li&gt;能儲存能量，作為暫時的電壓源或電流源，可在短時間內產生大電流或電壓&lt;/li&gt;
&lt;li&gt;電容器反抗電壓的突然改變、電感器反抗電流的突然改變&lt;/li&gt;
&lt;li&gt;電容器和電感器對頻率很靈敏，可以區別不同頻率，這條用在交流電路中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;積分器-integrator&#34;&gt;積分器 (Integrator)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;採用儲能元件的運算放大器組成的積分器，輸出訊號和輸入訊號的積分成正比
&lt;ul&gt;
&lt;li&gt;$v_0=-\frac{1}{RC}\int_0^tv_i(\tau)d\tau$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;微分器-differentiator&#34;&gt;微分器 (Differentiator)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;採用儲能元件的運算放大器組成的微分器，輸出訊號和輸入訊號的變率成正比
&lt;ul&gt;
&lt;li&gt;$v_0=-RC\frac{dv_i}{dt}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;類比計算機-analog-computer&#34;&gt;類比計算機 (Analog Computer)&lt;/h4&gt;
&lt;p&gt;由各種運算放大器綜合使用，可算出任意微分方程式&lt;/p&gt;
</description>
        </item>
        <item>
        <title>STM32 Timer / Counter 介紹</title>
        <link>https://roykesydon.github.io/Blog/p/stm32-timer-/-counter-%E4%BB%8B%E7%B4%B9/</link>
        <pubDate>Thu, 04 May 2023 01:32:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/stm32-timer-/-counter-%E4%BB%8B%E7%B4%B9/</guid>
        <description>&lt;h2 id=&#34;簡介&#34;&gt;簡介&lt;/h2&gt;
&lt;p&gt;Timer 和 Counter 的差別是 Timer 是定期的數數&lt;/p&gt;
&lt;h2 id=&#34;timing-functions&#34;&gt;Timing functions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定期對 CPU 發送 interrupt&lt;/li&gt;
&lt;li&gt;產生準確時間的 delay&lt;/li&gt;
&lt;li&gt;產生 pulses 或 periodic waveforms
&lt;ul&gt;
&lt;li&gt;PWM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;量測 duration&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stm32-timer--counter&#34;&gt;STM32 Timer / Counter&lt;/h2&gt;
&lt;p&gt;從 Basic 到 Advanced，追加更多功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Basic TImer (Simple Timer)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;16 bit auto-reload register&lt;/li&gt;
&lt;li&gt;programmable pre-scaler&lt;/li&gt;
&lt;li&gt;可以 output 到 DAC&lt;/li&gt;
&lt;li&gt;update event
&lt;ul&gt;
&lt;li&gt;CNT=ARR(up-count)&lt;/li&gt;
&lt;li&gt;CNT=0 (down-count)&lt;/li&gt;
&lt;li&gt;reset CNT to 0 or ARR&lt;/li&gt;
&lt;li&gt;set UIF flag in status register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;update event interrupt
&lt;ul&gt;
&lt;li&gt;如果 enabled (UIE=1)&lt;/li&gt;
&lt;li&gt;UIF 被設置的時候發送訊號&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-timer/rm-fig-367.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-timer/rm-fig-370.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$T_{EVENT}=Prescale \times Count \times T_{CK \_ INT} \\
=(PSC+1)\times(ARR+1)\times T_{CK \_ INT}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$T_{EVENT}$ 是兩次事件發生的間隔時間&lt;/li&gt;
&lt;li&gt;PSC 是設定 (數值 - 1)，所以 Prescale 是 1 的話，要設 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Control register&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CEN
&lt;ul&gt;
&lt;li&gt;是否啟用 counter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDIS
&lt;ul&gt;
&lt;li&gt;是否啟用 update event&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;URS
&lt;ul&gt;
&lt;li&gt;設定產生 update event 的 source&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OPM
&lt;ul&gt;
&lt;li&gt;是否只算一次 counter 就停&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ARPE
&lt;ul&gt;
&lt;li&gt;關於中途改 ARR 的 reload 設定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UIF
&lt;ul&gt;
&lt;li&gt;interrupt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;General Purpose Timer&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-timer/rm-fig-284.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;16-bit or 32-bit auto-reload register&lt;/li&gt;
&lt;li&gt;use for a variety of puposes
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;measuring lengths of input signals (Input Capture)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input Capture
&lt;ul&gt;
&lt;li&gt;測量 pulse width (高電位的時間) 或 period (一個週長)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;generating output waveforms (Output Compare and PWM Generation)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one pulse mode output&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Up to 4 independent channel&lt;/li&gt;
&lt;li&gt;Interrupt / DMA generation
&lt;ul&gt;
&lt;li&gt;event
&lt;ul&gt;
&lt;li&gt;counter overflow / underflow&lt;/li&gt;
&lt;li&gt;counter initialization&lt;/li&gt;
&lt;li&gt;trigger event&lt;/li&gt;
&lt;li&gt;input capture&lt;/li&gt;
&lt;li&gt;output compare&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Advanced Control Timer&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;16-bit auto-reload register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊 timer&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;low power timer
&lt;ul&gt;
&lt;li&gt;可以用在比如睡眠狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;補充&#34;&gt;補充&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;24 bits system timer (SysTick)&lt;/li&gt;
&lt;li&gt;reload
&lt;ul&gt;
&lt;li&gt;在 overflow 時回到 register 設定的數值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;stm32-timer-差異&#34;&gt;STM32 Timer 差異&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以去 Datasheet 找每個 Timer 的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Counter resolution&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;16/32 bit&lt;/li&gt;
&lt;li&gt;決定能從 0 數到多少個&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Counter Type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;決定能往上數或往下數或都可以&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Prescaler factor&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以把進來的數字先除以某個數，減緩速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DMA request generation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能否用 DMA access 記憶體&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Capture / Compare channels&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一個 Timer 可能可以發多個訊號出去，並且經過多個 Compare register，比對不同 event&lt;/li&gt;
&lt;li&gt;functions
&lt;ul&gt;
&lt;li&gt;Compare
&lt;ul&gt;
&lt;li&gt;和比對 register，比到了就送 event&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Capture
&lt;ul&gt;
&lt;li&gt;紀錄下 channel 的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Complementary output&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些馬達控制需要反向波，就要這個&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Max interface clock (MHz) and Max timer clock (MHz)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;進去和出來的速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;system-clock---clock-tree&#34;&gt;System Clock - Clock tree&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Timer 源頭就是 clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有四種來源幫忙驅動 system clock (SYSCLK)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HSI16 (high speed internal)
&lt;ul&gt;
&lt;li&gt;16 MHz RC oscillator clock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSI (multispeed internal)
&lt;ul&gt;
&lt;li&gt;RC oscillator clock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HSE (high speed external)
&lt;ul&gt;
&lt;li&gt;oscillator clock, from 4 to 48 MHz&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PLL clock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYSCLK 往下接到 AHB，再接到 APB1、APB2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;flash-read-access-latency&#34;&gt;Flash Read Access Latency&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;調整 clock 也要調整這部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;register&#34;&gt;Register&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TIMx_CR1
&lt;ul&gt;
&lt;li&gt;control register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TIMx_PSC
&lt;ul&gt;
&lt;li&gt;設定 prescale&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TIMx_ARR
&lt;ul&gt;
&lt;li&gt;auto-reload register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>STM32 GPIO 介紹</title>
        <link>https://roykesydon.github.io/Blog/p/stm32-gpio-%E4%BB%8B%E7%B4%B9/</link>
        <pubDate>Wed, 26 Apr 2023 01:32:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/stm32-gpio-%E4%BB%8B%E7%B4%B9/</guid>
        <description>&lt;h2 id=&#34;memory-map&#34;&gt;Memory Map&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU 對 I/O 操作方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Port I/O
&lt;ul&gt;
&lt;li&gt;用特殊 CPU 指令&lt;/li&gt;
&lt;li&gt;I/O 設備和記憶體不共享地址空間&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memory-Mapped I/O
&lt;ul&gt;
&lt;li&gt;I/O 設備和記憶體共享地址空間&lt;/li&gt;
&lt;li&gt;像一般控制記憶體&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;這塊記憶體具有四個責任&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command&lt;/li&gt;
&lt;li&gt;Status&lt;/li&gt;
&lt;li&gt;Output Data&lt;/li&gt;
&lt;li&gt;Input Data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gpio-結構&#34;&gt;GPIO 結構&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/gpio-structure.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPIO mode
&lt;ul&gt;
&lt;li&gt;Open-Drain
&lt;ul&gt;
&lt;li&gt;由外部電壓決定輸出電壓&lt;/li&gt;
&lt;li&gt;Output Register 是 0 會啟用 N-MOS，1 的話靠外部電壓推
&lt;ul&gt;
&lt;li&gt;好處是外部電壓可以自己決定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Push-Pull
&lt;ul&gt;
&lt;li&gt;由內部電壓決定輸出電壓&lt;/li&gt;
&lt;li&gt;Output Register 是 0 或 1 會決定啟用 N-MOS 或是 P-MOS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有關-register&#34;&gt;有關 Register&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Clock enable register
&lt;ul&gt;
&lt;li&gt;AHB2 peripheral clock enable regisetr (RCC_AHB2ENR)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Control register
&lt;ul&gt;
&lt;li&gt;GPIO port mode register&lt;/li&gt;
&lt;li&gt;GPIO port output type register&lt;/li&gt;
&lt;li&gt;GPIO port output speed register&lt;/li&gt;
&lt;li&gt;GPIO port pull-up/pull-down register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data register
&lt;ul&gt;
&lt;li&gt;Output&lt;/li&gt;
&lt;li&gt;Input&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用-gpio&#34;&gt;使用 GPIO&lt;/h2&gt;
&lt;p&gt;先去 Memory map 找 Boudary address&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/gpio-structure.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;根據 table 確認要設置的數值&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/table-39-1.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/table-39-2.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;設定 RCC enable&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/rcc-en.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;把上面說的各種 Control register 設定好&lt;/p&gt;
&lt;p&gt;比如 PUPDR
&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/PUPDR.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BSRR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改 ODR 會一次改到整個 GPIO port，若只要改某個 pin，可以用 BSRR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delay&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 4 MHz
&lt;ul&gt;
&lt;li&gt;1 cycle = 0.25$\mu$S&lt;/li&gt;
&lt;li&gt;可以查每個組合語言指令要幾個 cycle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械按鈕會有 Bouncing&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Debounce
&lt;ul&gt;
&lt;li&gt;Hardware method
&lt;ul&gt;
&lt;li&gt;加上濾波電容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Software method
&lt;ul&gt;
&lt;li&gt;讀取後等待一段時間才再次讀取&lt;/li&gt;
&lt;li&gt;連續讀取 N 次，看數值是否穩定改變&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-segment&#34;&gt;7-Segment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;COM 分共陽、共陰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8 個七段顯示器就要吃掉 8 * 8 個 GPIO 接腳，可以每次只顯示一個，那只需要 8 個 GPIO 接腳，快速閃過&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可用 Max 7219 控制，他有三個輸入 DIN、LOAD、CLK&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DIN 輸入資料&lt;/li&gt;
&lt;li&gt;CLK 上升的時候採樣，最多 10 MHz&lt;/li&gt;
&lt;li&gt;LOAD(CS) 採用最後輸進去的 16 bits
&lt;ul&gt;
&lt;li&gt;最早的是 MSB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>電路學 - II</title>
        <link>https://roykesydon.github.io/Blog/p/%E9%9B%BB%E8%B7%AF%E5%AD%B8-ii/</link>
        <pubDate>Mon, 10 Apr 2023 00:00:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/%E9%9B%BB%E8%B7%AF%E5%AD%B8-ii/</guid>
        <description>&lt;h2 id=&#34;分析方法&#34;&gt;分析方法&lt;/h2&gt;
&lt;h3 id=&#34;節點分析-nodal-analysis&#34;&gt;節點分析 (Nodal Analysis)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;解節點電壓
&lt;ol&gt;
&lt;li&gt;選取一個節點做為參考節點 (reference node) 或已知節點 (datum node)，其他節點的電壓相對於它
&lt;ul&gt;
&lt;li&gt;假設它電位為 0，稱為 ground&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把 KCL 用在剩下的 n-1 個參考節點 (假設電流方向，可以隨便假設，只要一致，不要兩端電流都流入同個電阻)&lt;/li&gt;
&lt;li&gt;求解聯立方程式，得到各節點電壓&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;包含電壓源的節點分析-nodal-analysis-with-voltage-sources&#34;&gt;包含電壓源的節點分析 (Nodal Analysis with Voltage Sources)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果電壓源連接於兩個非參考節點間，可以把電壓源和這兩個節點和與其並聯的元件看做一個超節點 (supernode) 或廣義節點 (generalized node)，解決無法知道流過電壓源的電流的問題
&lt;ul&gt;
&lt;li&gt;超節點的屬性
&lt;ul&gt;
&lt;li&gt;超節點內部的電壓源提供限制方程式&lt;/li&gt;
&lt;li&gt;超節點本身沒電壓&lt;/li&gt;
&lt;li&gt;超節點要同時用 KCL 和 KVL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;網目分析-mesh-analysis&#34;&gt;網目分析 (Mesh Analysis)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只能適用平面電路 (planer circuit)，不能用在非平面電路 (nonplaner circuit)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一個平面上沒有交互連接的分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;網目 (Mesh)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不包含子迴路的單一迴路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;網目電流 (mesh current)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流經網目的電流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;決定網目電流步驟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 n 個網目中，指定 n 個網目電流&lt;/li&gt;
&lt;li&gt;對 n 個網目個別應用 KVL，把歐姆定律應用在網目電流上，以表示電壓&lt;/li&gt;
&lt;li&gt;求解 n 個聯立方程式，計算網目電流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;包含電流源的網目分析-mesh-analysis-with-current-sources&#34;&gt;包含電流源的網目分析 (Mesh Analysis with Current Sources)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果有兩個 Mesh 共用同一個電流源，會形成超網目 (supermesh)，把公用的電流源還有串聯的元件給移除掉&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;視察法&#34;&gt;視察法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;待補&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;節點分析-vs-網目分析&#34;&gt;節點分析 vs 網目分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;節點比網目少選節點分析，反之也是&lt;/li&gt;
&lt;li&gt;要求電壓節點，求電流網目&lt;/li&gt;
&lt;li&gt;可以用一種驗證另一種的結果&lt;/li&gt;
&lt;li&gt;有些特殊問題只能用其中一種方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;直流電晶體電路&#34;&gt;直流電晶體電路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;電子產品中的基本元件有三端主動元件&amp;ndash;電晶體 (transistor)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;種類
&lt;ul&gt;
&lt;li&gt;雙極性接面電晶體 (biopolar junction transistor, BJT)
&lt;ul&gt;
&lt;li&gt;本節只討論這種&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;場效電晶體 (field-effect transistor, FET)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BJT 類型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NPN&lt;/li&gt;
&lt;li&gt;PNP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Part&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;射極 (emitter, E)&lt;/li&gt;
&lt;li&gt;基極 (base, B)&lt;/li&gt;
&lt;li&gt;集極 (collector, C)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用
&lt;ul&gt;
&lt;li&gt;$I_C=\alpha I_E$
&lt;ul&gt;
&lt;li&gt;$\alpha$ 是共基極電流增益 (common-base current gain)，表示射極注入的電子被基極收集的比例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$I_C=\beta I_B$
&lt;ul&gt;
&lt;li&gt;$\beta$ 是共射極電流增益 (common-emitter current gain)&lt;/li&gt;
&lt;li&gt;$I_E=(1+\beta) I_B$&lt;/li&gt;
&lt;li&gt;$\beta=\frac{\alpha}{1-\alpha}$&lt;/li&gt;
&lt;li&gt;因為 $\beta$ 很大，一個小的基極電流可以控制大電流的輸出，因此，雙極性電晶體可以當作放大器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;截止&lt;/li&gt;
&lt;li&gt;飽和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;電路理論&#34;&gt;電路理論&lt;/h2&gt;
&lt;h3 id=&#34;線性性質-linear-property&#34;&gt;線性性質 (Linear Property)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;線性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;齊次性
&lt;ul&gt;
&lt;li&gt;輸入 ( 激發 excitation) 乘以一個常數，輸出 ( 響應 response) 也會乘以相同的常數&lt;/li&gt;
&lt;li&gt;$kiR=kv$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可加性
&lt;ul&gt;
&lt;li&gt;輸入總和的 response 等於個別輸入的 response 的總和&lt;/li&gt;
&lt;li&gt;$v=(i_1+i_2)R=i_1R+i_2R=v_1+v_2$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此稱電阻是一個線性元件，因為電阻、電壓、電流的關係滿足齊次性和可加性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果電路滿足可加性和齊次性，稱此電路為線性電路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;線性電路是輸出與輸入為線性關係的電路&lt;/li&gt;
&lt;li&gt;組成
&lt;ul&gt;
&lt;li&gt;線性元件&lt;/li&gt;
&lt;li&gt;線性相依電源&lt;/li&gt;
&lt;li&gt;獨立電源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重疊-superposition&#34;&gt;重疊 (Superposition)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有兩個或更多的獨立電源時，除了節點和網目分析，可以求各獨立源對變數的貢獻，最後相加起來，這就是重疊&lt;/li&gt;
&lt;li&gt;重疊定理
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在一個線性電路中，跨接於元件上的電壓(流經元件的電流) = 每個獨立電源單獨作用於該元件二端的電壓(單獨流經該元件的電流)的代數和&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意事項&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一時間只考慮一個獨立電源，把其他的電壓源當作 0 V(短路)、電流源當作 0 A(開路)&lt;/li&gt;
&lt;li&gt;相依電源受電路變數控制，保持不變&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保留一個獨立電源，算它的輸出(電壓或電流)&lt;/li&gt;
&lt;li&gt;對每個電源做步驟 1&lt;/li&gt;
&lt;li&gt;把每個獨立電源的貢獻相加&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電源變換-source-transformation&#34;&gt;電源變換 (Source Transformation)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把電阻並聯的電流源和電阻串聯的電壓源做轉換(或反過來)
&lt;ul&gt;
&lt;li&gt;電源變換條件
&lt;ul&gt;
&lt;li&gt;$V_s=i_sR$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;也是用相依電源，但也要遵守條件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;戴維寧定理-thevenins-theorem&#34;&gt;戴維寧定理 (Thevenin&amp;rsquo;s Theorem)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常有一種情境，電路種有一個特殊的元件是可變的，又稱負載 (load)，比如插座可能連接不同家電所組成的負載，而每當 load 改變，就要重新分析電路。戴維寧定理可以把固定的部分換成一個等效電路&lt;/li&gt;
&lt;li&gt;戴維寧定理
&lt;ul&gt;
&lt;li&gt;線性二端電路可被由電壓源 $V_{Th}$ 和電阻 $R_{Th}$ 串聯所組成的戴維寧等效電路 (Thevenin equivalent circuit) 取代
&lt;ul&gt;
&lt;li&gt;$V_{Th}$ 是二端的開路電壓&lt;/li&gt;
&lt;li&gt;$R_{Th}$ 是關閉獨立電源後，端點上的輸入或等效電阻
&lt;ul&gt;
&lt;li&gt;關閉所有獨立電源(根據 電壓/電流 來 短路/開路)，但考慮相依電源&lt;/li&gt;
&lt;li&gt;$R_{Th}$ 有可能求出負值，這代表該電路提供功率，裡面有相依電源，雖然不可能出現在被動元件上，但等效電路是主動元件&lt;/li&gt;
&lt;li&gt;假設外接一個電壓源，求外面的 v 和 i 即可算出 $R_{Th}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;諾頓定理-nortons-theorem&#34;&gt;諾頓定理 (Norton&amp;rsquo;s Theorem)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和戴維寧定理很像，但是等效電路改成電流源和並聯的電阻，實際上，根據電源變換，可以知道諾頓定理和戴維寧定理的等效電阻相等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$R_N=R_{Th}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$I_N=\frac{V_{Th}}{R_{Th}}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;計算戴維寧或諾頓等效電路，要先求 $v_{oc}$、$i_{sc}$、$R_{in}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;求出兩個就可以算第三個&lt;/li&gt;
&lt;li&gt;$V_{Th}=v_{oc}$
&lt;ul&gt;
&lt;li&gt;$v_{oc}$ 是 a 和 b 兩端的開路電壓&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$I_N=i_{sc}$
&lt;ul&gt;
&lt;li&gt;$i_{sc}$ 是 a 和 b 兩端的短路電流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$R_{Th}=\frac{v_{oc}}{i_{sc}}=R_N$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;最大功率轉移-maximum-power-transfer&#34;&gt;最大功率轉移 (Maximum Power Transfer)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;轉移到 load 的功率是
&lt;ul&gt;
&lt;li&gt;$p=i^2R_{L}=(\frac{V_{Th}}{R_{Th}+R_L})^2R_L$&lt;/li&gt;
&lt;li&gt;最大值出現在 $R_L=R_{Th}$
&lt;ul&gt;
&lt;li&gt;最大功率定理 (maximum power theorem)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$p_{max}=\frac{V_{Th}^2}{4R_{Th}}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電源建模-source-modeling&#34;&gt;電源建模 (Source Modeling)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;實際的電源非理想電源
&lt;ul&gt;
&lt;li&gt;電壓源有串聯的內部電阻 (internal resistance)
&lt;ul&gt;
&lt;li&gt;下面稱為 $R_s$&lt;/li&gt;
&lt;li&gt;要理想要趨近於 0&lt;/li&gt;
&lt;li&gt;若不連接 load (開路)，$v_{oc}=v_s$
&lt;ul&gt;
&lt;li&gt;$v_s$ 可以看做無負載源電壓 (unloaded source voltage)，連接 load 會使端電壓下降，這就是負載效應 (loading effect)&lt;/li&gt;
&lt;li&gt;$R_L$ 越大會越接近理想電壓&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;量測 $v_s$ 和內部電阻
&lt;ul&gt;
&lt;li&gt;量開路電壓
&lt;ul&gt;
&lt;li&gt;$v_s=v_{oc}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;load 端連接可變電阻，調到 $v_L=v_{oc}/2$&lt;/li&gt;
&lt;li&gt;此時 $R_L=R_{Th}=R_s$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;電流源有並聯的電源電阻 (source resistance)
&lt;ul&gt;
&lt;li&gt;要理想要趨近於無窮大&lt;/li&gt;
&lt;li&gt;$R_L$ 越小越接近理想電源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電阻量測-resistance-measurement&#34;&gt;電阻量測 (Resistance Measurement)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;惠斯登電橋 (Wheatstone bridge)
&lt;ul&gt;
&lt;li&gt;平衡電橋 (balanced bridge)&lt;/li&gt;
&lt;li&gt;非平衡電橋 (unbalanced bridge)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>STM32 UART 實驗</title>
        <link>https://roykesydon.github.io/Blog/p/stm32-uart-%E5%AF%A6%E9%A9%97/</link>
        <pubDate>Sun, 09 Apr 2023 01:32:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/stm32-uart-%E5%AF%A6%E9%A9%97/</guid>
        <description>&lt;h2 id=&#34;介紹&#34;&gt;介紹&lt;/h2&gt;
&lt;p&gt;試用 STM32 UART 功能&lt;/p&gt;
&lt;p&gt;會透過 RealTerm 和 STM32L476RG 溝通，並用 DMA 接收訊息&lt;/p&gt;
&lt;p&gt;根據 User manual，USART2 預設會連接 ST-LINK，要連接外部設備的話要修改 solder bridge&lt;/p&gt;
&lt;h2 id=&#34;ioc-設置&#34;&gt;ioc 設置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Connectivity 可以設置 USART2&lt;/li&gt;
&lt;li&gt;mode 從 disable 改選 Asynchronous&lt;/li&gt;
&lt;li&gt;Parameters Settings 可以設置各種資訊
&lt;ul&gt;
&lt;li&gt;Baud Rate&lt;/li&gt;
&lt;li&gt;Word Length&lt;/li&gt;
&lt;li&gt;Parity&lt;/li&gt;
&lt;li&gt;Stop Bits&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DMA Setting
&lt;ul&gt;
&lt;li&gt;Add 一個 RX
&lt;ul&gt;
&lt;li&gt;Mode 改成 circular，並打開 memory 的 increment address
&lt;ul&gt;
&lt;li&gt;increment address 是因為資料是用 array 存&lt;/li&gt;
&lt;li&gt;circular 是當資料滿了後，會回到 zero position&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NVIC Setting
&lt;ul&gt;
&lt;li&gt;設置 DMA 應該就會自動設置一個 interrupt，檢查一下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;程式碼&#34;&gt;程式碼&lt;/h2&gt;
&lt;p&gt;發送&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myTxData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\r\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;HAL_UART_Transmit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;huart2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myTxData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;接收&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;UART_HandleTypeDef&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;huart2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// generated code
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myRxData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;HAL_UART_Receive_DMA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;huart2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myRxData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 在 Init 後，在 main 中執行一次就好
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;interrupt&lt;/p&gt;
&lt;p&gt;在 hal_uart.c 有&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;__weak&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_UART_RxCpltCallback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UART_HandleTypeDef&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;huart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* Prevent unused argument(s) compilation warning */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;UNUSED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;huart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* NOTE : This function should not be modified, when the callback is needed,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;            the HAL_UART_RxCpltCallback can be implemented in the user file.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;當 DMA 滿了就會呼叫這個 function&lt;/p&gt;
&lt;h2 id=&#34;實驗&#34;&gt;實驗&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_UART_RxCpltCallback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UART_HandleTypeDef&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;huart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* Prevent unused argument(s) compilation warning */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;UNUSED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;huart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* NOTE : This function should not be modified, when the callback is needed,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;            the HAL_UART_RxCpltCallback can be implemented in the user file.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;HAL_UART_Transmit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;huart2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myRxData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;當 20 個 Bytes 儲存滿了就回傳資訊給電腦&lt;/p&gt;
&lt;h3 id=&#34;realterm&#34;&gt;RealTerm&lt;/h3&gt;
&lt;h4 id=&#34;display&#34;&gt;Display&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;勾選 Half Duplex
&lt;ul&gt;
&lt;li&gt;發送的訊息會顯示綠色，接收的是黃色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;port&#34;&gt;Port&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;設置 Baud 和其他有的沒的&lt;/li&gt;
&lt;li&gt;選 open&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;send&#34;&gt;Send&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;EOL 可以勾選 CRLF&lt;/li&gt;
&lt;li&gt;打一些文字後按 Send ASCII&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;結果&#34;&gt;結果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-uart/result.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Roykesydon/STM32-Playground/tree/main/STM32-UART/uart_test&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程式碼&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>電路學 - I</title>
        <link>https://roykesydon.github.io/Blog/p/%E9%9B%BB%E8%B7%AF%E5%AD%B8-i/</link>
        <pubDate>Sun, 09 Apr 2023 00:00:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/%E9%9B%BB%E8%B7%AF%E5%AD%B8-i/</guid>
        <description>&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;h3 id=&#34;常見名詞&#34;&gt;常見名詞&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;電路 (electric circuit)&lt;/li&gt;
&lt;li&gt;元件 (element)
&lt;ul&gt;
&lt;li&gt;電路組成的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;單位系統&#34;&gt;單位系統&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;國際單位制 (International System of Units ,SI)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電荷與電流&#34;&gt;電荷與電流&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;電荷 (electric charge)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;組成原子的基本物質&lt;/li&gt;
&lt;li&gt;庫倫 (C)&lt;/li&gt;
&lt;li&gt;電荷守恆定律 (law of conservation of charge)
&lt;ul&gt;
&lt;li&gt;電荷不能被創造、破壞，只能轉移，系統中的電荷總數不變。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;電流 (electric current)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;電荷的時間變化率&lt;/li&gt;
&lt;li&gt;電流是電荷的移動，而且有方向性&lt;/li&gt;
&lt;li&gt;安培 (A)&lt;/li&gt;
&lt;li&gt;公式
&lt;ul&gt;
&lt;li&gt;$i \triangleq \frac{dq}{dt}$&lt;/li&gt;
&lt;li&gt;$Q \triangleq \int_{t_0}^{t}i\text{ }dt$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直流電 (direct current, dc)
&lt;ul&gt;
&lt;li&gt;恆定常數的電流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交流電 (alternating current, ac)
&lt;ul&gt;
&lt;li&gt;隨著時間以正弦波變化的電流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電壓&#34;&gt;電壓&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;電動勢 (electromotive force, emf)
&lt;ul&gt;
&lt;li&gt;驅動導體內的電子往某方向移動&lt;/li&gt;
&lt;li&gt;電壓 (voltage)、電位差 (potential difference)&lt;/li&gt;
&lt;li&gt;伏特 (V)&lt;/li&gt;
&lt;li&gt;$v_{ab}\triangleq\frac{dw}{dq}$
&lt;ul&gt;
&lt;li&gt;單位電荷從 b 移動到 a 需要做的功&lt;/li&gt;
&lt;li&gt;$w$ 是能量，單位是焦耳(J)&lt;/li&gt;
&lt;li&gt;$q$ 是電荷，單位是庫倫(C)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;壓降 (voltage drop)、壓升 (voltage rise)&lt;/li&gt;
&lt;li&gt;直流電壓 (dc voltage)、交流電壓 (ac voltage)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;功率與能量&#34;&gt;功率與能量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消耗或吸收能量的時間變化率，單位是瓦特(walt, W)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$p \triangleq\frac{dw}{dt}$&lt;/li&gt;
&lt;li&gt;$p=iv$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被動符號規則 (passive sign convention)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;電流從電壓的正極流入元件 ($p=+vi$)，表示該元件吸收功率&lt;/li&gt;
&lt;li&gt;電流從電壓的正極流出元件 ($p=-vi$)，表示該元件供應功率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能量守恆定律 (law of conservation of energy)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;電路中任何時刻的功率總和為 0&lt;/li&gt;
&lt;li&gt;$\sum p=0$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;電路元件&#34;&gt;電路元件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;被動元件 (passive element)
&lt;ul&gt;
&lt;li&gt;不具備產生能量的能力&lt;/li&gt;
&lt;li&gt;電阻器 (resistor)、電容器 (capacitor)、電感器 (inductor)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主動元件 (active element)
&lt;ul&gt;
&lt;li&gt;具備產生能量的能力&lt;/li&gt;
&lt;li&gt;發電機 (generator)、電池 (battery)、運算放大器 (operational amplifier)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;電源&#34;&gt;電源&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;電壓源、電流源
&lt;ul&gt;
&lt;li&gt;提供穩定電壓產生電流、提供穩定電流產生電壓&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;獨立電源
&lt;ul&gt;
&lt;li&gt;獨立電源提供指定電壓或電流的主動元件，與電路中其他元件無關。&lt;/li&gt;
&lt;li&gt;電池和發電機可被當作近似理想的電壓源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相依電源
&lt;ul&gt;
&lt;li&gt;提供的電壓或電流受另一個電流或電壓控制的主動元件&lt;/li&gt;
&lt;li&gt;類型
&lt;ul&gt;
&lt;li&gt;電壓控制電壓源 (voltage-controlled voltage source, VCVS)&lt;/li&gt;
&lt;li&gt;電流控制電壓源 (current-controlled voltage source, CCVS)&lt;/li&gt;
&lt;li&gt;電壓控制電流源 (voltage-controlled current source, VCCS)&lt;/li&gt;
&lt;li&gt;電流控制電流源 (current-controlled current source, CCCS)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本定律&#34;&gt;基本定律&lt;/h2&gt;
&lt;h3 id=&#34;歐姆定律-ohms-law&#34;&gt;歐姆定律 (Ohm&amp;rsquo;s Law)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一般材料具備阻止電荷流通的特性，稱為電阻 (resistance)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;均勻截面積下，$R=\rho \frac{l}{A}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\rho$ 是材料的電阻率 (resistivity)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;電路中抑制電流的材料稱為電阻器 (resistor)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$v=iR$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;短路 (short circuit)、開路 (open circuit)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短路: 電壓是 0，電流可能是任意值，電阻值接近 0&lt;/li&gt;
&lt;li&gt;開路: 電壓可能是任意值，電流是 0，電阻值接近無限大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固定電阻、可變電阻&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻值可調與否&lt;/li&gt;
&lt;li&gt;常用的可變電阻是電位器 (potentiometer)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是所有電阻都遵守歐姆定律&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵守歐姆定律的稱為線性電阻 (linear resistor)，反之則為非線性電阻 (nonlinear resistor)，阻值隨電流變化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;電導 (conductance)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;電阻 R 的倒數&lt;/li&gt;
&lt;li&gt;元件導通電流的能力&lt;/li&gt;
&lt;li&gt;$G=\frac{1}{R}=\frac{i}{v}$&lt;/li&gt;
&lt;li&gt;單位姆歐 (mho, $\mho$) 或西門子 (siemens, S)&lt;/li&gt;
&lt;li&gt;$1 S = 1 \mho = 1 A/V$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;node-branches-and-loops&#34;&gt;Node, Branches, and Loops&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分枝 (Branch)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意的兩端元件，比如電壓源、電阻&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;節點 (Node)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指連接二個或多個分支的接點&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迴路 (Loop)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是電路中的任一封閉路徑&lt;/li&gt;
&lt;li&gt;從一個節點開始，經過一組節點，最後回到一開始的節點，途中每個節點只經過一次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;串聯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多個元件共享單一節點&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;並連&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多個元件連接到相同的兩個節點&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;獨立迴路 (independent loop)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至少包含一個不屬於其他獨立迴路的 branch&lt;/li&gt;
&lt;li&gt;$b=l+n-1$
&lt;ul&gt;
&lt;li&gt;b 是 branch，l 是獨立迴路，n 是 node&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;克希荷夫定律-kirchhoffs-laws&#34;&gt;克希荷夫定律 (Kirchhoff&amp;rsquo;s Laws)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kirchhoff&amp;rsquo;s current law (KCL)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流入任一 node 或封閉邊界的電流總和為 0
&lt;ul&gt;
&lt;li&gt;或是說流入某一節點的電流和等於流出的電流和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\sum_{n=1}^{N}i_n=0$
&lt;ul&gt;
&lt;li&gt;$N$ 是連到 node 的 branch 數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kirchhoff&amp;rsquo;s voltage law (KVL)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一條封閉路徑(或迴路)中的電壓總和為零
&lt;ul&gt;
&lt;li&gt;或是說 voltage drop 的總和 = voltage rise 的總和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$\sum_{m=1}^{M}n_m=0$
&lt;ul&gt;
&lt;li&gt;$M$ 是迴路中的 branch 數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;串並聯電阻&#34;&gt;串並聯電阻&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;串聯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$R_{eq}=\sum_{n=1}^N R_n$
&lt;ul&gt;
&lt;li&gt;$R_{eq}$ 是等效電阻 (equivalent resistance)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分壓定理 (principle of voltage division)
&lt;ul&gt;
&lt;li&gt;電壓和各電阻的阻值成正比，阻值越大，壓降越大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分壓器 (voltage divider)&lt;/li&gt;
&lt;li&gt;$v_1=\frac{R_1}{R_1+R_2}v$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;並聯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\frac{1}{R_{eq}}=\frac{1}{R_1}+\frac{1}{R_2}+&amp;hellip;+\frac{1}{R_N}$
&lt;ul&gt;
&lt;li&gt;$R_{eq}$ 永遠小於並聯電阻中最小的電阻值&lt;/li&gt;
&lt;li&gt;$G_{eq} = G_{1}+G_2+&amp;hellip;+G_N$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分流定理 (principle of current division)
&lt;ul&gt;
&lt;li&gt;各分支電流與電阻值成反比&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分流器 (current divider)&lt;/li&gt;
&lt;li&gt;$i_1=\frac{R_2}{R_1+R_2}i$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;y---delta-轉換-wye-delta-transformations&#34;&gt;Y - $\Delta$ 轉換 (Wye-Delta Transformations)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遇到電阻不是串聯也不是並聯的情況，要如何轉換&lt;/li&gt;
&lt;li&gt;有時候把 Y 型網路和 $\Delta$ 型網路相互轉換會比較好算&lt;/li&gt;
&lt;li&gt;Y 型網路 = T 型網路&lt;/li&gt;
&lt;li&gt;$\Delta$ 網路 = $\Pi$ 網路&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;delta---y-轉換-delta-to-wye-conversion&#34;&gt;$\Delta$ - Y 轉換 (Delta to Wye conversion)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Y 網路的每個電阻是 $\Delta$ 中的兩個相鄰電阻的相乘除以 $\Delta$ 中的三個電阻總和&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;y---delta-轉換-wye-to-delta-conversion&#34;&gt;Y - $\Delta$ 轉換 (Wye to Delta conversion)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\Delta$ 網路的每個電阻是 Y 中的兩兩電阻的相乘總和除以 Y 中的對角電阻&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平衡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;條件
&lt;ul&gt;
&lt;li&gt;$R_1=R_2=R_3=R_Y$&lt;/li&gt;
&lt;li&gt;$R_a=R_b=R_c=R_{\Delta}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結果
&lt;ul&gt;
&lt;li&gt;$R_Y=\frac{R_\Delta}{3}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>STM32 GPIO 實驗</title>
        <link>https://roykesydon.github.io/Blog/p/stm32-gpio-%E5%AF%A6%E9%A9%97/</link>
        <pubDate>Sun, 02 Apr 2023 01:32:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/stm32-gpio-%E5%AF%A6%E9%A9%97/</guid>
        <description>&lt;h2 id=&#34;目的&#34;&gt;目的&lt;/h2&gt;
&lt;p&gt;本文會試用 GPIO output / input / interrupt&lt;/p&gt;
&lt;h2 id=&#34;gpio-架構&#34;&gt;GPIO 架構&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/gpio-structure.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;output-介紹&#34;&gt;Output 介紹&lt;/h2&gt;
&lt;p&gt;在 ioc 那邊選個 pin，選 GPIO_Output&lt;/p&gt;
&lt;p&gt;在左邊欄位 System Core 選擇 GPIO&lt;/p&gt;
&lt;p&gt;有五個欄位可以設定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GPIO output level&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始電位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GPIO mode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push pull 和 open drain
&lt;ul&gt;
&lt;li&gt;位於架構圖下方那部分，push pull 可以用 PMOS 和 NMOS 來得到高低電位，open drain 會 disable PMOS，讓你可以在外面自己接上拉電阻&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GPIO Pull-up/Pull-down&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Maximum output speed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;User Label&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用完記得 ctrl+s 讓他 generate code&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*Configure GPIO pin : PtPin */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Pin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RED_LED_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Mode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_MODE_OUTPUT_PP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Pull&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_NOPULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_SPEED_FREQ_LOW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;HAL_GPIO_Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED_LED_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*Configure GPIO pin Output Level */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED_LED_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RED_LED_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_PIN_RESET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED_LED_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RED_LED_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_PIN_RESET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 低電位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED_LED_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RED_LED_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_PIN_SET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 高電位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HAL_Delay&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//等一秒
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HAL_GPIO_TogglePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED_LED_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RED_LED_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;根據架構圖左側，你可以透過修改 BSRR 來修改 ODR，達到修改輸出的效果，請見 Reference Manuals，實際上 &lt;code&gt;HAL_GPIO_WritePin&lt;/code&gt; 也是這樣實現的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_TypeDef&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIOx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_PinState&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PinState&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* Check the parameters */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;assert_param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IS_GPIO_PIN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;assert_param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IS_GPIO_PIN_ACTION&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PinState&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PinState&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_PIN_RESET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;GPIOx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BSRR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;GPIOx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BRR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;input-介紹&#34;&gt;Input 介紹&lt;/h2&gt;
&lt;p&gt;看架構圖上方，用 Schmitt trigger 取得高低電位資料，他有 upper threshold 和 lower threshold，而不是用 single threshold&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*Configure GPIO pin : PtPin */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Pin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GREEN_LED_INPUT_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Mode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_MODE_INPUT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Pull&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_NOPULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;HAL_GPIO_Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GREEN_LED_INPUT_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_InitStruct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;uint8_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;green_led_input&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_ReadPin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GREEN_LED_INPUT_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GREEN_LED_INPUT_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;interrupt&#34;&gt;Interrupt&lt;/h2&gt;
&lt;p&gt;ioc 選個 pin，設定 GPIO_EXTI，這邊我選 B1(PC13)，也就是開發版上的藍色按鈕&lt;/p&gt;
&lt;p&gt;可以選 GPIO mode，這邊選 Falling Edge Trigger，值得一提的是他的設計是上拉電阻，所以這樣不是放開後觸發，是按下後觸發。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/b1.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;ioc 的 System Core 的 NVIC 還要把 EXTI line[15:10] interrupts 給 enabled，然後 Code generation 打開 Generate IRQ handler，還有 Call HAL handler。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;stm32l4xx_it.c&lt;/code&gt; 裡，
現在會有&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;EXTI15_10_IRQHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* USER CODE BEGIN EXTI15_10_IRQn 0 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* USER CODE END EXTI15_10_IRQn 0 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_EXTI_IRQHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B1_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* USER CODE BEGIN EXTI15_10_IRQn 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* USER CODE END EXTI15_10_IRQn 1 */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;這兩行各別是因為我們剛剛開的功能生的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_EXTI_IRQHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* EXTI line interrupt detected */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;__HAL_GPIO_EXTI_GET_IT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x00u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;__HAL_GPIO_EXTI_CLEAR_IT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_EXTI_Callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;__weak&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_EXTI_Callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* Prevent unused argument(s) compilation warning */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;UNUSED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* NOTE: This function should not be modified, when the callback is needed,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;           the HAL_GPIO_EXTI_Callback could be implemented in the user file
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;   */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;__weak 代表有同名 function 的話，就會採用沒 __weak prefix 的&lt;/p&gt;
&lt;p&gt;所以我們可以在 gpio.c 放下面的程式碼&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_EXTI_Callback&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GPIO_Pin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B1_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prev_val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev_val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED_LED_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RED_LED_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_PIN_SET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;prev_val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;HAL_GPIO_WritePin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RED_LED_GPIO_Port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RED_LED_Pin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GPIO_PIN_RESET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;prev_val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;實驗&#34;&gt;實驗&lt;/h2&gt;
&lt;p&gt;設定兩個輸入，一個輸出，一個 interrupt&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;當按下按鈕時，切換紅色 LED 的亮滅，並且讓板子上的綠色 LED 輸出和紅色 LED 相反的結果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B1(PC13、藍色按鈕) 按下去的時候，會發出 interrupt，並讓 RED_LED(PC10) 輸出和上次相反的電位，讓麵包版上的紅色 LED 亮滅，正極那邊接一條杜邦線給 GREEN_LED_INPUT (PC12)，並且 LD2(PA5、板子上的綠色 LED) 會輸出和紅色 LED 相反的結果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/result1.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32-gpio/result2.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Roykesydon/STM32-Playground/tree/main/STM32-GPIO/gpio_testing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程式碼&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>STM32CubeIDE 基本開發使用</title>
        <link>https://roykesydon.github.io/Blog/p/stm32cubeide-%E5%9F%BA%E6%9C%AC%E9%96%8B%E7%99%BC%E4%BD%BF%E7%94%A8/</link>
        <pubDate>Sun, 02 Apr 2023 00:32:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/stm32cubeide-%E5%9F%BA%E6%9C%AC%E9%96%8B%E7%99%BC%E4%BD%BF%E7%94%A8/</guid>
        <description>&lt;h2 id=&#34;使用的板子&#34;&gt;使用的板子&lt;/h2&gt;
&lt;p&gt;STM32L476RG&lt;/p&gt;
&lt;h2 id=&#34;開發文件&#34;&gt;開發文件&lt;/h2&gt;
&lt;p&gt;開發前需要先去 ST 官網，根據你的板子載四個重要文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Datasheet


        &lt;embed src=&#34;https://roykesydon.github.io/Blog/Blog/pdf/embedding/stm32cubeide/block-diagram.pdf&#34; type=&#34;application/pdf&#34; style=&#34;width:100%;height:50vh&#34;&gt;
    
上圖是其中的 block diagram&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reference Manuals&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Programming Manuals&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Schematic&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32cubeide/IMG_2389.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;創建-project&#34;&gt;創建 project&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;File -&amp;gt; New -&amp;gt; STM32 Project&lt;/li&gt;
&lt;li&gt;Board Selector 搜索 NUCLEO-L476RG，選取並 Next&lt;/li&gt;
&lt;li&gt;設置 Project Name，其他不動，Next&lt;/li&gt;
&lt;li&gt;Copy only the necessary library files，Finish&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ioc&#34;&gt;ioc&lt;/h2&gt;
&lt;p&gt;專案會有個 .ioc 檔，可以透過 GUI 生成設定 pin 的程式碼&lt;/p&gt;
&lt;p&gt;建議 Project Manager 的 Code Generator 勾選 Generate peripheral initialization as a pair &amp;lsquo;.c/.h&amp;rsquo; files per peripheral，開發起來比較方便&lt;/p&gt;
&lt;h2 id=&#34;compile&#34;&gt;Compile&lt;/h2&gt;
&lt;p&gt;點選上面的 hammer&lt;/p&gt;
&lt;h2 id=&#34;clock-configuration&#34;&gt;Clock Configuration&lt;/h2&gt;
&lt;p&gt;ioc 那邊還可以設置 clock&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;External clock
&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32cubeide/ex-clock.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;LSE 和 HSE 是 (Low / High Speed External)，你有 oscillator 的話可以自己弄&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://roykesydon.github.io/Blog/Blog/images/embedding/stm32cubeide/sys-peripheral.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;你可以調 sysclk 或 peripheral clock&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;programming&#34;&gt;Programming&lt;/h2&gt;
&lt;p&gt;在 USER CODE section 寫上程式碼&lt;/p&gt;
&lt;p&gt;選取的部分可以按 F3，看他是從哪邊來的，或看 macro 之類的&lt;/p&gt;
&lt;h2 id=&#34;debug&#34;&gt;DEBUG&lt;/h2&gt;
&lt;p&gt;上面有個 BUG 符號的東西，旁邊的箭頭可以用 DEBUG 的設定&lt;/p&gt;
&lt;p&gt;又建 STM32 C/C++ Application，可以 New 新設定&lt;/p&gt;
&lt;p&gt;C/C++ Application 那邊選你 compile 的 elf 檔&lt;/p&gt;
&lt;p&gt;Debugger 開啟 ST-LINK S/N，並且掃描，如果你的電腦有接上 MCU，應該會直接找到&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ARM 組合語言介紹</title>
        <link>https://roykesydon.github.io/Blog/p/arm-%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E4%BB%8B%E7%B4%B9/</link>
        <pubDate>Tue, 21 Mar 2023 01:32:54 +0800</pubDate>
        
        <guid>https://roykesydon.github.io/Blog/p/arm-%E7%B5%84%E5%90%88%E8%AA%9E%E8%A8%80%E4%BB%8B%E7%B4%B9/</guid>
        <description>&lt;h2 id=&#34;開發環境&#34;&gt;開發環境&lt;/h2&gt;
&lt;h3 id=&#34;ide&#34;&gt;IDE&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SW4STM32
&lt;ul&gt;
&lt;li&gt;支援 STM32&lt;/li&gt;
&lt;li&gt;GCC C/C++ compiler&lt;/li&gt;
&lt;li&gt;GDB-based debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;板子&#34;&gt;板子&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;STM32 Bucleo Board
&lt;ul&gt;
&lt;li&gt;Cortex-M4&lt;/li&gt;
&lt;li&gt;ST-LINK
&lt;ul&gt;
&lt;li&gt;debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memories
&lt;ul&gt;
&lt;li&gt;1MB Flash&lt;/li&gt;
&lt;li&gt;128KB SRAM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;debug-interface&#34;&gt;Debug Interface&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JTAG
&lt;ul&gt;
&lt;li&gt;Joint Test Action Group&lt;/li&gt;
&lt;li&gt;standard ASICs hardware debug interface&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SWD
&lt;ul&gt;
&lt;li&gt;Serial Wire Debug&lt;/li&gt;
&lt;li&gt;只從 JTAG 用 5 wires&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bootup-code&#34;&gt;Bootup Code&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Reset&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boot Loader&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0x00000000 的程式&lt;/li&gt;
&lt;li&gt;把 CPU 重置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reset handler&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ststem initialization&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C startup code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application(main)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;memory-map&#34;&gt;Memory map&lt;/h2&gt;
&lt;p&gt;見官網 memory map&lt;/p&gt;
&lt;p&gt;只用到 SRAM 的 128KB(SRAM)，還有 Code 的 1MB(Flash)&lt;/p&gt;
&lt;h2 id=&#34;sections&#34;&gt;Sections&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;.data
&lt;ul&gt;
&lt;li&gt;儲存資料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;.text
&lt;ul&gt;
&lt;li&gt;儲存程式碼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同 section 會放在一塊是為了設定 read-only 方便，比如 .text 的要靠硬體實現 read-only&lt;/p&gt;
&lt;h2 id=&#34;重要的額外文件&#34;&gt;重要的額外文件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linker Script
&lt;ul&gt;
&lt;li&gt;定義了不同 section 該存放的地方，以及 memory 相關定義&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;MEMORY
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    RAM (xrw)		: ORIGIN = 0x20000000, LENGTH = 96K
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ROM (rx)		: ORIGIN = 0x8000000, LENGTH = 1024K
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SECTIONS
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/* The program code and other data into ROM memory */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.text :
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    . = ALIGN(8);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *(.text)           /* .text sections (code) */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *(.text*)          /* .text* sections (code) */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *(.glue_7)         /* glue arm to thumb code */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *(.glue_7t)        /* glue thumb to arm code */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *(.eh_frame)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    KEEP (*(.init))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    KEEP (*(.fini))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    . = ALIGN(8);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    _etext = .;        /* define a global symbols at end of code */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;} &amp;gt;ROM
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.data : 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    . = ALIGN(8);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    _sdata = .;        /* create a global symbol at data start */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *(.data)           /* .data sections */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    *(.data*)          /* .data* sections */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    . = ALIGN(8);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    _edata = .;        /* define a global symbol at data end */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;} &amp;gt;RAM AT&amp;gt; ROM
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;Make File
&lt;ul&gt;
&lt;li&gt;描述如何編譯和連接的規則&lt;/li&gt;
&lt;li&gt;把 startup 的 .s檔加進去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;startup_stm32.s
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;編譯好後擺在 binary 頭的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vector table&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/******************************************************************************
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;* The STM32L476RGTx vector table.  Note that the proper constructs
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;* must be placed on this to ensure that it ends up at physical address
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;* 0x0000.0000.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;******************************************************************************/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.section .isr_vector,&amp;#34;a&amp;#34;,%progbits
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.type g_pfnVectors, %object
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.size g_pfnVectors, .-g_pfnVectors
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;g_pfnVectors:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word _estack
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word Reset_Handler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word NMI_Handler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word HardFault_Handler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	MemManage_Handler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	BusFault_Handler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	UsageFault_Handler
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.word	SVC_Handler
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Reset_Handler
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Reset_Handler:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ldr   r0, =_estack
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    mov   sp, r0          /* set stack pointer */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    /* Copy the data segment initializers from flash to SRAM */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ldr r0, =_sdata
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ldr r1, =_edata
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ldr r2, =_sidata
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    movs r3, #0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b LoopCopyDataInit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LoopCopyDataInit:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    adds r4, r0, r3
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    cmp r4, r1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    bcc CopyDataInit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    /* Zero fill the bss segment. */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ldr r2, =_sbss
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ldr r4, =_ebss
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    movs r3, #0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    b LoopFillZerobss
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;LoopFillZerobss:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    cmp r2, r4
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    bcc FillZerobss
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    /* Call the clock system intitialization function.*/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    bl  SystemInit
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    /* Call static constructors */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    bl __libc_init_array
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    /* Call the application&amp;#39;s entry point.*/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    bl main
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;arm-register&#34;&gt;ARM Register&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ARM 的可存取暫存器為 R0-R15&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r13: Stack Pointer&lt;/li&gt;
&lt;li&gt;r14: Link Register&lt;/li&gt;
&lt;li&gt;r15: Program Counter&lt;/li&gt;
&lt;li&gt;r0~r7 是 low register r8~r15 是 high register&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;狀態暫存器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPSR (Current Processor Status Register)
&lt;ul&gt;
&lt;li&gt;用來儲存各種狀態，包含 condition flag，比如 negative, zero, carry, overflow
&lt;ul&gt;
&lt;li&gt;carry: 無符號加法操作是否溢出&lt;/li&gt;
&lt;li&gt;overflow: 有符號加法操作是否溢出&lt;/li&gt;
&lt;li&gt;當兩個都為 1 或都為 0 代表運算沒問題&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有多種模式，有些模式有自己獨立的 r 暫存器，並有 SPSR，用來在中斷發生時，把 CPSR 的資訊 copy 過去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Special-purpose registers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APSR, IPSR, EPSR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;assembly-syntax&#34;&gt;Assembly syntax&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;UAL: Unified Assembler Language&lt;/li&gt;
&lt;li&gt;自己去翻 instruction set&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;instructions-class&#34;&gt;Instructions class&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Branch instructions
&lt;ul&gt;
&lt;li&gt;B, BL, BX,&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data-processing instructions
&lt;ul&gt;
&lt;li&gt;MOV, ADD, SUB, MUL,&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Load and store instructions
&lt;ul&gt;
&lt;li&gt;LDR, STR,&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Status register access instructions
&lt;ul&gt;
&lt;li&gt;MSR, MRS,&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Miscellaneous instructions
&lt;ul&gt;
&lt;li&gt;Memory Barrier instructions&lt;/li&gt;
&lt;li&gt;Exception-Related instructions&lt;/li&gt;
&lt;li&gt;Pseudo instructions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;examples&#34;&gt;examples&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MOVS R0, #0x12&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R0=0x12&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MOVS R1, #`A` &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R1=A(ASCII)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NVIC_IRQ_SETEN  EQU  0xE000E100&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宣告常數 NVIC_IRQ_SETEN，賦值 0xE000E100&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LDR R0,=NVIC_IRQ_SETEN&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;放 0xE000E100 進 R0&lt;/li&gt;
&lt;li&gt;這不能改成 &lt;code&gt;MOVS R0, #0xE000E100 &lt;/code&gt;，因為每個 instruction 只有 32 個 bits，這勢必塞不下，必須從記憶體 load 進來&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NVIC_IRQ0_ENABLE  EQU  0x1&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宣告常數 NVIC_IRQ0_ENABLE，賦值 0x1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MOVS R1, #NVIC_IRQ0_ENABLE&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R1=0x1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;STR R1, [R0]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把 0x1 存到 0xE000E100，這裡可以 enable external interrupt IRQ#0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LDR rn [pc, #offset to literal pool]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;load register n with one word from the address [pc + offset]&lt;/li&gt;
&lt;li&gt;最後的形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;operand2&#34;&gt;Operand2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;共有 12 bits
&lt;ul&gt;
&lt;li&gt;設計成 4 bits for rotate, 8 bits for Immediate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arm-instrcution-formats&#34;&gt;ARM instrcution formats&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ADD vs ADDS
&lt;ul&gt;
&lt;li&gt;有 S 代表會去更新 status&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cond
&lt;ul&gt;
&lt;li&gt;根據之前的執行情況，判斷指令要不要執行&lt;/li&gt;
&lt;li&gt;suffix&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reverse-ordering-operations&#34;&gt;Reverse Ordering Operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;REV (Byte-Reverse Word)
&lt;ul&gt;
&lt;li&gt;把 4 個 Byte 全數反轉，用在一個是 Little-Endian 一個是 Big-Endian 的情況&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;load-and-store-instructions&#34;&gt;Load and Store Instructions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;examples
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LDR r0, [r1]&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;r0 = [r1]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LDM r0, {r1, r2}&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;r1 = [r0]&lt;/li&gt;
&lt;li&gt;r2 = [r0+4]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STM r0, {r1, r2}&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;[r0] = r1&lt;/li&gt;
&lt;li&gt;[r0+4] = r2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;status-register-access-instructions&#34;&gt;Status Register Access Instructions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一般來說不太會用到，因為用 suffix 就可以看條件&lt;/li&gt;
&lt;li&gt;MRS: Register = Status Register
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MRS r0, IPSR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSR: Status Register = Register
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MSR APSR, r0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;if-then-else&#34;&gt;If-Then-Else&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用 CMP 和 conditional branches&lt;/li&gt;
&lt;li&gt;Example
&lt;ul&gt;
&lt;li&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  CMP R0, #10   ;compare r0 to 10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  BLE incr_counter ; if less or equal, then branch to incr_counter
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;branch-instructinos&#34;&gt;Branch Instructinos&lt;/h3&gt;
&lt;p&gt;能跳的距離受限於 operand 長度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-Branch
&lt;ul&gt;
&lt;li&gt;能跳 PC 的 +/- 2046 bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BL-Branch and Link
&lt;ul&gt;
&lt;li&gt;能跳 PC 的 +/- 254 bytes&lt;/li&gt;
&lt;li&gt;Branch to subroutine 的時候，會把下一行指令放到 Link register&lt;/li&gt;
&lt;li&gt;沒有 push 到 stack，所以要特別小心，register 是共用的，
可能要視情況自己放到 stack
&lt;ul&gt;
&lt;li&gt;比如要進兩層 function，可以用 &lt;code&gt;push {r4-r6, LR}&lt;/code&gt; 和 &lt;code&gt;POP {R4-R6, PC}&lt;/code&gt; 這種做法來保留參數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BX-Branch and exchange
&lt;ul&gt;
&lt;li&gt;return&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stack-memory-access&#34;&gt;Stack memory access&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PUSH&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SP = SP - N*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SP = SP + N*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ascending/Descending&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stack 往哪個方向長&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Empty/Full&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stack 指向下一個空的位置，還是最後一個 item&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;預設且常見的是 fully descending&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STM 和 LDM 可以透過 suffix 來存到 stack&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;example
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;STMFD r13!, {r4-r7}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;把 r4 到 r7 push 到 stack&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;memory-barrier-instructions&#34;&gt;Memory Barrier Instructions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DMB, SDB, ISB&lt;/li&gt;
&lt;li&gt;在下個指令前 sync memory data&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;function-call-and-parameter-passing&#34;&gt;Function Call and Parameter Passing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;caller 和 callee 誰負責 backup 和 restore
&lt;ul&gt;
&lt;li&gt;caller 負責
&lt;ul&gt;
&lt;li&gt;不管 callee 怎樣亂搞都行&lt;/li&gt;
&lt;li&gt;但不知道 callee 要用哪些參數，全 backup 可能多此一舉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;怎麼傳遞參數給 callee
&lt;ul&gt;
&lt;li&gt;常放在 stack，但這樣要透過 memory，相較 register 慢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;怎麼 return value 給 caller
&lt;ul&gt;
&lt;li&gt;和上個問題差不多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arm-procedure-call-standard&#34;&gt;ARM Procedure Call Standard&lt;/h3&gt;
&lt;p&gt;又稱 APCS，講不同的 register 的一種使用規範&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r0-r3 用來當參數和回傳&lt;/li&gt;
&lt;li&gt;r4-r11 用來 local variable，callee 使用前可以先 backup&lt;/li&gt;
&lt;li&gt;r12-r15 特殊用途，沒事別亂動&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
