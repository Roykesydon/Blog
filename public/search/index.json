[{"content":"邏輯上的執行順序 FROM WHERE GROUP BY HAVING DISTINCT SELECT ORDER BY DDL Data Definition Language 用來定義資料庫的結構 Create Database 1 CREATE DATABASE database_name; Create Table 1 2 3 4 5 6 CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype, .... ); Data types: INTENGER, VARCHAR(size), TEXT, etc. VARCHAR Variable-length character string Constraints 1 2 3 4 5 6 CREATE TABLE table_name ( column1 datatype constraint, column2 datatype constraint, column3 datatype constraint, .... ); Auto Increment 用來自動增加一個數值 通常用在 primary key Primary Key 用來唯一識別一筆資料 Foreign Key 用來避免資料不一致 必須是另一個 table 的 primary key 可以是 NULL 可以設置 reference action 比如 ON DELETE CASCADE Not Null 用來限制 column 不可以是 NULL Unique 不像 primary key，可以有 null Check 用來限制 column 的值，可以自己寫條件 可以用在多個 column DCL Data Control Language 用來控制資料庫的存取權限 DQL Data Query Language 用來查詢資料庫中的資料 Select 1 SELECT column1, column2, ... FROM table_name; * 代表所有的 column column column 也可以利用 operator 1 SELECT column1 + column2 FROM table_name; 可以使用 AS 來改變 column 的名稱 1 SELECT column1 AS new_name FROM table_name; WHERE 針對 row 的條件過濾 1 SELECT column1, column2, ... FROM table_name WHERE condition; ANY, ALL 用來比較子查詢的結果 1 SELECT column1, column2, ... FROM table_name WHERE column1 \u0026gt; ANY (SELECT column1 FROM table_name); 如果用 \u0026gt; ANY subquery，而 subquery 沒有任何結果，那麼就會回傳 false，因為你的數值沒有比任何一人都高（要至少一人） 如果是 \u0026gt; ALL subquery，那麼就是要比所有人都高，所以如果 subquery 沒有任何結果，那麼就會回傳 true，你的數值比裡面的東西都高 JOIN 用來結合兩個 table 1 SELECT column1, column2, ... FROM table1 JOIN table2 ON table1.column = table2.column; types INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN GROUP BY 用來將資料分組 針對 group 的條件過濾 1 SELECT column1, column2, ... FROM table_name GROUP BY column1; select 的 column 必須是 group by 的 column 或是 aggregate function HAVING 用來過濾 group by 的結果 要有 group by 才能使用 1 SELECT column1, column2, ... FROM table_name GROUP BY column1 HAVING condition; ORDER BY 1 SELECT column1, column2, ... FROM table_name ORDER BY column1; 可以指定升冪或降冪 DESC, ASC LIMIT \u0026amp; OFFSET 用來限制查詢結果的數量 DISTINCT 用來去除重複的資料 CASE 用來做條件判斷 1 2 3 4 5 6 SELECT column1, column2, ... CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ELSE result END FROM table_name; 查詢結果集合運算 UNION 用來結合兩個查詢結果 1 2 3 (SELECT column1, column2, ... FROM table1) UNION (SELECT column1, column2, ... FROM table2); UNION ALL 會包含重複的資料 UNION 會自動去除重複的資料 限制 每個查詢的 column 數量必須相同 每個查詢的 column 的資料型態必須相同 column 的順序必須相同 INTERSECT 用來取兩個查詢結果的交集 EXCEPT 用來取兩個查詢結果的差集 ALL 要加這個才會包含重複的資料 Subquery select, from, where 等等都可以有 subquery 他可以視情況回傳一個值，也可以回傳一堆 row，或是一個 column（一維向量 可以用 outer query 的 column 來當作 subquery 的條件 Correlated Subquery 一個 subquery 用到 outer query 的 value 可能導致效能問題，比如每一筆資料都要執行一次 subquery 像是兩層 for loop flattening 寫成等效的 flat query DML Data Manipulation Language 用來操作資料庫中的資料 Insert 1 2 3 INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...), (value1, value2, value3, ...) 可以一次插入多筆資料 Update 1 UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition; Delete 1 DELETE FROM table_name WHERE condition; Operators Arithmetic Operators Comparison Operators Bitwise Operators String Operators Functions Math Functions Date Functions String Functions ","date":"2024-08-25T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/sql-%E8%AA%9E%E6%B3%95%E7%AD%86%E8%A8%98/","title":"SQL 語法筆記"},{"content":"MongoDB 基礎 以 BSON (Binary JSON) 儲存資料 BSON 是 JSON 的二進位版本，支援更多資料型別，如日期和二進位資料 _id 欄位作為預設的主鍵 若未指定，MongoDB 會自動生成一個 12 字節的 ObjectId 用於確保文件中唯一性，特別在分散式系統中 索引機制 Composite Index 由多個欄位組成，例如 (a, b) Prefix 特性 如果索引為 (a, b)，則 (a) 也可被單獨使用 但 (b) 或 (a, b, c) 無法直接利用此索引 Hint 可強制 MongoDB 使用特定索引 用於測試或避免 optimizer 選錯索引 Explain 分析查詢 用來檢視查詢的執行計畫 重要欄位 cursor BasicCursor 表示全表掃描，應避免 BtreeCursor 表示使用索引 nscanned 掃描的索引數量 nscannedObjects 掃描的文件數量 n 最終返回的文件數量 關係：nscanned \u0026gt;= nscannedObjects \u0026gt;= n scanAndOrder 表示需要將文件載入記憶體並排序 通常一次性返回所有結果，效率較低 Optimizer 索引選擇 第一階段：尋找最佳索引 最佳索引條件 包含所有 filter 和 sort 的欄位 equality filter 必須在 range filter 之前 sort 欄位必須在 range filter 之後 若有多個最佳索引條件符合條件，隨便選擇一個 第二階段：實驗性選擇 若無最佳索引，會測試多個索引 optimizer 選擇 nscanned 最小的索引作為最終方案 儲存引擎 MMAPv1 MongoDB 早期的儲存引擎 特性 _id 直接對應 disk 偏移量 (diskloc) 查詢速度快，但更新需維護偏移量，效能低 鎖定機制 初始為 database-level lock 後期升級至 collection-level lock 已於 MongoDB 4.0 後棄用 WiredTiger MongoDB 收購並採用的新儲存引擎 特性 Document-level locking，提升並發效能 支援資料壓縮，減少儲存空間 版本演進 5.2 之前 _id 用於查找 recordid recordid 作為 clustered index，指向實際文件 5.3 之後 _id 直接成為 clustered index _id 為 12 字節 (ObjectId)，比原 64 位 recordid 更大 影響 對 secondary index 增加儲存負擔 提升跨機器和 shard 環境中的唯一性 ","date":"2024-08-16T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/mongodb-%E7%AD%86%E8%A8%98/","title":"MongoDB 筆記"},{"content":"Transaction 一個或多個操作的集合 一個 transaction 要不全部執行，要不全部不執行 即使程式中未顯式使用 transaction，資料庫也會自動為操作包裹一個隱式的 transaction lifespan begin commit rollback Atomicity 一個 transaction 要不全部執行，要不全部不執行 在 commit 前不管因為任何理由失敗，都該 rollback Consistency 符合當初制定的規則 (ex: 設置的 foreign key 指向的資料一定要存在) referential integrity 保證 primary key 和 foreign key 之間的關係 Eventual consistency 最後一定會 consistent，儘管過程中可能會出現短暫的不一致 Isolation 一個 transaction 的執行不應該影響其他 transaction read phenomena dirty read 一個 transaction 讀到了另一個 transaction 已經寫了但還沒 commit 的資料。這個資料有可能被 commit 也有可能被 rollback non-repeatable read 一個 transaction 兩次讀取同個資料時，得到的資料不一樣因是因為有其他 transaction 更新了這個資料（已經 commit 了） 和 dirty read 不同的是，這個資料是已經 commit 的 phantom read 也是第一次和第二次讀取的資料不一樣，第二次發現多了額外的資料，這次是因為有其他 transaction 寫入了新的資料（並且 commit 了） 之所以要和 non-repeatable read 分開，是因為他這裡沒辦法簡單的靠鎖起來已經讀過的資料，因為你沒辦法鎖你本來看不到的資料 系統設計遇到這問題可以考慮用 pre-populate 的方式，把所有可能的資料都先創好，就可以個別鎖住 lost update 我更新了某筆資料，但是在 commit 之前，有其他 transaction 也更新了這筆資料，並且 commit。我再去讀取這筆資料時，發現我更新的資料就被覆蓋了 double booking problem 當兩個 transaction 同時搶更新同個資源就有可能遇到該問題 example 兩個 transaction 都先 select 再 update 他們兩個 select 都先看到有空位，然後一前一後更新，就會造成 double booking Isolation level 為了解決 read phenomena，資料庫提供了不同的隔離等級 不同的隔離等級會影響到 transaction 之間讀取資料的方式，以達到不同的資料一致性要求 不會影響自身 transaction 前面所 write 的資料 read uncommitted No isolation 可以看到其他 transaction 還沒 commit 的資料 所有的 read phenomena 都有可能發生 read committed 只能看到其他 transaction commit 的資料 許多資料庫的預設隔離等級 除了 dirty read 之外，其他 read phenomena 都有可能發生 repeatable read 確保同一筆資料在同一個 transaction 中讀取時，結果是一樣的 phantom read 還是有可能發生 snapshot 保證 transaction 得到的資料是一致的 只會看到 transaction 開始時的 snapshot read phenomena 都不會發生 好像不是所有資料庫都有這個隔離等級，也有些 repeatable read 就是用 snapshot 來實現的 比如 PostgreSQL 就是用 snapshot 來實現 repeatable read 但這不代表不會遇到問題，請參考 double booking problem serializable 最高隔離等級 保證所有 concurrent transaction 執行起來會和依序執行的效果一樣 如果 transaction 不會彼此影響，還是有可能會讓 transaction 並行執行 read phenomena 都不會發生 和要求 exclusive lock 相比，有可能實現方法是遇到衝突會 fail Durability 一旦 transaction 完成，資料應該要 persistent 完成的 transaction 會被記在 non-volatile storage durability technique Write ahead log (WAL) 先寫 log (寫你做了什麼操作，但不去真的改 disk 上對應的資料)，有空再修改 這樣一些修改就可以改在 memory，如果 crash 了，可以用 log 來 recover 而且考量硬碟限制，如果你想修改的資料遠小於硬碟可寫的最小單位，會很浪費 Asynchronous snapshot 在後台把 snapshot 寫到 disk ","date":"2024-07-21T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/database-transactions-and-acid-properties/","title":"Database Transactions and ACID Properties"},{"content":"Pipeline 名詞 Artifact 你需要用到的檔案，可能是 build 出來的檔案，或是跑測試用的專案 ex: .jar, .war Type Build pipeline Release pipeline azure-pipelines.yml 可以 create pipeline，在專案中加入該檔案，Azure DevOps 會自動偵測並執行 用於 build pipeline trigger 指定哪些 branch 有 push 時，要執行 pipeline Variables 可以設定變數，用在 yaml 中 Task 可以搜尋各種 task 來完成任務 copy files publish build artifacts Release pipeline 把 build 出來的 artifact，部署到指定的環境 artifact 上方的閃電，可以設置當有新的 artifact 時，自動觸發 release create release 執行 CI/CD Agent pool 可以加入自己的 agent，也就是自己的 server Board Work item Epic 一個非常 high level 的需求 Issue 把 Epic 拆成小的需求 在敏捷也可以稱為 User Story Task 再把 Issue 拆成更小的需求 Backlog PO 創建的 Issue，會在 Backlog 中 可以把 Issue 拖拉到 sprint 中 可以結合 git repo，把 commit 或 branch 關聯到 Issue Sprint 在這可以新增 sprint 也有 task board，列出所有 task 可以設置 task 的狀態以及指派人員 ","date":"2024-07-20T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/azure-devops-%E7%AD%86%E8%A8%98/","title":"Azure Devops 筆記"},{"content":"Terms Incremental vs Iterative Incremental 透過多個 increment（增量）逐步構建專案，每個增量都是可運行的部分功能，並在後續開發中持續擴充。 Iterative 建立 prototype（原型），然後反覆改進，每次迭代都基於上一版本進行調整與優化。 Model Type Linear/Predictive 適用於具備類似專案經驗的情境 擁有明確的開發流程 變更空間極小，需求需在開發前確定 Flexible/Adaptive 適用於新創概念或需求尚不明確的專案 專案可能隨時間變更，因此需具備較高的靈活性 Waterfall Model 像瀑布一樣，一個階段完成後才能進入下一個階段 典型流程： Requirement → Design → Implementation → Testing → Deployment → Maintenance 高度預測性（Predictive），變更成本極高，彈性低 問題點： 若在 Testing 階段發現重大缺陷，可能需回溯至 Requirement 重新開始 隨著進度推進，修正成本（fix cost）將大幅增加 需要在每個階段做詳細規劃，以降低風險 用戶直到後期才會看到可運行的成果 Incremental Model 在整個開發過程中，將系統劃分為 多個增量（increments） 來逐步開發與交付 每個增量都具備可運行的功能，並能獨立部署 各個增量的目標與功能範圍需事先定義，以確保最終整合 Agile 一種思維方式，而非特定的開發模型 Agile Manifesto（敏捷宣言） Individuals and interactions over processes and tools（個人與互動高於流程與工具） 若團隊決定使用新的工具，應優先考量團隊的需求，而非僅僅依賴過去習慣的工具 Working software over comprehensive documentation（可運行的軟體高於完備的文件） 文件很重要，但單純依賴大量文件無法讓客戶提供有效回饋 Customer collaboration over contract negotiation（與客戶合作高於合約談判） 強調持續與客戶溝通，以確保專案方向正確，而不是只關注合同上的條款 Responding to change over following a plan（回應變化高於遵循計畫） 在變化快速的環境下，適應需求變更比僵化地執行既定計畫更重要 瀑布式開發的缺點（Agile 解決的問題） 技術環境變化迅速，Agile 讓開發更具適應性 傳統開發方法往往因為考量成本，不容易應對變更 而 Agile 透過 小的增量（increment） 來持續調整方向，降低風險 軟體需求無法 100% 預測 早期規劃的需求可能與最終需求不符，因此 Agile 強調 持續交付與回饋 系統可能不符合用戶需求 透過 迭代開發（iterative development），確保用戶能夠在開發過程中參與並提供反饋 市場變化快速 Agile 強調 MVP（最小可行產品），讓團隊能在短時間內推出核心功能，以快速測試市場反應 Kanban 以視覺化方式管理工作流程 透過卡片（Kanban 卡）來追蹤工作項目 能夠直觀地發現某個工作階段是否積壓過多任務 核心屬性（Properties） Visualize workflow（視覺化工作流） Limit work in progress（限制在製作業務量） Manage flow（管理工作流） Make process policies explicit（明確定義流程規則） Improve collaboratively（透過協作持續改進） 核心原則（Principles） Start with what you do now（從現有流程開始） Agree to pursue incremental, evolutionary change（追求漸進式改變） 並非一次性顛覆整個流程，而是逐步優化 Respect the current process, roles, responsibilities \u0026amp; titles（尊重現有流程、角色、職責與職位） Encourage acts of leadership at all levels（鼓勵各層級展現領導力） Leadership 不僅指管理職責，也包含主動解決問題、協助他人、激勵他人 工作欄位（Work Columns） Backlog（待辦事項） Analyze（需求分析） Develop（開發） Test（測試） Release（發布） Scrum Scrum 核心概念 Scrum 是敏捷開發框架，透過迭代式的開發方式，提高軟體交付的效率與適應性。 主要流程包括 Sprint Planning、Daily Scrum、Sprint Review 和 Sprint Retrospective。 角色與職責 1. Product Owner 負責確保產品的價值最大化 職責： 維護 健康的 Product Backlog（保持任務清晰、優先順序合理） 與 利害關係人 溝通，確保開發方向符合需求 定義 Acceptance Criteria（驗收標準） 管理 預算與 Release 計畫 2. Scrum Master 確保 Scrum 流程正確執行 職責： 促成 Daily Standup，確保討論聚焦 移除障礙，幫助團隊專注於開發 培養 Scrum 文化，確保團隊理解並實踐 Scrum 的價值觀 Servant Leader - 有一點領導，但和大家平等。促成團隊工作而不是指揮別人 3. 開發團隊（Dev Team） 包括工程師、設計師、測試人員等 目標： 與 Product Owner 合作撰寫 User Stories 開發、測試、確保功能符合定義的需求 參與 技術設計、研究與原型開發 Scrum 流程 1. Product Backlog 由 Product Owner 負責維護，內容包含： 優先度 預估花費時間 負責的人 2. Sprint Planning Meeting 目標：將 Product Backlog 轉換為 Sprint Backlog 角色分工： Scrum Master 確保會議高效進行 如果有講太久的部分，可能稍後再排單獨會議 確保一切都和 sprint goal 一致 Product Owner 準備好 product backlog 澄清 product backlog 的細節 要準備好描述 acceptance criteria 比如搜索速度要多快？ Dev Team 拆解任務、估算工作量、選擇可完成的任務 3. Sprint Backlog 本次 Sprint 需要完成的所有任務 開發人員自行選擇任務，並在 1-4 週內完成 Sprint 4. Daily Scrum 不能花太久，比如限制 15 分鐘內完成 Scrum Master 確保會議的進行，確保 timebox 紀錄關於目前障礙的筆記，規劃時間移除 Dev Team 昨天完成了什麼？ 今天計畫做什麼？ 有遇到什麼阻礙？ 5. Sprint Review（成果展示） 向 Stakeholders 展示這次 Sprint 交付的 Product Increment 討論改進方向，準備下一個 Sprint 6. Sprint Retrospective（回顧與改進） 探討 這次 Sprint 哪些地方可以改進 常見方法： Start-Stop-Continue Start：開始做什麼？ Stop：應該停止什麼？ Continue：繼續保持哪些做法？ 每個人說出一個想開始做的事情，一個想停止做的事情，一個想繼續做的事情 可以保持匿名 3-5-3 Structure（Scrum 的核心架構） 3 大工件（Artifacts） Product Backlog Sprint Backlog Product Increment 5 大事件（Events） Sprint Planning Daily Scrum The Sprint Sprint Review Sprint Retrospective 3 大角色（Roles） Product Owner Scrum Master 開發團隊（Dev Team） 其他補充： Scrum 5 大價值觀 (Values)： 專注（Focus） 尊重（Respect） 承諾（Commitment） 勇氣（Courage） 開放（Openness） Scrum 3 大支柱 (Pillars)： 透明性（Transparency） 檢視（Inspection） 適應（Adaptation） 可以利用 back-to-back testing 來確認沒有弄壞之前 sprint 的功能 ","date":"2024-06-27T02:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/software-development-model/","title":"Software Development Model"},{"content":"測試相關概念 Test Data 用來測試系統的輸入 Test Case 包含測試步驟、預期結果、測試資料 Oracle 理想的結果，作為判斷測試是否成功的標準 Verification（驗證） 確認系統是否符合規格（specification） 若出錯，通常是開發或設計的問題 Validation（確認） 確認系統是否符合使用者需求 若出錯，代表產品目標可能有誤 Bug 與錯誤類型 Bug 程式中的錯誤或偏離預期的行為 Failure 偏離預期的事件（event），如系統崩潰或錯誤輸出 Error 導致 failure 的程式錯誤（code issue） Fault（缺陷） 造成 failure 的設計或開發上的錯誤，可能潛伏在系統內直到被觸發 測試輔助工具 Stub 用來代替其他元件的簡單實作，會回傳硬編碼（hard-coded）值 Mock 類似 stub，但除了回傳預設值，還可驗證是否正確調用 Driver 負責執行測試指令並初始化變數的工具 測試覆蓋率（Test Coverage） Line Coverage（行覆蓋率） 測試過的程式碼行數相對於總行數的比例 Branch Coverage（分支覆蓋率） 測試所有條件分支是否都被執行過，如 if、switch 內的所有可能路徑 測試類型（Testing Types） 單元測試（Unit Testing） 測試程式的最小單位（smallest unit of software） 需隔離（isolate）被測單元，避免外部依賴影響測試結果 常使用 dummy value、mock 物件來替代外部依賴 整合測試（Integration Testing） 測試不同組件（components）之間的交互（communication）和架構（architecture） 測試方式 Big Bang Testing（非漸進式測試） 一次測試所有 components，通常用於大型應用程式 Incremental Testing（漸進式測試） 逐步新增模組進行測試，直到完整測試整個系統 Top-Down Testing 從最上層開始，尚未開發的底層使用 stub 代替 Bottom-Up Testing 從最底層開始，尚未開發的上層使用 driver 代替 Back-to-Back Testing（對比測試） 比較已知良好版本與新版本的輸出 若 output 相同，則新版本仍保有舊版本的正確功能 可作為 incremental testing 的一部分 黑箱測試 vs 白箱測試 黑箱測試（Black Box Testing） 不需要知道內部結構，透過輸入與輸出來驗證系統行為 常見測試方法 Boundary Value Analysis（邊界值分析） 測試邊界值，如最大、最小、剛好超出範圍的數值 Cause-Effect Graph（因果圖測試） 一種設計測試案例的方法，也稱為 fishbone diagram 不同的輸入條件（cause）會導致不同的結果（effect） Pair-Wise Testing（成對測試） 測試多個參數的不同組合，減少測試案例數量的同時仍保證足夠覆蓋率 State-Based Testing（狀態測試） 測試不同狀態下的輸入，確認狀態變更的正確性 測試種類 Functional Testing（功能測試） 確保系統功能符合需求 Regression Testing（回歸測試） 重新測試已驗證過的功能，確保新的修改沒有破壞舊的功能 Non-Functional Testing（非功能測試） 測試效能、安全性、可靠性等非功能性需求 白箱測試（White Box Testing） 需要了解內部結構，測試程式碼本身 常見測試方法 Control Flow Testing（控制流程測試） 設計測試案例，使所有條件分支（branch condition）皆被執行 Data Flow Testing（資料流測試） 測試變數的生命週期，包括變數的定義（declaration）與使用（use） 應用範圍 Unit Testing 最主要用於單元測試 Integration Testing 用於確保不同模組之間的溝通正確 ","date":"2024-06-27T00:01:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/testing/","title":"Testing"},{"content":"Creational patterns 關於 object creation 的 patterns。\nFactory Method 將不同 Product 定義一個共有的 Interface(以下簡稱 PI)，並由子類別實作，同時也幫不同工廠定義一個生成 product 的 interface(以下簡稱 FI)，透過不同的工廠類別實體來建立有共同 interface (PI)的不同 Product。 優點 將建立 Product 的方法獨立出來，符合 Single Responsibility Principle 可以輕易擴充新種類的 Product，而不用修改原本的程式碼，符合 Open-Closed Principle Abstract Factory 相比 Factory Method，現在的情境是有多個 Product 的同時，又會分不同系列，而且每次都是使用同一系列的 Product。 - ex: 有一套家具，但是分多種不同的風格，每次都是使用同一風格的家具。\n現在 Factory 會有一個共有的 interface，但是這個 interface 包含了建立一整套 product 的方法\nBuilder 對於建構一個複雜且具備多種組合的產品，可以透過下面兩種方式其中之一解決：\n建構巨大的建構函式 覆蓋所有可能的子類別 但都存在其問題，要不是大量的子類別，不然就是難以呼叫的建構函式。\n把建立物件的每個 component 獨立出來，並且切成多個可分開執行的 step，再根據自己的需求調用需要的函式。\n對於建置步驟可能需要不同時做的情況，定義一個 Builder interface，包含了建立物件的每個 component 的方法，然後由 Builder 的子類別來實作這些方法。\nClient 可以根據自己的需要調用 Builder 中的方法（不用全部調用），就可以在同樣的建構程式碼下透過不同的 Builder 來建立不同的物件。\nDirector 不是必需的，但有需要的話可以讓他幫忙調用 Builder 的 method，好在專案中重複使用。\nPrototype 使用在想要獲得某個對象的 clone 的情境。如果直接照著外表複製，可能會因為看不到私有屬性而造成問題。\n把 clone 的責任交給對象本身，而不是交給 Client。由對象本身提供 clone method。 支援 clone 方法的物像被稱為 prototype。\nSingleton 確保某個類別只有一個 instance，並且提供一個 global access point。\n但是這樣違反了 Single Responsibility Principle，因為他現在要解決兩個問題：\n要讓唯一的 instance 可以被全域存取 負責確保自己的類別只有一個 instance 而且會讓全域變數有的缺點轉移過來，比如不安全，因為別的程式碼可能也可能修改我們在用的變數\nStructural patterns 探討如何組裝類別和物件成為更大的結構。\nAdapter 轉換某個對象的 interface 到另外一種 interface，讓另外一個 Object 可以理解他。 就像 XML 要轉到 JSON。\nBrdige 把一個大類別分成兩個獨立的維度（抽象和實作），讓他們可以獨立變化。\nGura 舉的簡單例子 這例子可以被拿來想像具體實作可能長怎樣\n使用在需要在多個 orthogonal (independent) 的維度上擴展類別時的情境。比如我們要生產的一堆 entity 有分不同的 shape 和 color。 如果有兩種 shape 和兩種 color，我們就會有 4 種子類別\n目標是讓情況從難以計數的子類別數，變成多組功能聯合起來。可以透過把其中一個維度轉換成單獨的類別，然後用引用的方式獲取。\n作法 拆成 abstraction (high-level control) 和 implementation (實際工作)， 由 abstraction 來控制 implementation，比如 GUI 來控制底下的 API。 這樣的好處是兩邊都可以各自發展，以 GUI 和 API 舉例，GUI 可以開發不同方法調用事先說好的 API 介面（abstract），而根據 API 介面可以發展出不同的 implementation。\n未來有更新的 GUI （繼承原有的 abstraction）也因為 implementation 是獨立的，不用擔心影響到他\nComposite 用在程式模型具有層級結構（像是表示成樹）的情況。比如說我現在有一個大盒子，每次拆開盒子裡面有可能是多個東西，然後東西可能是小一點的盒子，或是產品。\n如果要確認全部的產品價格總和，就要層層展開所有盒子，直到看到所有產品。\n作法 假設盒子結構稱為 Composite，而裡面的東西稱為 Component。我們可以定義一個共同介面，以價格為例，可能是讓 composite 和 component 都有獲取價格的 method，但是當調用 composite 的價格時，他會往 child 調用獲取價格的 method，然後把價格加總起來。用遞迴的方式來處理。\n對於 Composite (Container)，不但實現 Component，也提供一個 list 來存放子 component，以及加入和從 list 中移除的 method。\n對 Composite 的操作，會被委託給子 component，不需要 client 擔心。\n就像指揮官只需要對高階軍官下命令。\nDecorator 當今天有多種同類型的東西，你可以能會同時用到多種子類別所形成的組合時，就可以用 Decorator。\nGuru 舉例，不同社群平台的 notification，你可能會想要有不同的 notifier，發到一些指定的社群平台。也有拿天冷穿衣服舉例，可以層層穿不同的衣服。\n但這是一層層的感覺，具有順序性。 Decorator 和 Component 都繼承同一個 interface。 有兩種實作辦法，可以層層包裹但是在外部自行調用，也可以把包裹的功能放在 Decorator 裡面，讓他自己調用。 如果是第二種，可能就像下面這樣 就像是 data = new Encrypt(new Compress(new FileData(data)))\n存在很難從 stack 中刪除特定 decorator 的缺點。\nFacade 為複雜的一堆子系統提供一個外部介面 Class，讓 client 可以使用他們關心的功能。 實際怎麼調用 client 無須知道。\nGuru 舉例，比如說你要轉換影片，可能要調用很多不同的子系統，比如說轉檔、壓縮、上傳等等，可以獨立出去一個新的 class 提供轉換影片的功能，然後內部調用這堆子系統，client 只需要調用這個新的 class 就好。\n容易形成 god object。\nFlyweight 對於大量類似的物件，為求節省記憶體而誕生的 pattern。\n把物件的內容分成 intrinsic 和 extrinsic，intrinsic 是不會改變的 (unique)，而 extrinsic 是會改變的 (repeating)。讓 extrinsic 的東西用同一塊記憶體。\n可以透過一個可以儲存建立過共有物件的 factory 來建立物件。\nProxy 用在多個服務想要調用某個重量級資源的情境下，可能只有很偶爾的情況需要用這 entity，但是如果平常就佔據著這個 entity，可能會消耗大量資源。\n如果在服務和 entity 之間加上 proxy，就可以讓 proxy 來處理這些情況。可以用 proxy 的場景較多，下面以 cache 的場景為例子。\n獲取某個靜態檔案可能非常花時間，但如果透過 proxy，第一個 service 想要這檔案的時候，proxy 可以去調用並暫存，其他 service 來要求的時候就可以直接回傳給他們。\nBehavioral patterns 探討物件或是演算法之間的溝通和分配職責。\nChain of Responsibility 透過一連串可以串接起來的 handler，來處理請求。\n對於一系列檢查的情況，可以用這種作法，有兩種形式：\n一路檢查，檢查失敗則中斷請求。 常見的例子是用在網頁的 middleware，如果有一個 middleware 檢查失敗，就不會往下傳。 每個 Handler 自行決定要不要處理該請求，要的話則不會往下傳。 這樣可能會最後沒人處理 就像網頁點擊事件，一層層元素往上問。 Command 把請求獨立出來，讓請求可以被用各種方式調用。 比如說把業務邏輯從 GUI 中抽出來，讓 GUI 只負責呼叫 command，然後 GUI 就可以有多個地方呼叫同一個 command。\n比如多種不同的按鈕或快捷鍵背後都執行同一個存檔功能。存檔就可以作為 command 獨立出來。 背後再根據這個 command 實施對應的業務邏輯。\nIterator 用來需要遍歷集合中元素的情境，把不同種類的遍歷行為細節隱藏起來。\n提供多種不同的 iterator，但遵循同一種 interface，讓使用者可以根據需要選擇 iterator。 對於不關心用哪種 iterator 的使用者，也能受益於 iterator 的 interface，而不必耦合於特定的演算法。\nMediator 禁止多個 component 直接溝通，迫使他們透過 mediator 來溝通，避免複雜的關係。 所有人只能透過 notify mediator 來溝通，mediator 根據 sender 和 event，來做出相應處理。\n所有的 component 都不知道最終會有哪些 component 處理自己的請求，同樣的，他們也不知道請求是誰造成的，彼此不知道對方的存在。\nMemento 讓你可以儲存和復原到先前的狀態。\n讓要儲存的對象自己生成 snapshot。\n建議存在名為 momento 的 special object，這個 object 不能讓除了 producer 外的其他 object 直接存取。\n其他 object 只能透過 limited interface 來取得透過 producer 產生的 momento。\n這些限制讓 momento 可以交給其他 object 來管理，稱為 caretaker，要復原的時候再把 momento 交還給 producer。\nObserver 定義 subscription 機制。\n有 interesting state 的 object 稱為 subject，但由於他也會通知其他人，所以又稱為 publisher。追蹤它的人稱為 Subscriber。\nSubscriber 如果想要在 Publisher 的狀態改變時被通知，就要訂閱 Publisher。然後 Publisher 維護一個 list 來存放所有訂閱者。\nState 用在類似 Finite-State Machine 的情況。\n把物件可能的狀態給提取出去，建立一個 interface，interface 包含了所有在不同狀態下會表現行為不同的 method。\n該 pattern 把每個 state 獨立成一個 Class，把實際的行為委託給 state，而不是由 context (原始物件) 來控制。Context 只管切換 state。\nStrategy 把不同實現方法的演算法定義為遵循同一個 interface 的類別，讓使用者可以根據需要選擇演算法。\n原始的類別叫做 Context，client 可以把不同的策略傳給 Context，然後 Context 再根據策略來執行。\nTemplate Method 把演算法拆成多個步驟，讓子類別可以選擇性覆寫其中的一些步驟，但不改變演算法的結構。\n原始的 template 可能有已經有預設實作或是 abstract method，就算有預設實作，子類別也可以選擇性覆寫。\nVisitor 如果今天有一堆有共同父類別的子類別，我想新增某個功能，並給他們所有人用，同時不太希望修改到既有的這些類別，這時候可以用 visitor（雖然還是會做微不足道的修改）。\nVisitor 要解決的問題和 Double Dispatch 很像。\nvistor 會把新功能放在名為 Visitor 的新 class 中，然後透過 double dispatch 來執行。\n新功能會根據這些子類別提供不同的 method，然後透過這些 method 來執行新功能。\n我們最終會在這些子類別中新增一個 accept method，這個 method 會接受一個 visitor，然後根據 visitor 來執行對應的 method。\n雖然這樣依然會修改到子 class，但這屬於微不足道的改變，而且可以讓之後新增的一些功能不用再去修改這些子 class。\nSingle Dispatch dispatch 是指決定在 runtime 要呼叫哪個 method 的過程。 大多數的物件導向程式語言都支持 single dispatch，比如說在執行時期，遇到多型的時候，選擇要執行什麼 method。（我不確定有沒有多型以外的情況）\nDouble Dispatch 這是一種技巧，讓我們可以在執行時期根據接收者（物件本身）和參數（傳進方法的物件）的類型決定要執行哪個 method。\n好像也可以說是兩個參數的多型。\n這是因為在編譯時期，看利用多型的程式碼，我們只能知道物件的多型型別，但是不知道他的實際型別，所以我們無法知道要執行哪個 method。\n但是如果我們在執行時期，可以根據物件的實際型別來決定要執行哪個 method，這樣就可以達到我們想要的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class A { public void accept(Visitor v) { v.visit(this); } } public class B { public void accept(Visitor v) { v.visit(this); } } public class Visitor { public void visit(A a) { // visitor 不一定要用重名，這裏只是舉例 System.out.println(\u0026#34;A\u0026#34;); } public void visit(B b) { System.out.println(\u0026#34;B\u0026#34;); } } 調用的時候可能會像a.accept(visitor)\n第一次調用發生在 accept method，根據 a 來決定要執行哪個 accept method\n第二次調用發生在 visit method，根據 參數的類型 來決定要執行哪個 visit method\n","date":"2023-10-10T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-desing-pattern/","title":"設計模式 Desing Pattern"},{"content":"簡介 Meta 在 2015 年公開的 API Query Language 相較於傳統的 REST API，具備更靈活的查詢能力 可讓客戶端精確地獲取所需的資料，避免多餘的請求和回應 被多家公司採用，如： Facebook GitHub Twitter \u0026hellip; GraphQL 與 REST API 的主要差異 Single Endpoint\nREST API 針對不同資源 (resource) 需要不同的 endpoint，而 GraphQL 透過單一 endpoint 存取所有資源 但 GraphQL 由於僅有一個 URL，無法直接利用 HTTP caching 進行快取，而是依賴 client-side caching 或 persistent queries 來優化效能 解決 Under-fetching 和 Over-fetching 問題\nUnder-fetching\n一個 API call 無法取得所有需要的資料，導致需要多次 API call 例如，使用 RESTful API 取得一篇文章及其作者資訊，可能需要先請求文章資料，再請求作者資料 GraphQL 透過 nested query 可以在單次 API call 內獲取文章及作者資訊 Over-fetching\nAPI 回應的資料超過實際所需，造成資源浪費 GraphQL 允許客戶端指定僅需要的欄位，避免傳輸過多無用資料 GraphQL 的運作方式 GraphQL 需要特別架設 GraphQL server，可考慮使用 Apollo Server、Express + graphql 套件等方式實作\n需定義 schema 來描述不同的資料類型 (Data type) 及其關聯 (relationship) 透過 resolver 來處理查詢和資料變更 Query (查詢) GraphQL 的查詢語法允許客戶端精確地獲取所需的資料，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 query postQuery($id: ID!) { post(id: $id) { id title content author { id name } } } ### Mutation (變更資料) GraphQL 透過 Mutation 來處理新增、修改、刪除資料，例如新增文章的請求： ```graphql query addPost($post: AddPostInput!) { addPost(post: $post) { id title content author { id name } } } ","date":"2023-08-22T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/graphql-%E7%B0%A1%E4%BB%8B/","title":"GraphQL 簡介"},{"content":"基本介紹 功能特性 NoSQL 資料庫 記憶體式存儲 (In-memory) 以鍵值對 (Key-Value) 形式存儲資料 支援多種資料結構，如列表 (List)、集合 (Set)、雜湊 (Hash) 等 高性能，適合需要快速讀寫的場景 使用場景 快取 (Cache)\n儲存常用資料，減少長時間的 IO 操作，提升回應速度 共享會話 (Shared Session)\n在無狀態 (stateless) 的伺服器間共享會話資料 分散式鎖 (Distributed Lock)\n用於多個程序共享資源時，透過 SETNX (set if not exists) 實現原子性鎖定 速率限制 (Rate Limiter)\n利用計數器 (increment) 和過期時間 (expiration) 實現請求限制 基本操作 啟動與連線 redis-server\n啟動 Redis 服務，預設埠為 6379 redis-cli\n進入 Redis 命令列介面 資料存取 SET \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\n設定鍵值對，預設值為字串類型 GET \u0026lt;key\u0026gt;\n獲取指定鍵的值 DEL \u0026lt;key\u0026gt;\n刪除指定鍵 EXISTS \u0026lt;key\u0026gt;\n檢查鍵是否存在 KEYS \u0026lt;pattern\u0026gt;\n查找符合模式的鍵，例如 KEYS * 可列出所有鍵 FLUSHALL\n清空所有資料 過期機制 TTL \u0026lt;key\u0026gt;\n查看鍵的剩餘存活時間，單位為秒 \u0026ldquo;-1\u0026rdquo; 表示永不過期 \u0026ldquo;-2\u0026rdquo; 表示已過期 EXPIRE \u0026lt;key\u0026gt; \u0026lt;second\u0026gt;\n設定鍵的過期時間 SETEX \u0026lt;key\u0026gt; \u0026lt;seconds\u0026gt; \u0026lt;value\u0026gt;\n設定鍵值對並同時指定過期時間 支援的資料結構 列表 (List) LPUSH/RPUSH \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\n從左/右端推入值 LRANGE \u0026lt;key\u0026gt; \u0026lt;start index\u0026gt; \u0026lt;end index\u0026gt;\n獲取指定範圍的值，end index 可為 -1 表示到最後 LPOP/RPOP \u0026lt;key\u0026gt;\n從左/右端彈出值 集合 (Set) SADD \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\n加入值到集合 SMEMBERS \u0026lt;key\u0026gt;\n列出集合所有成員 SREM \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\n移除集合中的值 雜湊 (Hash) HSET \u0026lt;key\u0026gt; \u0026lt;field\u0026gt; \u0026lt;value\u0026gt;\n設定雜湊欄位的值 HGET \u0026lt;key\u0026gt; \u0026lt;field\u0026gt;\n獲取指定欄位的值 HGETALL \u0026lt;key\u0026gt;\n獲取雜湊所有欄位與值 HDEL \u0026lt;key\u0026gt; \u0026lt;field\u0026gt;\n刪除指定欄位 HEXISTS \u0026lt;key\u0026gt; \u0026lt;field\u0026gt;\n檢查欄位是否存在 注意：Redis 不支援巢狀雜湊結構 快取機制 常見快取策略 Cache Aside\n先查詢快取，若無資料則查詢資料庫，並將結果存入快取 Read Through\n用戶端僅存取快取，若快取無資料，由快取負責從資料庫取回 Write Through\n寫入資料時，快取保留一份並同步寫入資料庫 Write Behind\n與 Write Through 類似，但不會立即寫入資料庫，而是累積資料後批量寫入 快取情境問題與解法 快取雪崩 (Cache Avalanche)\n大量快取同時失效，導致資料庫瞬間承受高流量 解法\n為快取加上隨機過期時間，避免集中失效 快取擊穿 (Hotspot Invalid)\n熱點快取失效，大量請求直接衝擊資料庫 解法\n設定熱點資料永不過期，或在查詢資料庫時加鎖控制流量 快取穿透 (Cache Penetration)\n用戶請求不存在的資料，快取與資料庫皆無結果，直接衝擊資料庫 解法\n在應用層過濾非法請求，或使用布隆過濾器 (Bloom Filter) 預先檢查 記憶體管理 過期鍵刪除策略 定期刪除\n每隔固定時間隨機抽樣檢查部分鍵，若過期則刪除 惰性刪除\n訪問鍵時檢查是否過期，若過期則立即刪除 記憶體淘汰策略 (maxmemory-policy, Eviction) 當記憶體使用達到上限時，根據設定的策略處理資料\nnoeviction\n不淘汰任何鍵，記憶體滿時拒絕新寫入 allkeys-lru\n對所有鍵使用最近最少使用 (LRU) 算法淘汰 allkeys-lfu\n對所有鍵使用最不常用 (LFU) 算法淘汰 volatile-lru\n僅對設有過期時間的鍵使用 LRU 淘汰 volatile-lfu\n僅對設有過期時間的鍵使用 LFU 淘汰 allkeys-random\n從所有鍵中隨機淘汰 volatile-random\n從設有過期時間的鍵中隨機淘汰 volatile-ttl\n優先淘汰剩餘存活時間 (TTL) 較短的鍵 持久化 RDB (Redis Database) 以固定時間間隔對記憶體中的資料進行快照 (memory dump) 優點：恢復速度快，適合大規模資料備份 缺點：若伺服器故障，可能丟失最後一次快照後的資料 相關命令 SAVE\n同步生成快照，會阻塞主進程 BGSAVE\n異步生成快照，不影響主進程 AOF (Append Only File) 記錄每一次寫入操作的流程，類似操作日誌 優點：資料一致性高，丟失風險低 缺點：檔案較大，恢復速度比 RDB 慢 AOF 重寫 (Rewrite)\n當 AOF 檔案過大時，Redis 會生成新檔案，\n用最少的操作重建當前資料狀態，取代舊檔案 混合模式 結合 RDB 和 AOF 優勢 在 AOF 重寫時，前段使用 RDB 格式快照，後段附加 AOF 操作日誌 兼顧恢復速度與資料完整性 高可用性 (High Availability) 主從同步 一主多從架構，主節點負責寫入，從節點分擔讀取壓力 從節點會即時同步主節點的資料 提升讀取效能，但主節點故障需手動切換 哨兵模式 (Sentinel) 部署哨兵進程監控主從伺服器的運行狀態 哨兵持續 Ping 伺服器，檢測異常 若為哨兵叢集： 單一哨兵檢測異常時，標記伺服器為主觀下線 多數哨兵同意後，判定為客觀下線，觸發故障轉移 (failover) 自動選出新主節點，確保服務可用 叢集模式 (Cluster) 將資料分片儲存，分散寫入壓力 Redis 預設提供 16384 個槽 (slot)，透過雜湊函數分配鍵到不同槽 節點間使用預設埠 16379 進行通訊 可結合主從同步實現高可用性 適用於大規模資料與高併發場景 ","date":"2023-06-05T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/redis/","title":"Redis"},{"content":"Hexagonal Architecture (Ports and Adapters Architecture) 目標是讓應用程式的核心邏輯與外部系統解耦 把軟體分為內部部分與外部部分 內部部分 包含 domain logic 先被開發，不受外部系統影響 外部部分 包含所有的依賴層 (dependency layers) 不屬於應用程式的部分，如 UI、資料庫 (DB)、或應用框架 (framework) Ports 介面 (interface)，定義外部系統可以使用的方法 兩種類型 Input Ports：由內部應用程式暴露給外部使用，定義應用程式的行為 Output Ports：由內部應用程式呼叫外部系統，如資料庫或 API Adapters 用來實作 Ports，轉換外部請求到應用程式內部邏輯 Primary Adapter 實作 Input Port，負責接收外部輸入並調用 Use Case 例如 Web Controller 或 CLI Handler Secondary Adapter 實作 Output Port，負責將 Use Case 的結果傳遞到外部系統 例如資料庫存取層 (Repository) 或 API 呼叫 Clean Architecture 目標是讓 domain logic 與其他部分分離，使系統可以隨時更換技術而不影響核心邏輯 透過 DIP (Dependency Inversion Principle) 達成 高層次模組不應依賴低層次模組，兩者應依賴抽象 抽象不應依賴細節，細節應依賴抽象 將軟體分為不同層次，並確保依賴方向只能往內部流動 常見架構比較 傳統三層架構 (Three-Tier Architecture)\n依賴關係：Presentation Layer -\u0026gt; Business Logic Layer -\u0026gt; Data Access Layer 這種架構會導致 Business Logic 依賴 Data Access，影響可測試性與可維護性 Clean Architecture\n所有外部層次都應依賴 Business Logic Layer (Use Cases) 依賴方向為 Frameworks \u0026amp; Drivers -\u0026gt; Interface Adapters -\u0026gt; Use Cases -\u0026gt; Entities 優點 技術可替換性高 domain logic 獨立於技術實現，允許更換 UI、資料庫、框架等技術 只需替換 Adapters，不影響核心邏輯 測試方便 domain logic 不依賴外部系統，可以使用 mock 測試 減少整合測試的負擔 更容易擴展與維護 避免不同技術層相互耦合，讓系統更具彈性 Clean Architecture 的層次結構 Entities 核心物件，負責企業規則 (Enterprise Business Rules) 只關心應用程式的核心邏輯，與技術無關 例如帳戶物件：包含帳號名稱、密碼、驗證密碼的方法 Use Cases 應用程式規則 (Application Business Rules)，定義具體業務邏輯 負責協調 Entities，確保業務流程正確 例如處理使用者登入、交易等邏輯 Interface Adapters 負責資料轉換，讓資料符合不同層的需求 例如 View Model 轉換、DTO 轉換、Repository 轉換 Frameworks and Drivers 包含所有技術相關的部分，如 Web 框架、資料庫、第三方 API 這些技術可以隨時替換，不影響 Use Cases 和 Entities ","date":"2023-05-22T00:00:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/clean-architecture/","title":"Clean Architecture"},{"content":"重構 在不改變軟體行為的情況下，對軟體內部構造進行改善\nCode Smell 也稱 Bad Smell，代表程式碼中需要重構的部分\nBloaters 程式碼（類別、方法）過於龐大\nLong Method 部分解法 用 Extract Method 拆解過長的 function 用 Replace Temp with Query 取代暫存變數 Large Class 一個 Class 有太多 fields / methods / lines 部分解法 Extract Class Extract Subclass 把部分功能移到新建的子類別 Long Parameter List 部分解法 Preserve Whole Object 把來自同一物件的資料直接該物件取代 Introduce Parameter Object 把相關的參數包成一個 Object Data Clumps 不同的程式碼區域出現相同的變數組（Guru 舉的例子是連接資料庫用的參數） 常一起出現的資料群應該被單獨抽成一個 Class 部分解法 Extract Class Introduce Parameter Object Primitive Obsession 過度使用基本類別（primitives），造成 Shotgun Surgery Magic Number 也是一種 Primitive Obsession 部分解法 Replace Data Value with Object Replace Type Code with Class Object-Orientation Abusers 亂用物件導向程式設計原則\nSwitch Statements 有非常複雜的 Switch Case 或是 if-else 部分解法 Replace Conditional with Polymorphism Replace Type Code with Subclasses 直接把多種狀態個別建立子物件，並把相關行為放進去，用多型處理 Replace Type Code with State/Strategy 用一個 state 物件來取代 type code Temporary Field 指那些只在特定情況下才會被使用的 field，平時都是 null 通常是因為存在需要大量參數的 function，但是這些參數被選擇放到 field 部分解法 Extract Class 把這些 field 和會用到的 function 抽成一個 Class Introduce Null Object 用一個 Null Object 來取代 null，他可以提供一些預設的行為 Alternative Classes with Different Interfaces 兩個 Class 具有功能相同、命名不同的 function 部分解法 Rename Method Extract Superclass 把兩個 Class 的共同功能抽成一個父類別 Change Preventers 一處改變會導致多處程式碼改變\nDivergent Change 對一個類別的修改會導致類別的多處也需要修改 部分解法 Extract Class Shotgun Surgery 某個責任被分散到大量的 Class 身上，使修改其時要大量修改 對多個類別進行同一種修改 部分解法 Move Method Move Field Dispensables 不必要的程式碼\nDuplicated Code 多個程式碼片段幾乎相同 部分解法 Extract Method Lazy Class 沒什麼用的冗餘 Class 部分解法 Inline Class 把這個 Class 的 feature 全部移到另一個 Class Collapse Hierarchy 子類別和父類別功能差不多，可以把子類別和父類別合併 Couplers 導致類別之間高度耦合\nFeature Envy 存取別的 Object 的 Data 的情形比自己的還頻繁 這方法可能應該屬於另一個 Object 部分解法 Move Method 把這個方法移到另一個 Class Extract Method 如果只有一部分有這種情況，可以把這部分抽出來 Message Chains Client 請求 A 物件，A 物件又請求 B 物件，以此類推 部分解法 Hide Delegate 情境是 client 從 A 物件取得 B 物件，然後又呼叫 B 物件的方法 解法是把 B 物件的方法轉移給 A 物件 Extract Method \u0026amp; Move Method 把最終的方法抽出來，放到開頭的物件 Inappropriate Intimacy 一個類別使用另一個類別的內部欄位或方法 不單是存取私有變數，應該說依賴於另外一個類別的實作細節，比如出於某些原因知道要以特定順序呼叫方法 和 Feature Envy 相比，損害了其他類別的封裝性 部分解法 Move Method / Move Field 如果該類別確實不需要這些東西可以考慮 Extract Class 把這些方法和欄位抽成一個 Class ","date":"2023-04-25T14:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E9%87%8D%E6%A7%8B-refactoring/","title":"重構 Refactoring"},{"content":"Normalization 目的 避免 redundant information 資料重複容易導致資料不一致 避免 anomalies 避免資料不一致 隨著 1NF ~ 5NF，有更多的 safety guarantee\nFunctional Dependency {X} -\u0026gt; {Y}\nX 是 determinant，Y 是 dependent Y is functionally dependent on X (Y depends on X) X functionally determines Y 一個 attribute 的 value 可以決定另一個 attribute 的 value\nex: {playerID} -\u0026gt; {playerName} 這代表 playerID 決定了 playerName 用箭頭表示，左邊是 determinant，右邊是 dependent\n一個 attribute 可以有多個 dependent\nex: {playerID} -\u0026gt; {playerName, playerAge}\n一個 attribute 也可以是多個 attribute 的 dependent\nex: {playerID, itemID} -\u0026gt; {itemName}\n1NF 去除重複性 違反條件 用 row order 傳達資訊 mixing data types in single column 但 relational database 不會讓你這樣做 存在沒有 primary key 的 table repeating groups 同一個 column 有多個數值，或是在同一個 row 存多個同類型的數值 每個 column 的 value 都應該是 atomic ex : player item roy 1 item_1, 4 item_2 star 4 item_4 player item_type1 quantity1 item_type2 quantity2 roy item1 1 item2 4 star item_4 4 2NF 去除 partial dependency 所有的 non-key attribute 都要 depend on 整個 PK 非正式定義，有點細微差異 如果是 composite key，不能 depend on PK 的其中一部分 functional dependency ex: {playerID, itemID} -\u0026gt; {itemName} 違反的例子 ex: playerID itemID itemName 1 1 item_1 1 2 item_2 2 1 item_1 這裡的 PK 是 {playerID, itemID}，但 itemName 只 depend on itemID 3NF 去除 transitive dependency\ntransitive dependency {A} -\u0026gt; {B} -\u0026gt; {C} 考慮到 functional dependency 有遞移性(Transitivity)\nTransitivity {A} -\u0026gt; {B}，{B} -\u0026gt; {C}，則 {A} -\u0026gt; {C} 所有 non-key attribute 都要 depend on the whole key，不能 depend on 其他 non-key attribute\n違反的例子\nex: playerID itemID itemName itemCategory 1 1 item_1 weapon 1 2 item_2 weapon 2 1 item_1 weapon 這裡的 PK 是 {playerID, itemID}，但 itemCategory 只 depend on itemName 這裡的 itemCategory 是 transitive dependency Boyce-Codd Normal Form (BCNF) 3NF 的強化版，又稱 3.5NF 實務中大多做到 3NF 對於每個 functional dependency，左邊的 attribute 都是 super key 違反例子 ex: playerID itemID itemName PlayerName 1 1 item_1 roy 1 2 item_2 roy 2 1 item_1 test 存在至少兩個 functional dependency {itemID} -\u0026gt; {itemName} {playerID} -\u0026gt; {playerName} 但是 {playerID} 和 {itemID} 都不是 super key 拆成三個表就可以解決 4NF 要先符合 BCNF 去除多值依賴(Multivalued Dependency) multivalued dependency 一個表格至少要有 3 個 column 才有可能有 multivalued dependency 對於 {A} -\u0026gt; {B}，如果一個 A 可以對應到多個 B，也可以對應到多個 C，然後 B 和 C 獨立，則有 multivalued dependency 一個 table 中的所有 multivalued dependency 必須依賴於 key 5NF 又稱 Project-Join Normal Form (PJNF) 去除 join dependency join dependency 一個 table 可以表示成其他 table join 起來的結果 如果 JOIN dependency 存在，就拆分多個 table ","date":"2023-03-14T10:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/database-normalization/","title":"Database Normalization"},{"content":"Class Diagram 類別關係 (Class Relationships) 依賴 (Dependency) 描述：「uses-a」關係，表示某個類別暫時依賴於另一個類別，通常體現在方法的參數或回傳值中。 符號：虛線箭頭 - - -\u0026gt; 範例：Class A - - -\u0026gt; Class B（A 使用 B，但 B 的變動不會影響 A） 關聯 (Association) 描述：「knows-a」關係，表示兩個類別彼此有關聯，可存取對方的屬性或方法。 符號：實線 ----- 額外資訊： 單向關聯：A 知道 B，但 B 不知道 A 雙向關聯：A 和 B 彼此知道對方 聚合 (Aggregation) 描述：「has-a」關係，表示物件之間的組合，但子物件 (child) 可以獨立存在，不受 parent 影響。 符號：空心菱形 ◊----- 範例：學校 (School) 擁有多個老師 (Teacher)，但學校刪除後，老師仍然可以存在。 組合 (Composition) 描述：「has-a」關係，強於聚合，表示 child 的生命週期依賴 parent，若 parent 被刪除，child 也會消失。 符號：實心菱形 ◆----- 範例：房子 (House) 由房間 (Room) 組成，若房子被拆除，房間也會消失。 繼承 (Inheritance) 描述：「is-a」關係，表示子類別 (subclass) 繼承父類別 (superclass) 的屬性和行為。 符號：實線箭頭 -----▷ 範例：Dog 是 Animal 的子類別 (Dog -----▷ Animal) 實作 (Implementation) 描述：「can-do」關係，表示類別實作 (implements) 介面 (interface)。 符號：虛線箭頭 - - - -▷ 範例：Bird 實作 Flyable (Bird - - - -▷ Flyable) 額外特性 (Other Features) 導向 (Navigation) 若兩個類別都能訪問對方，則使用無箭頭的關聯線 -----。 若只有一方能訪問對方，則使用箭頭 -----\u0026gt;。 角色名稱 (Role Name) 在關聯線旁標示角色名稱，表示該類別在關係中的角色。 範例：Person 與 Car 之間的關係中，Car 可能有 owner 角色。 多重度 (Multiplicity) 定義關聯物件的數量。 範例： 1：只能有一個實例 0..1：最多一個 *：零個或多個 1..*：至少一個 自關聯 (Self-Association) 當類別內部的物件彼此有關聯時，可用自關聯 (Self-Association)。 範例：Employee 可能是另一個 Employee 的 manager。 存取修飾詞 (Access Modifiers) 在 UML 類別圖中，可以用 +、-、# 來表示不同的存取權限：\n符號 存取修飾詞 說明 + public 任何類別都可以存取 - private 只有該類別本身可以存取 # protected 只有該類別與其子類別可以存取 ~ package (default) 只有相同 package 內的類別可以存取 ","date":"2023-03-09T14:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/uml-%E7%AD%86%E8%A8%98/","title":"UML 筆記"},{"content":"軟體設計原則 軟體設計原則 Encapsulate What Varies 封裝經常改變的程式碼，以避免影響其他區塊的程式碼，提升維護性 具體做法包括將變動部分抽象為 interface，讓實作細節與使用方解耦 例如，在策略模式（Strategy Pattern）中，將變動行為封裝於獨立類別，並透過 interface 進行交換 Favor Composition over Inheritance Composition（組合）在許多情境下可取代 Inheritance（繼承），並能達成 Polymorphism（多型） 只有在符合 is-a 關係時才應考慮使用繼承，例如「貓是動物」 Composition 透過組合物件的方式擴展功能，通常比繼承更具彈性，且能降低耦合度 比如有 Engine 類別，Car 可以有一個 Engine 的物件，而不是繼承 Engine SOLID 設計原則 Single Responsibility Principle (SRP) - 單一職責原則 A class should have only one reason to change 每個類別應該只負責一項功能，避免職責過於複雜 實踐方式： 把一個複雜的模組拆成多個獨立的類別 例如，把「資料庫存取」與「商業邏輯」分開，避免單一類別同時負責多種功能 Open-Closed Principle (OCP) - 開放封閉原則 You should be able to extend the behavior of a system without having to modify that system 系統應該對擴充開放，對修改封閉 實踐方式： 使用抽象類別與介面，讓新功能可以透過擴展來新增，而不是直接修改原始碼 例如，在 Shape 介面下定義 draw()，新增 Circle、Rectangle 只需實作該介面，而無需修改原有 Shape 相關程式碼 Liskov Substitution Principle (LSP) - 里氏替換原則 子類別應該能替換父類別，且不影響程式的正確性 確保繼承時不破壞原有功能，避免發生「使用父類別時正常，但換成子類別就出錯」的情況 實踐方式： 避免子類別重寫父類別方法時，改變原有的行為或拋出例外 例如，如果 Bird 有 fly() 方法，而 Penguin 繼承 Bird，但企鵝不會飛，則應改用 CanFly 介面來區分，而非讓 Penguin 繼承 Bird 而空實作 fly() Interface Segregation Principle (ISP) - 介面隔離原則 No client should be forced to depend on methods it does not use 避免讓一個介面擁有過多功能，導致實作該介面的類別需要實作不必要的功能 實踐方式： 把大介面拆分為多個小介面，使類別只需實作與自身業務相關的介面 例如，Worker 介面包含 work()、eat() 方法，則應將其拆成 Workable 介面（包含 work()）與 Eatable 介面（包含 eat()），避免機器人類別被迫實作 eat() Dependency Inversion Principle (DIP) - 依賴反轉原則 高階模組不應該依賴低階模組，兩者都應依賴抽象層 抽象不應依賴具體實現，具體實現應依賴抽象 實踐方式： 透過 interface 或 抽象類別 來解耦高階與低階模組 例如，OrderService 依賴 PaymentProcessor 介面，而不是直接依賴 PayPalProcessor 或 StripeProcessor，這樣未來更換支付方式時無需修改 OrderService Modularity Coupling（耦合） 模組間的依賴程度，耦合越鬆散，模組的獨立性越高，維護與擴展性越好\nTight Coupling（緊密耦合） Content Coupling（內容耦合）\n一個模組直接依賴另一個模組的內部運作 範例：一個模組直接存取另一個模組的變數（假設變數表示長度，單位是公尺） 若另一個模組改變單位為公分，則所有存取該變數的模組都會受到影響 解法：透過 getter 提供 getMeter() 方法，而不是直接存取變數 Common Coupling（公共耦合）\n多個模組共同存取和修改同一個 global data 範例：多個模組使用相同的全域變數，當其中一個模組錯誤修改該變數時，其他模組可能會出錯 External Coupling（外部耦合）\n多個模組依賴相同的外部 I/O 範例：所有模組直接呼叫相同的 API，若 API 變更，所有模組都需修改 Medium Coupling（中等耦合） Control Coupling（控制耦合）\n一個模組透過參數影響另一個模組的內部邏輯 範例：函式 process(data, mode) 內部邏輯依賴 mode 參數，若 mode 值的定義變更，所有呼叫該函式的地方都需同步修改 Data-Structure Coupling（資料結構耦合）\n多個模組共用相同的 data structure 範例：若所有模組都依賴一個 dict 來存取資料，當 dict 結構變更時，所有模組都會受到影響 Loose Coupling（鬆散耦合） Data Coupling（資料耦合）\n模組之間僅透過資料交換（參數或回傳值）來溝通 範例：函式 calculateTax(amount) 接受 amount 參數，而不依賴全域變數 Message Coupling（訊息耦合）\n模組之間透過訊息或指令進行溝通，而不是直接影響彼此的邏輯 範例：一個模組透過 event bus 發送 order_created 訊息，另一個模組根據訊息執行相應動作（而不依賴具體的函式呼叫） Cohesion（內聚） 衡量模組內部功能的相關性，內聚度越高，模組的單一性越強，功能更專注且更易於維護\nWeak Cohesion（弱內聚） Coincidental Cohesion（偶然內聚）\n模組內的功能沒有關聯，只是被放在同一個檔案內 範例：單一檔案內包含不相關的函式，如 calculateTax() 和 generateReport() Temporal Cohesion（時間內聚）\n功能的唯一關聯是它們在相同時間執行 範例：Initializer 類別內包含 initDatabase()、initCache()、initLogger()，這些功能只在初始化時執行，內聚度較低 Logical Cohesion（邏輯內聚）\n模組內的功能可以被歸類為相同的類別 範例：BackupController 負責多種不同類型的備份，沒有專注於單一職責 Medium Cohesion（中等內聚） Procedural Cohesion（程序內聚）\n模組內的功能需要以特定順序執行 範例：Sender 類別內包含 connect()、sendData()、disconnect()，這些功能需要按照順序執行，內聚度較高 Communicational Cohesion（通信內聚）\n模組內的功能都圍繞在某個特定資料結構上 範例：ShoppingCart 類別內包含 addItem()、removeItem()、calculateTotal()，這些功能都圍繞在 items 屬性上 Sequential Cohesion（順序內聚）\n某個函式的輸出作為另一個函式的輸入，且具有執行順序 範例：readData() → processData() → saveData()，內聚度相對較高，但仍可能包含非核心功能 Strong Cohesion（強內聚） Functional Cohesion（功能內聚） 模組中的各部分都對模組中單一明確的目標有貢獻 範例：CalculateCircleArea 類別僅包含 calculateArea() 方法，專注於計算圓形面積 ","date":"2023-03-08T14:26:17+08:00","permalink":"https://roykesydon.github.io/Blog/p/%E8%BB%9F%E9%AB%94%E8%A8%AD%E8%A8%88-low-level/","title":"軟體設計 - Low Level"},{"content":"介紹 一種用於自動化找超參數的方法，用在採樣昂貴而且是黑盒子的情況\n流程 取樣一些資料點 生出一個 Surrogate Model(可採用 Gaussian Process) 反覆做以下事情 用 Acquisition Function 挑選下一個要採樣的點 重新評估 Surrogate Model Gaussian Process 最終的 prediction 是一個 distribution 而不是單一個數字 生成方法需借助 kernel function，常用 RBF(Radial Basis Function)\n$K(x, x^{\u0026rsquo;}|\\tau)=\\sigma^2exp(-\\frac{1}{2}(\\frac{x-x^{\u0026rsquo;}}{l})^2)$\n$\\sigma$ 和 $l$ 是兩個可以調整的超參數\nAcquisition Function 可用超參數來調節 exploitation 和 exploitation\nUCB(Upper confidence bound) PI(probability of improvement) EI(Expected improvement) ","date":"2023-01-26T01:36:53+08:00","permalink":"https://roykesydon.github.io/Blog/p/bayesian-optimization/","title":"Bayesian Optimization"}]